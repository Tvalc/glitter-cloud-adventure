<!doctype html>
<html lang="en">
<!-- CACHE BUSTER: 20250513_1825 -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Glitter Cloud Adventure</title>
    <script>
      // RELIC SYSTEM IMPLEMENTATION - Single global instance
      window.RELIC_SYSTEM = {
        // Track initialized state
        initialized: false,
        
        // Get fury required for a specific level
        getFuryForNextLevel(currentLevel) {
          return Math.floor(200 * Math.pow(1.5, currentLevel - 1));
        },
        
        // Initialize the relic system for a player
        initializeRelics(player) {
          console.log('Initializing relics for player');
          if (!player) return;
          
          // Create relics object if it doesn't exist
          if (!player.relics) {
            player.relics = {};
          }
          
          // Track which relics have had bonuses applied (to prevent stacking)
          if (!player.appliedRelicBonuses) {
            player.appliedRelicBonuses = {};
          }
          
          // Initialize equipment object if it doesn't exist
          if (!player.equipment) {
            player.equipment = {};
          }
          
          // Ensure relic slots are properly initialized
          if (player.equipment.relic_1 === undefined) {
            player.equipment.relic_1 = null;
          }
          
          if (player.equipment.relic_2 === undefined) {
            player.equipment.relic_2 = null;
          }
          
          // Initialize glitchStick if it doesn't exist
          if (!player.relics.glitchStick) {
            player.relics.glitchStick = {
              id: 'glitchStick',
              name: 'Glitch Stick',
              level: 0, // Start at level 0 (inactive)
              fury: 0,
              furyToNextLevel: this.getFuryForNextLevel(1),
              maxLevel: 5,
              description: 'A mysterious USB stick that contains... something.',
              fightsSinceLastUse: 0,
              abilities: [
                {
                  level: 1,
                  name: 'Reality Guide',
                  description: '+1 to all stats, summon your guide to give you a hint about what to do next'
                },
                {
                  level: 2,
                  name: 'Basic Shop Access',
                  description: '+2 to all stats, summon your guide who will let you access a shop to buy and sell consumable items'
                },
                {
                  level: 3,
                  name: 'Advanced Shop Access',
                  description: '+3 to all stats, summon your guide who will let you access a shop to buy and sell consumable items, armor, and weapons'
                },
                {
                  level: 4,
                  name: 'Relic Fusion',
                  description: '+4 to all stats, summon your guide who will let you fuse relic pieces together to create new relics'
                },
                {
                  level: 5,
                  name: 'Guide\'s Blessing',
                  description: '+5 to all stats, summon your guide to heal you and your party and restore your MP, this can only be used once every 20 fights'
                }
              ]
            };
          }
          
          this.initialized = true;
          console.log('Relic system initialized for player', player.name || 'Unknown');
        },
        
        // Acquire the Glitch Stick relic
        acquireGlitchStick(player) {
          if (!player) return false;
          
          // Initialize relics if needed
          if (!player.relics) {
            this.initializeRelics(player);
          }
          
          // If player already has the Glitch Stick, don't give it again
          if (player.relics.glitchStick && player.relics.glitchStick.level > 0) {
            return false;
          }
          
          // Set Glitch Stick to level 1 but DO NOT apply bonuses yet (only apply on equip)
          player.relics.glitchStick.level = 1;
          player.relics.glitchStick.furyToNextLevel = this.getFuryForNextLevel(2);
          
          // Display message
          if (typeof UIManager !== 'undefined' && UIManager.log) {
            UIManager.log('You acquired the Glitch Stick! Your guide will now assist you on your journey.');
            UIManager.log('The Glitch Stick grants +1 to all stats when equipped and allows you to summon your guide for hints.');
          } else {
            console.log('Acquired Glitch Stick relic');
          }
          
          // Make sure to update character screen if it's open
          if (document.getElementById('characterScreen') && 
              document.getElementById('characterScreen').style.display !== 'none') {
            if (typeof ensureRelicsTab === 'function') {
              ensureRelicsTab();
              updateRelicsTab(player);
            }
          }
          
          return true;
        },
        
        // Apply relic bonuses to player stats
        applyRelicBonuses(player, relicName) {
          const relic = player.relics[relicName];
          if (!relic) return;

          // Make sure player has equipment object
          if (!player.equipment) {
            player.equipment = {};
          }
          
          // Make sure relic slots exist
          if (player.equipment.relic_1 === undefined) {
            player.equipment.relic_1 = null;
          }
          
          if (player.equipment.relic_2 === undefined) {
            player.equipment.relic_2 = null;
          }

          // CRITICAL DEBUG: Find when the relics tab disappears
          console.log('[CRITICAL DEBUG] About to equip relic:', relicName);
          debugDOMState('Before equipping relic ' + relicName);
          
          // Store whether this relic's bonuses have been applied already
          if (!player.appliedRelicBonuses) {
            player.appliedRelicBonuses = {};
            console.log('[DEBUG] Created player.appliedRelicBonuses');
          }
          
          // Only apply if not already applied
          if (!player.appliedRelicBonuses[relicName]) {
            console.log('[DEBUG] Relic not yet applied, applying now:', relicName);
            
            // FORCE TAB TO STAY VISIBLE - critical fix before we do anything else
            try {
              const relicsTab = document.getElementById('relics-tab');
              if (!relicsTab) {
                console.log('[CRITICAL DEBUG] relics-tab MISSING before equipping! Recreating...');
                window.ensureRelicsTab();
              }
            } catch (e) {
              console.error('[ERROR] Error checking for relics tab:', e);
            }
            
            // Count how many relics are currently equipped
            let equippedCount = 0;
            for (const key in player.appliedRelicBonuses) {
              if (player.appliedRelicBonuses[key] === true) {
                equippedCount++;
                console.log('[DEBUG] Found equipped relic:', key);
              }
            }
            
            // Prevent equipping more than 2 relics
            if (equippedCount >= 2) {
              console.log('Cannot equip more than 2 relics at a time');
              if (typeof UIManager !== 'undefined' && UIManager.log) {
                UIManager.log('You cannot equip more than 2 relics at a time. Unequip a relic first.');
              }
              return;
            }
            
            // Remember HP/MP status to maintain after stat recalculation
            const wasAtMaxHP = player.derivedStats && player.hp >= player.derivedStats.maxHp - 1;
            const wasAtMaxMP = player.derivedStats && player.mp >= player.derivedStats.maxMp - 1;
            
            // Apply stat bonuses
            player.stats.strength += relic.level;
            player.stats.dexterity += relic.level;
            player.stats.intelligence += relic.level;
            player.stats.vitality += relic.level;
            player.stats.fortune += relic.level;
            player.stats.charisma += relic.level;
            
            // Add to equipment slot - this is critical for proper display
            if (player.equipment.relic_1 === null) {
              player.equipment.relic_1 = {
                name: relic.name,
                type: 'relic',
                relicId: relicName,
                level: relic.level
              };
              console.log(`Added ${relicName} to relic_1 slot`);
            } else if (player.equipment.relic_2 === null) {
              player.equipment.relic_2 = {
                name: relic.name,
                type: 'relic',
                relicId: relicName,
                level: relic.level
              };
              console.log(`Added ${relicName} to relic_2 slot`);
            } else {
              console.log('No available relic slots - something went wrong');
              return;
            }
            
            // CRITICAL DEBUGGING: Add diagnostic before applying relic bonuses
            console.log(`[CRITICAL DEBUG] About to mark relic ${relicName} as applied`);
            debugDOMState('Before marking relic as applied');
            
            // Mark as applied
            player.appliedRelicBonuses[relicName] = true;
            
            console.log(`Applied relic bonuses for ${relicName}: +${relic.level} to all stats`);
            
            // Force the relics tab to stay in DOM before updating stats
            try {
              const relicsTab = document.getElementById('relics-tab');
              console.log('[CRITICAL DEBUG] relics-tab exists before updateCharacterStats:', !!relicsTab);
              if (!relicsTab) {
                console.log('[CRITICAL FIX] Recreating missing relics tab before updateCharacterStats');
                window.ensureRelicsTab();
              }
            } catch (e) {
              console.error('[ERROR] Error checking for relics tab:', e);
            }
            
            // Recalculate derived stats
            if (typeof LEVELING_SYSTEM !== 'undefined' && typeof LEVELING_SYSTEM.updateCharacterStats === 'function') {
              console.log('[CRITICAL DEBUG] About to call updateCharacterStats');
              LEVELING_SYSTEM.updateCharacterStats(player);
              console.log('Recalculated derived stats after applying relic bonuses');
              
              // Check if relics tab still exists AFTER updateCharacterStats
              debugDOMState('After updateCharacterStats');
              
              // If relics tab disappeared, recreate it immediately
              const relicsTabAfter = document.getElementById('relics-tab');
              if (!relicsTabAfter) {
                console.log('[CRITICAL FIX] Relics tab disappeared during updateCharacterStats! Recreating...');
                window.ensureRelicsTab();
              }
              
              // Maintain max HP/MP status if player was at max
              if (wasAtMaxHP && player.derivedStats) {
                player.hp = player.derivedStats.maxHp;
              }
              
              if (wasAtMaxMP && player.derivedStats) {
                player.mp = player.derivedStats.maxMp;
              }
            }
            
            // Update UI to reflect stat changes
            if (typeof updateCharacterScreen === 'function') {
              updateCharacterScreen();
              console.log('Updated character screen after applying relic bonuses');
            }
          } else {
            player.stats.dexterity -= relic.level;
            player.stats.intelligence -= relic.level;
            player.stats.vitality -= relic.level;
            player.stats.fortune -= relic.level;
            player.stats.charisma -= relic.level;
            
            // Mark as not applied
            player.appliedRelicBonuses[relicName] = false;
            
            console.log(`Removed relic bonuses for ${relicName}: -${relic.level} from all stats`);
            
            // Recalculate derived stats
            if (typeof LEVELING_SYSTEM !== 'undefined' && typeof LEVELING_SYSTEM.updateCharacterStats === 'function') {
              LEVELING_SYSTEM.updateCharacterStats(player);
            }
            
            // Update UI to reflect stat changes
            if (typeof updateCharacterScreen === 'function') {
              updateCharacterScreen();
            }
          }
        }
      };
      
      // Define functions for relics tab
      window.ensureRelicsTab = function() {
        console.log('Ensuring relics tab exists...');
        const characterScreen = document.getElementById('characterScreen');
        if (!characterScreen) return;
        
        // Check if relics tab already exists
        if (!document.getElementById('relics-tab')) {
          // Create relics tab content
          const relicsTabContent = document.createElement('div');
          relicsTabContent.className = 'tab-content';
          relicsTabContent.id = 'relics-tab';
          relicsTabContent.innerHTML = `
            <div class="equipment-screen-content">
              <div class="equipment-list" id="relics-list">
                <!-- Relics will be added here dynamically -->
              </div>
              <div class="equipment-tooltip" id="relicTooltip">
                <div class="title">Relic Information</div>
                <div class="description">Click on a relic to see details</div>
              </div>
            </div>
          `;
          
          // Append to character screen
          characterScreen.appendChild(relicsTabContent);
          
          // Make sure tab button exists
          const tabButtons = characterScreen.querySelectorAll('.tab-button');
          let hasRelicsTab = false;
          
          for (const button of tabButtons) {
            if (button.getAttribute('data-tab') === 'relics-tab') {
              hasRelicsTab = true;
              break;
            }
          }
          
          if (!hasRelicsTab) {
            // Find the tab-scroll element
            const tabScroll = document.getElementById('tab-scroll');
            if (tabScroll) {
              // Create relics tab button
              const relicsTabButton = document.createElement('button');
              relicsTabButton.className = 'tab-button';
              relicsTabButton.setAttribute('data-tab', 'relics-tab');
              relicsTabButton.textContent = 'Relics';
              
              // Add to tab-scroll
              tabScroll.appendChild(relicsTabButton);
              
              // Add event listener (handled by general tab system)
            }
          }
          
          console.log('Relics tab created and added to character screen');
        }
      };
      
      window.updateRelicsTab = function(player) {
        console.log('Updating relics tab...');
        // Use the permanent relics container instead of relics-list
        const relicsContainer = document.getElementById('relics-container');
        if (!relicsContainer) {
          console.warn('Relics container element not found');
          return;
        }
        
        // Get the tooltip element for displaying ability details
        const relicTooltip = document.getElementById('relicTooltip');
        
        // Clear existing content
        relicsContainer.innerHTML = '';
        
        // Track if we have any relics to show (either in inventory or equipped)
        let hasVisibleRelics = false;
        
        // First check equipped relics in player.equipment
        if (player.equipment) {
          // Look for equipped relics
          for (const slot in player.equipment) {
            if (slot === 'relic_1' || slot === 'relic_2') {
              const equipped = player.equipment[slot];
              if (equipped && equipped.relicId) {
                hasVisibleRelics = true;
                // Don't break, we want to keep counting all equipped relics
              }
            }
          }
        }
        
        // Now check visible relics in player.relics
        if (player.relics) {
          for (const relicKey in player.relics) {
            if (player.relics[relicKey].level > 0) {
              hasVisibleRelics = true;
              break;
            }
          }
        }
        
        // CRITICAL FIX: Always show the relics tab even if empty, just like skills and spells tabs
        if (!hasVisibleRelics) {
          relicsContainer.innerHTML = '<div class="empty-message">No relics found</div>';
          // Critical: DO NOT return here, we still need to finish the function
        }
        
        // Force the tab to stay in DOM - just like skills and spells tabs
        const relicsTab = document.getElementById('relics-tab');
        if (relicsTab) {
          // Ensure it has a higher z-index to prevent flickering
          relicsTab.style.zIndex = '5';
        }
        
        // Only proceed with adding relics if we have any
        if (hasVisibleRelics && player.relics) {
          // Add each relic to the list, including equipped ones
          for (const [relicKey, relic] of Object.entries(player.relics)) {
            // Skip relics with level 0 (not yet acquired) UNLESS they are equipped
            const isEquipped = player.equipment?.relic_1?.relicId === relicKey || 
                              player.equipment?.relic_2?.relicId === relicKey;
                              
            // Show relic if it's acquired (level > 0) OR if it's equipped
            if (relic.level === 0 && !isEquipped) continue;
            
            const relicItem = document.createElement('div');
            relicItem.className = 'relic-item';
            
            let abilitiesHTML = '';
            if (relic.abilities && relic.abilities.length > 0) {
              abilitiesHTML = `
                <div class="relic-abilities">
                  ${relic.abilities.map(ability => `
                    <div class="ability-item" data-ability-name="${ability.name}" data-ability-level="${ability.level}" data-ability-unlocked="${ability.level <= relic.level}" data-ability-description="${ability.description}">
                      <div class="ability-level ${ability.level <= relic.level ? 'unlocked' : 'locked'}">${ability.level}</div>
                      <div class="ability-info">
                        <div class="ability-name ${ability.level <= relic.level ? '' : 'locked'}" style="text-align: left !important;">${ability.name}</div>
                        <div class="ability-description">${ability.description}</div>
                      </div>
                    </div>
                  `).join('')}
                </div>
              `;
            }
            
            let furyBarHTML = '';
            if (relic.level < (relic.maxLevel || 5)) {
              const furyPercent = Math.min(100, Math.floor((relic.fury / relic.furyToNextLevel) * 100));
              furyBarHTML = `
                <div class="fury-bar">
                  <div class="fury-fill" style="width: ${furyPercent}%"></div>
                </div>
                <div class="fury-text">${relic.fury}/${relic.furyToNextLevel} Fury</div>
              `;
            }
            
            relicItem.innerHTML = `
              <div class="relic-header">
                <span class="relic-name">${relic.name}</span>
                <span class="relic-level">Lvl ${relic.level}</span>
              </div>
              <div class="relic-description">${relic.description || ''}</div>
              ${furyBarHTML}
              <div class="relic-stats">+${relic.level} to all stats when equipped</div>
              ${abilitiesHTML}
            `;
            
            // Add click event to use the relic ability
            relicItem.addEventListener('click', () => {
              if (window.RELIC_SYSTEM) {
                window.RELIC_SYSTEM.useRelicAbility(player, relicKey);
                updateRelicsTab(player); // Refresh the display
              } else {
                console.error('RELIC_SYSTEM not found!');
              }
            });
            
            relicsContainer.appendChild(relicItem);
          } // Close for loop
        } // Close if hasVisibleRelics
        
        // Use the PERMANENT tooltip in the UI instead of creating a popup tooltip
        // Add event listeners to JUST the ability level elements (not the whole item)
        const abilityLevels = relicsContainer.querySelectorAll('.ability-level');
        
        abilityLevels.forEach(levelElement => {
          levelElement.addEventListener('click', function(e) {
            // Prevent event propagation to parent elements
            e.stopPropagation();
            
            // Get the parent ability item
            const abilityItem = this.closest('.ability-item');
            if (!abilityItem) return;
            
            // Get ability details from data attributes
            const name = abilityItem.getAttribute('data-ability-name');
            const level = abilityItem.getAttribute('data-ability-level');
            const description = abilityItem.getAttribute('data-ability-description');
            const isUnlocked = abilityItem.getAttribute('data-ability-unlocked') === 'true';
            
            // Update the fixed tooltip at the bottom of the screen with ability details
            if (relicTooltip) {
              const titleElement = relicTooltip.querySelector('.title');
              const descriptionElement = relicTooltip.querySelector('.description');
              
              if (titleElement && descriptionElement) {
                titleElement.innerHTML = isUnlocked 
                  ? `<span style="color: #00ff00">${name} (Level ${level})</span>` 
                  : `<span style="color: #ff8800">${name} (Level ${level} - Locked)</span>`;
                
                descriptionElement.innerHTML = isUnlocked 
                  ? `${description}<br><span style="color: #00ff00">Ability Unlocked!</span>` 
                  : `<span style="color: #aaaaaa">${description}</span><br><span style="color: #ffff00">Upgrade your relic to level ${level} to unlock.</span>`;
              }
            }
            
            console.log('Showing details for ability: ' + name);
          });
        });
        
        console.log('Relics tab updated with player relics');
      };
      
      // We're using the fixed tooltip in the tab instead of a floating tooltip
      // This ensures tooltips work consistently with the rest of the UI
      console.log('Using fixed tooltips for relic abilities instead of popup tooltips');
      
      function showAbilityTooltip(element, name, description, isUnlocked) {
        // Get the tooltip element
        const tooltip = document.getElementById('relicTooltip');
        if (!tooltip) return;
        
        // Update tooltip content
        tooltip.innerHTML = `
          <div class="title">${name} ${isUnlocked ? '(Unlocked)' : '(Locked)'}</div>
          <div class="description">${description}</div>
        `;
        
        // Position the tooltip 5px below the abilities list
        const relicAbilities = document.querySelector('.relic-abilities');
        if (relicAbilities) {
          tooltip.style.position = 'absolute';
          tooltip.style.top = (relicAbilities.offsetHeight + 5) + 'px';
          tooltip.style.bottom = 'auto';
          tooltip.style.left = '0';
          tooltip.style.right = '0';
          tooltip.style.width = '100%';
        }
        
        // Make tooltip visible
        tooltip.style.display = 'block';
      }
      
      function hideAbilityTooltip() {
        // Reset the tooltip content
        const tooltip = document.getElementById('relicTooltip');
        if (!tooltip) return;
        
        tooltip.innerHTML = `
          <div class="title">Relic Information</div>
          <div class="description">Hover over a relic ability to see details</div>
        `;
      }
      
      // Function to show equipment info in the equipment tab
      function showEquipmentInfo(slot, item) {
        if (!item) return;
        
        const tooltip = document.getElementById('equipmentTooltip');
        if (!tooltip) return;
        
        let content = '';
        
        if (slot.startsWith('relic_')) {
          // This is a relic
          content = `
            <div class="title">${item.name} (Level ${item.level})</div>
            <div class="stat-info">+${item.level} to all stats</div>
          `;
          
          // Add abilities if available
          if (item.abilities && item.abilities.length > 0) {
            content += '<div class="ability-list">';
            for (const ability of item.abilities) {
              if (ability.level <= item.level) {
                content += `<div class="ability-item">${ability.name}: ${ability.description}</div>`;
              }
            }
            content += '</div>';
          }
        } else {
          // Regular equipment
          content = `
            <div class="title">${item.name}</div>
            <div class="description">${item.description || ''}</div>
          `;
          
          // Add stats if available
          if (item.stats) {
            content += '<div class="stats-list">';
            for (const [stat, value] of Object.entries(item.stats)) {
              content += `<div class="stat-item">${stat}: ${value > 0 ? '+' : ''}${value}</div>`;
            }
            content += '</div>';
          }
        }
        
        tooltip.innerHTML = content;
      }
      
      // Function to hide ability tooltip (not needed for fixed tooltip, but kept for compatibility)
      function hideAbilityTooltip() {
        // No need to hide the fixed tooltip as it's always visible
        console.log('Fixed tooltip always remains visible');
      }
      
      // Add CSS for relics (note: .relic-level is now in the main CSS section)
      const relicStyles = document.createElement('style');
      relicStyles.textContent = `
        /* Tooltip styles */
        .ability-tooltip {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: rgba(0, 0, 0, 0.9);
          border: 2px solid #00ffff;
          border-radius: 5px;
          padding: 10px;
          color: #00ffff;
          font-family: 'Game Font', monospace;
          z-index: 1000;
          max-width: 300px;
          text-align: center;
        }
        
        .ability-tooltip .title {
          font-size: 14px;
          font-weight: bold;
          margin-bottom: 5px;
          color: #ffffff;
        }
        
        .ability-tooltip .description {
          font-size: 12px;
          color: #00ff00;
        }
        
        /* Relic item styles */
        .relic-item {
          position: relative;
          width: 100%;
          background-color: rgba(0, 0, 0, 0.8);
          border: 2px solid #00ffff;
          border-radius: 5px;
          padding: 10px;
          margin-bottom: 15px;
          box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
          transition: all 0.3s ease;
        }
        
        .relic-item.equipped {
          border-color: #00ff00;
          box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
        
        .relic-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
          cursor: pointer;
        }
        
        .relic-name {
          color: #ffffff;
          font-size: 16px;
          font-weight: bold;
        }
        
        .relic-level {
          color: #00ffff;
          font-size: 14px;
          background-color: rgba(0, 0, 0, 0.6);
          border: 1px solid #00ffff;
          border-radius: 3px;
          padding: 2px 5px;
        }
        
        .relic-description {
          color: #cccccc;
          font-size: 12px;
          margin-bottom: 10px;
        }
        
        .fury-bar {
          height: 8px;
          background-color: rgba(255, 0, 0, 0.3);
          border-radius: 4px;
          margin-bottom: 5px;
          position: relative;
          overflow: hidden;
        }
        
        .fury-fill {
          height: 100%;
          background: linear-gradient(90deg, #ff0000, #ff6600);
          border-radius: 4px;
          width: 0%;
          transition: width 0.5s ease;
        }
        
        .fury-text {
          font-size: 10px;
          color: #ff6600;
          text-align: right;
          margin-bottom: 8px;
        }
        
        .relic-stats {
          color: #00ff00;
          font-size: 12px;
          margin-bottom: 10px;
          text-align: center;
          padding: 5px;
          background-color: rgba(0, 0, 0, 0.5);
          border-radius: 3px;
        }
        
        /* Relic grid layout */
        .relic-grid {
          display: grid;
          grid-template-columns: repeat(2, 1fr); /* Change to 2 columns for better spacing */
          grid-gap: 8px; /* Add consistent gap between items */
          color: #00ffff;
          position: relative;
          margin-bottom: 60px; /* Add space for the tooltip below */
        }
        
        .level-number {
          font-size: 10px;
          color: #aaa;
          position: absolute;
          top: 2px;
          left: 4px;
        }
        
        .level-name {
          font-size: 11px;
          text-align: center;
          padding: 8px 0;
        }
        
        .ability-level.locked {
          color: #555555;
        }
        
        .ability-info {
          margin-top: 3px;
        }
        
        .ability-name {
          font-size: 10px;
          color: #ffffff;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          max-width: 100px;
        }
        
        .ability-name.locked {
          color: #555555;
        }
        
        @keyframes pulse {
          0% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0.7); }
          70% { box-shadow: 0 0 0 10px rgba(0, 255, 255, 0); }
          100% { box-shadow: 0 0 0 0 rgba(0, 255, 255, 0); }
        }
        
        .relic-item.equipped .relic-header {
          animation: pulse 2s infinite;
        }
        
        .ability-item:hover {
          background-color: rgba(0, 0, 30, 0.8);
        }
        
        .ability-description {
          font-size: 10px;
          color: #ccc;
        }
        
        .equipment-item .relic-name {
          color: #00ffff;
        }
        
        /* Center the relic slots in the equipment tab */
        .equipment-screen-content .equipment-list {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
          gap: 10px;
        }
        
        /* Equipment tooltip enhancements */
        .equipment-tooltip .ability-list {
          margin-top: 5px;
          border-top: 1px solid #00ffff;
          padding-top: 5px;
        }
        
        .equipment-tooltip .ability-item {
          margin-bottom: 3px;
          font-size: 10px;
          color: #00ff00;
        }
        
        .equipment-tooltip .stat-info {
          color: #00ffff;
          margin: 5px 0;
        }
        
        .equipment-tooltip .stats-list {
          margin-top: 5px;
          border-top: 1px solid #555;
          padding-top: 5px;
        }
        
        .equipment-tooltip .stat-item {
          color: #00ffff;
          font-size: 10px;
          margin-bottom: 2px;
        }
      `;
      document.head.appendChild(relicStyles);

      
      // Force a refresh of the relics tab to ensure styles are applied
      if (window.player && window.player.relics) {
        console.log('Forcing relics tab refresh to apply styles');
        window.updateRelicsTab(window.player);
        
        // Add a MutationObserver to prevent the tab from being removed when it's "empty"
        // This is a critical fix to ensure the relics tab stays visible just like spells and skills tabs
        const observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' && mutation.removedNodes.length > 0) {
              // Check if our relics tab was removed
              for (let i = 0; i < mutation.removedNodes.length; i++) {
                const node = mutation.removedNodes[i];
                if (node.id === 'relics-tab') {
                  console.log('[CRITICAL FIX] Detected relics tab removal, restoring it');
                  // The tab was removed, add it back
                  window.ensureRelicsTab();
                  window.updateRelicsTab(window.player);
                  setTimeout(function() {
                    window.keepRelicsVisibleInTab(window.player);
                  }, 50);
                  return;
                }
              }
            }
          });
        });
        
        // Start observing the character screen for changes
        const characterScreen = document.getElementById('characterScreen');
        if (characterScreen) {
          observer.observe(characterScreen, { childList: true, subtree: true });
          console.log('[CRITICAL FIX] Added observer to prevent relics tab removal');
        }
      }
      
      // Force cache busting and clear any stored game state
      const VERSION = '20250516_2022';
      console.log('Game Version:', VERSION);
      // Force a clear of localStorage to ensure changes take effect
      localStorage.clear();
      console.log('Local storage cleared to force game refresh');
      
      // If the page was loaded from cache, force a refresh
      window.onload = function() {
        if (document.getElementById('force-refresh')) {
          return; // Already refreshed
        }
        const marker = document.createElement('div');
        marker.id = 'force-refresh';
        marker.style.display = 'none';
        document.body.appendChild(marker);
        console.log('Force refresh mechanism active');
      };
    </script>
    <style>
      /* Replacing pixel font with mobile-friendly typewriter font */
      @font-face {
        font-family: "Game Font";
        src: local("Courier New");
      }
      
      /* Relic Level Display - Moved from dynamic styles to ensure consistent application */
      .relic-level {
        color: #00ff00;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 6px;
        border-radius: 10px;
        border: 1px solid #00ff00;
        min-width: 60px;
        text-align: center;
        display: inline-block;
      }

      @font-face {
        font-family: "Monoton";
        src: url("https://fonts.googleapis.com/css2?family=Monoton&display=swap");
      }

      /* Add shake animation keyframes */
      @keyframes shake {
        0% {
          transform: translateX(0);
        }
        10% {
          transform: translateX(-5px);
        }
        20% {
          transform: translateX(5px);
        }
        30% {
          transform: translateX(-5px);
        }
        40% {
          transform: translateX(5px);
        }
        50% {
          transform: translateX(-5px);
        }
        60% {
          transform: translateX(5px);
        }
        70% {
          transform: translateX(-5px);
        }
        80% {
          transform: translateX(5px);
        }
        90% {
          transform: translateX(-5px);
        }
        100% {
          transform: translateX(0);
        }
      }

      /* Add dialogue animations */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }
      @keyframes pulse {
        0% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.5;
        }
      }

      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: #000;
        font-family: "Courier New", Courier, monospace;
        overflow: hidden;
      }

      #introScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding-bottom: 50px;
        cursor: pointer;
      }

      .command-prompt {
        color: #00ffff;
        font-size: 12px;
        line-height: 1.5;
        max-width: 800px;
        padding: 20px;
      }

      .spacebar-text {
        position: absolute;
        bottom: 40px;
        font-size: 12px;
        color: #00ffff;
        text-align: center;
      }
      #game-container {
        position: relative;
        width: 800px;
        height: 600px;
        background: #111;
        border: 4px solid #333;
        display: flex;
        flex-direction: column;
      }
      #topNav {
        position: relative;
        height: 40px;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0 10px;
        color: #fff;
        z-index: 1;
        border-bottom: 2px solid #8b4513;
      }
      #gameCanvas {
        flex: 1;
        width: 100%;
        height: calc(100% - 40px);
        image-rendering: pixelated;
      }
      #gameLog {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100px;
        background: rgba(0, 0, 0, 0.9);
        color: #fff;
        padding: 10px;
        overflow-y: auto;
        font-size: 12px;
        display: none;
        border-top: 2px solid #8b4513;
        z-index: 2;
      }
      #messageIndicator {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: #00ffff;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        display: none;
        border: 1px solid #00ffff;
        animation: pulse 2s infinite;
        z-index: 1;
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
      #startScreen {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GlitterStart-eWtnNjTcWxXyheoQtPcBK9MDLQWYBK.png?koxn")
          no-repeat center center;
        background-size: cover;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
      }

      #characterScreen {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 800px;
        height: 600px;
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #00ffff;
        color: #00ffff;
        z-index: 1000;
        display: none;
        padding: 20px;
        box-sizing: border-box;
        overflow: hidden;
      }

      .tab-navigation {
        display: flex;
        width: 100%;
        gap: 0;
        border: none;
        background: none;
        margin-bottom: 20px;
      }

      .tab-button {
        flex: 1 1 0;
        min-width: 0;
        padding: 12px 0;
        background: rgba(0, 0, 0, 0.8);
        border: none;
        color: #00ffff;
        cursor: pointer;
        font-size: 15px;
        text-align: center;
        border-bottom: 2px solid transparent;
        border-radius: 0;
        outline: none;
        margin: 0;
        box-shadow: none;
        transition:
          background 0.2s,
          color 0.2s,
          border-bottom 0.2s;
      }
      .tab-button[data-tab="stats-tab"] {
        flex: 0.8 1 0;
      }
      .tab-button[data-tab="equipment-tab"] {
        flex: 1.3 1 0;
      }

      /* Move skills content 5px to the left to prevent overflow */
      #skills-tab .equipment-list {
        margin-left: -5px;
      }

      .tab-button.active,
      .tab-button:hover {
        border-bottom: 2px solid #00ffff;
        color: #fff;
        background: rgba(0, 210, 211, 0.2);
      }

      @media screen and (max-width: 800px) {
        #game-container {
          width: 100%;
          height: 100vh;
          border: none;
        }

        #topNav {
          border-bottom: none;
        }

        #characterScreen {
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          width: 100%;
          max-width: 100%;
          height: 100vh;
          max-height: 100vh;
          transform: none;
          border: none;
          padding: 10px;
        }

        .tab-navigation {
          gap: 2px;
          padding: 5px;
          flex-wrap: wrap;
          width: 100%;
          max-width: 100%;
          margin: 0;
          box-sizing: border-box;
        }

        .tab-button {
          padding: 5px 10px;
          font-size: 12px;
          flex: 1;
          min-width: 60px;
          text-align: center;
        }
      }

      #startScreen::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
        z-index: 1;
      }

      #startScreen .start-content {
        margin-top: 60%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        position: relative;
        z-index: 2;
        animation: float 3s ease-in-out infinite;
      }
      #startScreen .button {
        background: linear-gradient(135deg, rgba(153, 50, 204, 0.8) 0%, rgba(153, 50, 204, 0.4) 100%);
        border: 2px solid #9932cc;
        color: #00ffff;
        font-family: "Courier New", Courier, monospace;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-shadow:
          0 0 10px #000,
          0 0 20px #000,
          0 0 30px #00ffff;
        box-shadow: 0 0 20px rgba(153, 50, 204, 0.5);
        border-radius: 25px;
        position: relative;
        overflow: hidden;
        min-width: 200px;
        text-align: center;
        z-index: 3;
        padding: 15px 30px;
        animation: buttonPulse 2s infinite;
      }
      #startScreen .button:hover {
        background: linear-gradient(135deg, rgba(153, 50, 204, 1) 0%, rgba(153, 50, 204, 0.6) 100%);
        transform: scale(1.05);
        text-shadow:
          0 0 20px #000,
          0 0 30px #000,
          0 0 40px #00ffff; /* Updated to cyan for better visibility */
      }
      #startScreen h1 {
        font-size: 42px;
        font-family: "Monoton", cursive;
        text-align: center;
        color: #9932cc; /* Electric purple */
        text-shadow:
          0 0 7px #9932cc,
          0 0 10px #9932cc,
          0 0 21px #9932cc,
          0 0 42px #9932cc,
          0 0 82px #9932cc,
          0 0 92px #9932cc,
          0 0 102px #9932cc,
          0 0 151px #9932cc;
        animation: glow 2s ease-in-out infinite alternate;
      }
      @keyframes flicker {
        0%,
        18%,
        22%,
        25%,
        53%,
        57%,
        100% {
          text-shadow:
            0 0 7px #9932cc,
            0 0 10px #9932cc,
            0 0 21px #9932cc,
            0 0 42px #9932cc,
            0 0 82px #9932cc,
            0 0 92px #9932cc,
            0 0 102px #9932cc,
            0 0 151px #9932cc;
        }
        20%,
        24%,
        55% {
          text-shadow: none;
        }
      }
      @font-face {
        font-family: "Monoton";
        src: url("https://fonts.googleapis.com/css2?family=Monoton&display=swap");
      }
      #characterSelect {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GlitterStart-eWtnNjTcWxXyheoQtPcBK9MDLQWYBK.png?koxn")
          no-repeat center center;
        background-size: cover;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: #00ffff;
        z-index: 2;
        padding: 20px;
        box-sizing: border-box;
      }
      #characterSelect h2 {
        font-size: 24px;
        margin: 0 0 10px 0;
        color: #00ffff;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        letter-spacing: 1px;
        font-family: "MedievalSharp", "Georgia", serif;
        text-align: center;
      }
      #characterSelect h3 {
        font-size: 12px;
        margin: 0 0 20px 0;
        color: #00ffff;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-family: "Luminari", "Georgia", serif;
        text-align: center;
        font-style: italic;
      }
      #characterList {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 345px;
        margin: -10px auto 0;
      }
      .character-card {
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #00ffff;
        border-radius: 8px;
        padding: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        width: 100%;
        box-sizing: border-box;
      }
      .character-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 0 20px rgba(0, 210, 211, 0.5);
      }
      .character-card.selected {
        background: rgba(0, 210, 211, 0.1);
        border-color: #fff7d6;
      }
      .character-card h3 {
        color: #00ffff;
        margin: 0 0 5px 0;
        font-size: 18px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }
      .character-card p {
        color: #fff;
        margin: 5px 0;
        font-size: 12px;
      }
      .character-card .stats {
        margin-top: 5px;
        padding-top: 5px;
        border-top: 1px solid rgba(0, 210, 211, 0.3);
      }
      .character-card .stat {
        display: flex;
        justify-content: space-between;
        margin: 5px 0;
        color: #fff;
        font-size: 12px;
      }
      .character-card .stat-label {
        color: #00ffff;
      }
      .character-card .stat-value {
        font-weight: bold;
      }
      .character-card .derived-stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(0, 210, 211, 0.3);
      }
      .character-card .stat-container {
        margin-bottom: 0;
      }
      .character-card .stat-label {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #00ffff;
        margin-bottom: 2px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        cursor: pointer;
        transition: color 0.3s ease;
      }
      .character-card .stat-label:hover {
        color: #fff7d6;
      }
      .character-card .stat-bar {
        height: 6px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 3px;
        overflow: hidden;
        border: 1px solid rgba(0, 210, 211, 0.3);
        box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.5);
      }
      .character-card .stat-fill {
        height: 100%;
        background: linear-gradient(to right, #00ffff, #fff7d6);
        transition: width 0.3s ease;
      }
      .character-card .description {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(0, 210, 211, 0.3);
        font-size: 15px;
        color: #00ffff;
        text-align: center;
        line-height: 1.4;
        font-style: italic;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        min-height: 80px;
        max-height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 5px;
      }
      .button {
        order: 1;
        padding: 15px 40px;
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid #00ffff;
        color: #00ffff;
        font-family: "Courier New", Courier, monospace;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-shadow:
          0 0 10px #000,
          0 0 20px #000,
          0 0 30px #00ffff;
        box-shadow: 0 0 20px rgba(0, 210, 211, 0.5);
        border-radius: 25px;
        position: relative;
        overflow: hidden;
        min-width: 200px;
        text-align: center;
      }
      .button:hover {
        background: linear-gradient(135deg, #00ff00 0%, #00ffff 100%);
      }
      .button::before {
        content: "";
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: linear-gradient(45deg, transparent, rgba(0, 210, 211, 0.2), transparent);
        transform: rotate(45deg);
        animation: buttonGlow 2s linear infinite;
      }
      @keyframes buttonGlow {
        0% {
          transform: rotate(45deg) translateX(-100%);
        }
        100% {
          transform: rotate(45deg) translateX(100%);
        }
      }
      .stat-icon {
        width: 20px;
        height: 20px;
        margin-right: 3px;
        vertical-align: middle;
      }
      .stat-group {
        display: flex;
        align-items: center;
        margin-right: 15px;
        font-family: "Courier New", Courier, monospace;
        font-size: 12px;
      }
      .stat-value {
        color: #00ffff;
        margin-left: 5px;
      }
      @keyframes glow {
        from {
          text-shadow:
            0 0 10px #000,
            0 0 20px #000,
            0 0 30px #00ffff;
        }
        to {
          text-shadow:
            0 0 20px #000,
            0 0 30px #000,
            0 0 40px #00ffff;
        }
      }
      .menu-buttons {
        margin-left: auto;
        display: flex;
        gap: 5px;
      }
      .menu-button {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid #00ffff;
        color: #00ffff;
        padding: 4px 12px;
        font-size: 12px;
        cursor: pointer;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
        font-family: "Luminari", "Georgia", serif;
      }
      .menu-button:hover {
        background: linear-gradient(135deg, #00ff00 0%, #00ffff 100%);
      }
      #characterScreen {
        position: fixed;
        top: calc(40px + 12px); /* topNav height + 12px gap */
        left: 50%;
        transform: translateX(-50%);
        width: 320px;
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #00ffff;
        border-radius: 8px;
        padding: 10px;
        color: #00ffff;
        z-index: 1000;
        display: none;
        font-family: "Luminari", "Georgia", serif;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }
      .tab-navigation {
        display: flex;
        justify-content: space-between;
        width: 100%;
        margin-bottom: 0;
        padding-bottom: 0;
      }
      .tab-button {
        background: none;
        border: none;
        color: #00ffff;
        padding: 5px 10px;
        cursor: pointer;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
        border-bottom: 2px solid #00ffff;
      }

      .tab-button:hover {
        color: #00ff00;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }

      .tab-button.active {
        color: #00ff00;
        border-bottom: 2px solid #00ff00;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }
      .tab-content {
        display: none;
        padding: 20px;
      }
      .tab-content.active {
        display: block;
      }
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin: 0 -5px 15px -7px;
        padding: 0 5px;
      }
      .stat-box {
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        border-radius: 4px;
        padding: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .stat-label {
        color: #00ffff;
        font-size: 12px;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .stat-value {
        color: #00ff00;
        font-size: 12px;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }
      .items-list,
      .skills-list,
      .spells-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .item,
      .skill-item,
      .spell-item {
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        border-radius: 4px;
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .item-name,
      .skill-name,
      .spell-name {
        color: #00ffff;
        font-size: 12px;
        font-weight: bold;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .item-quantity,
      .spell-cost {
        color: #fff;
        font-size: 12px;
      }
      .skill-description,
      .spell-description {
        color: #fff;
        font-size: 12px;
        font-style: italic;
      }
      .no-items,
      .no-skills,
      .no-spells {
        color: #00ffff;
        text-align: center;
        font-style: italic;
        margin: 10px 0;
      }
      .close-button {
        position: absolute;
        top: 5px;
        right: 5px;
        background: none;
        border: none;
        color: #00ffff;
        font-size: 12px;
        cursor: pointer;
        padding: 3px;
        transition: color 0.3s ease;
      }
      .close-button:hover {
        color: #fff;
      }
      #inventoryScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 400px;
        max-height: 80vh;
        background: rgba(0, 0, 0, 0.95);
        border: 8px solid transparent;
        border-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABXUExURUxpcemgQOmgQOmgQOmgQOmgQB/0/ZQAAAAcdFJOUwAQnr4IYL9QMID+8Q/Q7jCAX5+vL9+P3q5w7zC9VsZjAAAB1ElEQVRYw+2Y25KDIAyGE8ETIFYFq7bn93/LxbbdnQAJ6F56kQvGmfwk/AkRQvzqV/+qWCz6YjIX4wI8XYhmqIQmwK2bsMEEeDgTiQngZk5sEgdYuBObxMEFhwFwReyagX6EprkYN+9+ZHGxqN8CVW2+FvWBbnx69GG1yXqG5wAD+0UAGu+lGQDTFj8Ahh0+Aay75+5xgKr7C4DtGQDTFt8CVt1zcwwwbfEWUHVPxOoAYN3iHWDdPRErD1h3+Ayo+icS4QGb7okoPGDT4gDYdk8kPGDb4gDYdk+kB+y6J6L0gF2LA2DXPZHwgH2LA2DfPZEeELonEuEBYYsDIO6eSA8I3ROJ8IC4xQEQd0+kB6TuiUR4QNriAIi7J9IDUvdEIjwgbfEREHdPpAek7olEeEDa4gCI3BMhqcUBELknQmiLAyByT4TQFgdA5J4I6QF590RID8i7J0J6QN49EdID8u6JkB6Qd0+E9IC8eyKkB+TdEyGsxQEQuSdCWIsDIHJPhLAWB0DknghhLQ6AyD0RwlocAJF7IoS1OAAi90QIa3EARO6JENbiAIjcEyGsxQEQuSdCWIsDIHJPhLAWB0DknghhLQ6AyD0R8h/AH/2qX/0BKnKqbAP+QSIAAAAASUVORK5CYII=")
          8 stretch;
        padding: 20px;
        color: #00ffff;
        z-index: 1000;
        display: none;
        font-family: "Luminari", "Georgia", serif;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }
      #inventoryScreen h2 {
        text-align: center;
        margin-bottom: 15px;
        font-size: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }
      .inventory-item {
        display: flex;
        align-items: center;
        padding: 10px;
        margin-bottom: 10px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(0, 210, 211, 0.3);
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .inventory-item:hover {
        background: rgba(0, 0, 0, 0.7);
        border-color: rgba(0, 210, 211, 0.6);
        transform: translateX(5px);
      }
      .item-icon {
        width: 32px;
        height: 32px;
        margin-right: 10px;
        border: 2px solid rgba(0, 210, 211, 0.6);
        border-radius: 4px;
      }
      .item-details {
        flex-grow: 1;
      }
      .item-name {
        font-size: 12px;
        margin-bottom: 4px;
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .item-description {
        font-size: 12px;
        color: #daa520;
        margin-bottom: 4px;
      }
      .item-quantity {
        font-size: 12px;
        color: #00ffff;
      }
      .nav-arrow {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: #00ffff;
        font-size: 24px;
        cursor: pointer;
        padding: 10px;
        z-index: 3;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
      }
      .nav-arrow:hover {
        color: #fff7d6;
        text-shadow: 0 0 15px #00ffff;
        transform: translateY(-50%) scale(1.1);
      }
      .nav-arrow.prev {
        left: -40px;
      }
      .nav-arrow.next {
        right: -40px;
      }
      .choose-button {
        margin-top: 20px;
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid rgba(0, 210, 211, 0.6);
        color: #fff;
        padding: 8px 20px;
        font-size: 12px;
        cursor: pointer;
        border-radius: 4px;
      }
      .choose-button:hover {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 0 20px rgba(0, 210, 211, 0.4);
      }
      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: #00ffff;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 100;
        pointer-events: none;
        border: 1px solid #00ffff;
        display: none;
      }
      .stat-box {
        border: 1px solid #00ffff;
        padding: 8px;
        display: flex;
        justify-content: space-between;
        background: rgba(0, 0, 0, 0.5);
        cursor: help;
        position: relative;
      }
      .stats-table {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin: 15px 0;
      }
      .resources-box {
        display: flex;
        justify-content: space-between;
        margin: 15px 0;
        color: #00ffff;
      }
      .description-box {
        border: 1px solid #00ffff;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        color: #00ffff;
        font-size: 12px;
        text-align: center;
        font-style: italic;
        margin-top: 15px;
      }
      #messageBox {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: #00ffff;
        padding: 10px 20px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 1000;
        border: 1px solid #00ffff;
        display: none;
        text-align: center;
        max-width: 80%;
      }
      .progress-stats {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .progress-stat {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .progress-label {
        display: flex;
        justify-content: space-between;
        font-size: 0.9em;
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .progress-bar {
        height: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
        overflow: hidden;
      }
      .hp-fill {
        height: 100%;
        background: linear-gradient(to right, #00ff00, #00ffff);
        transition: width 0.3s ease;
      }
      .mp-fill {
        height: 100%;
        background: linear-gradient(to right, #00ffff, #00ffff);
        transition: width 0.3s ease;
      }
      .xp-fill {
        height: 100%;
        background: linear-gradient(to right, #00ffff, #00ff00);
        transition: width 0.3s ease;
      }
      .equipment-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 4px;
        margin-top: 4px;
        font-size: 11px;
        height: calc(100% - 100px);
        padding: 0 5px;
        margin-bottom: 85px;
      }
      .equipment-item {
        display: flex;
        align-items: center;
        gap: 1px;
        padding: 1px 3px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid #333;
        cursor: pointer;
        min-height: 16px;
        position: relative;
      }
      .equipment-item:hover {
        border-color: #00ffff;
      }
      .slot-label {
        min-width: 70px;
        font-weight: bold;
        color: #00ff00;
        font-size: 12px;
        text-transform: capitalize;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }
      .item {
        display: flex;
        align-items: center;
        flex: 1;
      }
      .item-name {
        font-size: 11px;
        color: #00ffff;
        line-height: 1;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .empty-slot {
        color: #666;
        font-style: italic;
        font-size: 11px;
        line-height: 1;
        flex: 1;
        text-align: right;
        padding-right: 5px;
      }
      .equipment-info-box {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.9);

        padding: 8px;
        min-height: 70px;
        font-size: 11px;
        color: #fff;
      }
      .equipment-info-box .title {
        color: #00ffff;
        margin-bottom: 4px;
        font-size: 12px;
        font-weight: bold;
      }
      .equipment-info-box .requirements {
        color: #999;
        font-style: italic;
        margin-top: 2px;
        font-size: 10px;
      }
      .equipment-info-box .stats {
        color: #fff;
        margin-top: 4px;
        font-size: 10px;
      }
      .equipment-info-box .description {
        color: #999;
        font-style: italic;
        font-size: 10px;
      }
      .equipment-tooltip {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #00ffff;
        padding: 10px;
        color: #00ff00;
        font-size: 11px;
        min-height: 70px;
      }
      .equipment-tooltip .title {
        color: #00ffff;
        font-size: 12px;
        margin-bottom: 5px;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .equipment-tooltip .requirements {
        color: #00ff00;
        font-size: 11px;
        margin-bottom: 5px;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }
      .equipment-tooltip .stats {
        color: #fff;
        font-size: 11px;
      }
      .equipment-tooltip .description {
        color: #00ff00;
        font-style: italic;
        font-size: 11px;
        margin-top: 5px;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }
      .menu-buttons {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
      }
      .menu-button {
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #00ffff;
        color: #00ffff;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .menu-button:hover {
        background: rgba(0, 210, 211, 0.2);
      }
      .character-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
      }
      .character-header h2 {
        margin: 0;
        color: #00ffff;
      }
      .character-portrait {
        width: 64px;
        height: 96px;
        overflow: hidden;
        flex-shrink: 0;
      }
      .character-portrait img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .top-nav-buttons {
        display: flex;
        gap: 10px;
        margin-left: auto;
      }
      .top-nav-button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #00ffff;
        color: #00ffff;
        padding: 8px 16px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: "Luminari", "Georgia", serif;
      }
      .top-nav-button:hover {
        background: rgba(0, 210, 211, 0.2);
      }
      .character-select-buttons {
        display: flex;
        gap: 10px;
        margin: 10px 0;
      }
      .character-select-button {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid rgba(0, 210, 211, 0.6);
        color: #fff;
        padding: 4px 12px;
        font-size: 12px;
        cursor: pointer;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
        font-family: "Luminari", "Georgia", serif;
      }
      .character-select-button:hover {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(0, 210, 211, 0.4);
      }
      .stat-controls {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .stat-button {
        background: none;
        border: none;
        color: #00ffff;
        font-size: 12px;
        cursor: pointer;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }

      .stat-button.plus {
        color: #00ff00;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }

      .stat-button.minus {
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }

      .stat-value {
        min-width: 20px;
        text-align: center;
      }
      .item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
        margin-bottom: 5px;
      }
      .item-name {
        font-weight: bold;
        color: #00ffff;
      }
      .item-description {
        color: #aaa;
        font-size: 0.9em;
      }
      .item-stats {
        color: #4caf50;
        font-size: 0.9em;
      }
      .item-requirements {
        color: #ff9800;
        font-size: 0.9em;
      }
      .item-quantity {
        color: #2196f3;
        font-weight: bold;
      }
      .use-button,
      .equip-button,
      .unequip-button {
        padding: 5px 10px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-weight: bold;
        margin-left: auto;
      }
      .use-button {
        background: #4caf50;
        color: white;
      }
      .equip-button {
        background: #2196f3;
        color: white;
      }
      .unequip-button {
        background: #f44336;
        color: white;
      }
      .use-button:hover,
      .equip-button:hover,
      .unequip-button:hover {
        opacity: 0.8;
      }
      .equipment-screen-content {
        position: relative;
        height: 100%;
        padding-bottom: 90px; /* Make room for tooltip */
      }
      .equipment-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 4px;
        margin-top: 4px;
        font-size: 11px;
        padding: 0 5px;
      }
      .equipment-tooltip {
        position: absolute;
        bottom: 10px;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #00ffff;
        padding: 10px;
        color: #00ff00;
        font-size: 11px;
        min-height: 90px;
        margin: 0 5px 5px 5px;
      }
      .equipment-message-box {
        position: absolute;
        bottom: 0; /* Changed from 5px to 0 to be at the very bottom */
        left: 5px;
        right: 5px;
        background: rgba(0, 0, 0, 0.9);
        border: 1px solid #00ffff;
        border-radius: 3px;
        padding: 8px;
        min-height: 70px;
        font-size: 11px;
        color: #fff;
      }
      .character-screen {
        position: fixed;
        top: calc(40px + 2px); /* topNav height + 2px gap */
        left: 50%;
        transform: translateX(-50%);
        width: 300px;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #00ffff;
        border-radius: 5px;
        padding: 10px;
        color: #fff;
        display: none;
        z-index: 100;
      }
      .equipment-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 4px;
        margin-top: 4px;
        font-size: 11px;
        height: calc(100% - 100px);
        padding: 0 5px;
        margin-bottom: 85px;
      }
      .equipment-message-box {
        position: absolute;
        bottom: 0; /* Changed from 5px to 0 to be at the very bottom */
        left: 5px;
        right: 5px;
        background: rgba(0, 0, 0, 0.9);
        border: 1px solid #00ffff;
        border-radius: 3px;
        padding: 8px;
        min-height: 70px;
        font-size: 11px;
        color: #fff;
      }
      .items-list {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 10px;
        padding: 10px;
      }
      .item {
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        border-radius: 4px;
        padding: 8px;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
      .item-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .item-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .item-name {
        color: #00ffff;
        font-size: 12px;
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 150px;
      }
      .item-quantity {
        color: #fff;
        font-size: 12px;
      }
      .use-button,
      .equip-button,
      .unequip-button {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #00ffff;
        border-radius: 4px;
        color: #00ffff;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
        white-space: nowrap;
      }
      .use-button:hover,
      .equip-button:hover,
      .unequip-button:hover {
        background: rgba(0, 210, 211, 0.2);
      }
      #introScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        font-family: "Courier New", monospace;
      }

      .command-prompt {
        color: #00ffff;
        font-size: 12px;
        line-height: 1.5;
        max-width: 800px;
        padding: 20px;
      }

      .text-container {
        white-space: pre-wrap;
        overflow: hidden;
      }

      .cursor {
        display: inline-block;
        animation: blink 1s step-end infinite;
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
      }
      @keyframes float {
        0% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
        100% {
          transform: translateY(0px);
        }
      }

      @keyframes glow {
        from {
          text-shadow:
            0 0 7px #00ffff,
            0 0 10px #00ffff,
            0 0 21px #00ffff,
            0 0 42px #00ffff,
            0 0 82px #00ffff,
            0 0 92px #00ffff,
            0 0 102px #00ffff,
            0 0 151px #00ffff;
        }
        to {
          text-shadow:
            0 0 10px #00ffff,
            0 0 20px #00ffff,
            0 0 30px #00ffff,
            0 0 40px #00ffff,
            0 0 70px #00ffff,
            0 0 80px #00ffff,
            0 0 100px #00ffff,
            0 0 150px #00ffff;
        }
      }

      @keyframes buttonPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(0, 255, 255, 0.4);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(0, 255, 255, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 255, 255, 0);
        }
      }
      .character-select {
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #00ffff;
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      }

      .character-select h2 {
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
        border-bottom: 2px solid #00ffff;
      }

      .character-select .description {
        color: #00ff00;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }

      .character-select .stats {
        color: #00ffff;
      }

      body {
        min-height: 100vh;
        background: #000;
        font-family: "Courier New", Courier, monospace;
        overflow: hidden;
      }

      #game-container {
        position: relative;
        width: 800px;
        height: 600px;
        background: #111;
        border: 4px solid #333;
        display: flex;
        flex-direction: column;
      }
      #topNav {
        position: relative;
        height: 40px;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0 10px;
        color: #fff;
        z-index: 1;
        border-bottom: 2px solid #8b4513;
      }
      #gameCanvas {
        flex: 1;
        width: 100%;
        height: calc(100% - 40px);
        image-rendering: pixelated;
      }
      #gameLog {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100px;
        background: rgba(0, 0, 0, 0.9);
        color: #fff;
        padding: 10px;
        overflow-y: auto;
        font-size: 12px;
        display: none;
        border-top: 2px solid #8b4513;
        z-index: 2;
      }
      #messageIndicator {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: #00ffff;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        display: none;
        border: 1px solid #00ffff;
        animation: pulse 2s infinite;
        z-index: 1;
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
      #startScreen {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GlitterStart-eWtnNjTcWxXyheoQtPcBK9MDLQWYBK.png?koxn")
          no-repeat center center;
        background-size: cover;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        color: #fff;
        z-index: 2;
      }
      #startScreen .start-content {
        margin-top: 75%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      #startScreen .button {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid #00ffff;
        color: #00ffff;
        font-family: "Courier New", Courier, monospace;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-shadow:
          0 0 10px #000,
          0 0 20px #000,
          0 0 30px #00ffff;
        box-shadow: 0 0 20px rgba(0, 210, 211, 0.5);
        border-radius: 25px;
        position: relative;
        overflow: hidden;
        min-width: 200px;
        text-align: center;
        z-index: 3;
      }
      #startScreen .button:hover {
        background: linear-gradient(135deg, #00ff00 0%, #00ffff 100%);
        text-shadow:
          0 0 20px #000,
          0 0 30px #000,
          0 0 40px #00ffff;
      }
      #startScreen h1 {
        font-size: 32px;
        font-family: "Monoton", cursive;
        text-align: center;
        color: #00ffff;
        text-shadow:
          0 0 7px #00ffff,
          0 0 10px #00ffff,
          0 0 21px #00ffff,
          0 0 42px #00ffff,
          0 0 82px #00ffff,
          0 0 92px #00ffff,
          0 0 102px #00ffff,
          0 0 151px #00ffff;
        animation: flicker 1.5s infinite alternate;
        margin: 0;
        z-index: 3;
      }
      @keyframes flicker {
        0%,
        18%,
        22%,
        25%,
        53%,
        57%,
        100% {
          text-shadow:
            0 0 7px #00ffff,
            0 0 10px #00ffff,
            0 0 21px #00ffff,
            0 0 42px #00ffff,
            0 0 82px #00ffff,
            0 0 92px #00ffff,
            0 0 102px #00ffff,
            0 0 151px #00ffff;
        }
        20%,
        24%,
        55% {
          text-shadow: none;
        }
      }
      @font-face {
        font-family: "Monoton";
        src: url("https://fonts.googleapis.com/css2?family=Monoton&display=swap");
      }
      #characterSelect {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: url("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/bg_ch1-kfSYqZkhRTZH8lBO90oBjby2fknBXF.png?vmqV")
          no-repeat center center;
        background-size: cover;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: #00ffff;
        z-index: 2;
        padding: 10px;
        box-sizing: border-box;
      }
      #characterSelect h2 {
        font-size: 24px;
        margin: 0 0 10px 0;
        color: #00ffff;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        letter-spacing: 1px;
        font-family: "MedievalSharp", "Georgia", serif;
        text-align: center;
      }
      #characterSelect h3 {
        font-size: 12px;
        margin: 0 0 20px 0;
        color: #00ffff;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-family: "Luminari", "Georgia", serif;
        text-align: center;
        font-style: italic;
      }
      #characterList {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 345px;
        margin: -10px auto 0;
      }
      .character-card {
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #00ffff;
        border-radius: 8px;
        padding: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        width: 100%;
        box-sizing: border-box;
      }
      .character-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 0 20px rgba(0, 210, 211, 0.5);
      }
      .character-card.selected {
        background: rgba(0, 210, 211, 0.1);
        border-color: #fff7d6;
      }
      .character-card h3 {
        color: #00ffff;
        margin: 0 0 10px 0;
        font-size: 18px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }
      .character-card p {
        color: #fff;
        margin: 5px 0;
        font-size: 12px;
      }
      .character-card .stats {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid rgba(0, 210, 211, 0.3);
      }
      .character-card .stat {
        display: flex;
        justify-content: space-between;
        margin: 5px 0;
        color: #fff;
        font-size: 12px;
      }
      .character-card .stat-label {
        color: #00ffff;
      }
      .character-card .stat-value {
        font-weight: bold;
      }
      .character-card .derived-stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(0, 210, 211, 0.3);
      }
      .character-card .stat-container {
        margin-bottom: 0;
      }
      .character-card .stat-label {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #00ffff;
        margin-bottom: 2px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        cursor: pointer;
        transition: color 0.3s ease;
      }
      .character-card .stat-label:hover {
        color: #fff7d6;
      }
      .character-card .stat-bar {
        height: 6px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 3px;
        overflow: hidden;
        border: 1px solid rgba(0, 210, 211, 0.3);
        box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.5);
      }
      .character-card .stat-fill {
        height: 100%;
        background: linear-gradient(to right, #00ffff, #fff7d6);
        transition: width 0.3s ease;
      }
      .character-card .description {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(0, 210, 211, 0.3);
        font-size: 15px;
        color: #00ffff;
        text-align: center;
        line-height: 1.4;
        font-style: italic;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        min-height: 80px;
        max-height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0 5px;
      }
      .button {
        order: 1;
        padding: 15px 40px;
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid #00ffff;
        color: #00ffff;
        font-family: "Courier New", Courier, monospace;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-shadow:
          0 0 10px #000,
          0 0 20px #000,
          0 0 30px #00ffff;
        box-shadow: 0 0 20px rgba(0, 210, 211, 0.5);
        border-radius: 25px;
        position: relative;
        overflow: hidden;
        min-width: 200px;
        text-align: center;
      }
      .button:hover {
        background: linear-gradient(135deg, #00ff00 0%, #00ffff 100%);
      }
      .button::before {
        content: "";
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: linear-gradient(45deg, transparent, rgba(0, 210, 211, 0.2), transparent);
        transform: rotate(45deg);
        animation: buttonGlow 2s linear infinite;
      }
      @keyframes buttonGlow {
        0% {
          transform: rotate(45deg) translateX(-100%);
        }
        100% {
          transform: rotate(45deg) translateX(100%);
        }
      }
      .stat-icon {
        width: 20px;
        height: 20px;
        margin-right: 3px;
        vertical-align: middle;
      }
      .stat-group {
        display: flex;
        align-items: center;
        margin-right: 15px;
        font-family: "Courier New", Courier, monospace;
        font-size: 12px;
      }
      .stat-value {
        color: #00ffff;
        margin-left: 5px;
      }
      @keyframes glow {
        from {
          text-shadow:
            0 0 10px #000,
            0 0 20px #000,
            0 0 30px #00ffff;
        }
        to {
          text-shadow:
            0 0 20px #000,
            0 0 30px #000,
            0 0 40px #00ffff;
        }
      }
      .menu-buttons {
        margin-left: auto;
        display: flex;
        gap: 5px;
      }
      .menu-button {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid #00ffff;
        color: #00ffff;
        padding: 4px 12px;
        font-size: 12px;
        cursor: pointer;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
        font-family: "Luminari", "Georgia", serif;
      }
      .menu-button:hover {
        background: linear-gradient(135deg, #00ff00 0%, #00ffff 100%);
      }
      #characterScreen {
        position: fixed;
        top: calc(40px + 12px); /* topNav height + 12px gap */
        left: 50%;
        transform: translateX(-50%);
        width: 320px;
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #00ffff;
        border-radius: 8px;
        padding: 10px;
        color: #00ffff;
        z-index: 1000;
        display: none;
        font-family: "Luminari", "Georgia", serif;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }
      .tab-navigation {
        display: flex;
        justify-content: space-between;
        width: 100%;
        margin-bottom: 0;
        padding-bottom: 0;
      }
      .tab-button {
        background: none;
        border: none;
        color: #00ffff;
        padding: 5px 10px;
        cursor: pointer;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
        border-bottom: 2px solid #00ffff;
      }

      .tab-button:hover {
        color: #00ff00;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }

      .tab-button.active {
        color: #00ff00;
        border-bottom: 2px solid #00ff00;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }
      .tab-content {
        display: none;
        padding: 20px;
      }
      .tab-content.active {
        display: block;
      }
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin: 0 -5px 15px -7px;
        padding: 0 5px;
      }
      .stat-box {
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        border-radius: 4px;
        padding: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .stat-label {
        color: #00ffff;
        font-size: 12px;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .stat-value {
        color: #00ff00;
        font-size: 12px;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }
      .items-list,
      .skills-list,
      .spells-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .item,
      .skill-item,
      .spell-item {
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        border-radius: 4px;
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .item-name,
      .skill-name,
      .spell-name {
        color: #00ffff;
        font-size: 12px;
        font-weight: bold;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .item-quantity,
      .spell-cost {
        color: #fff;
        font-size: 12px;
      }
      .skill-description,
      .spell-description {
        color: #fff;
        font-size: 12px;
        font-style: italic;
      }
      .no-items,
      .no-skills,
      .no-spells {
        color: #00ffff;
        text-align: center;
        font-style: italic;
        margin: 10px 0;
      }
      .close-button {
        position: absolute;
        top: 5px;
        right: 5px;
        background: none;
        border: none;
        color: #00ffff;
        font-size: 12px;
        cursor: pointer;
        padding: 3px;
        transition: color 0.3s ease;
      }
      .close-button:hover {
        color: #fff;
      }
      #inventoryScreen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 400px;
        max-height: 80vh;
        background: rgba(0, 0, 0, 0.95);
        border: 8px solid transparent;
        border-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABXUExURUxpcemgQOmgQOmgQOmgQOmgQB/0/ZQAAAAcdFJOUwAQnr4IYL9QMID+8Q/Q7jCAX5+vL9+P3q5w7zC9VsZjAAAB1ElEQVRYw+2Y25KDIAyGE8ETIFYFq7bn93/LxbbdnQAJ6F56kQvGmfwk/AkRQvzqV/+qWCz6YjIX4wI8XYhmqIQmwK2bsMEEeDgTiQngZk5sEgdYuBObxMEFhwFwReyagX6EprkYN+9+ZHGxqN8CVW2+FvWBbnx69GG1yXqG5wAD+0UAGu+lGQDTFj8Ahh0+Aay75+5xgKr7C4DtGQDTFt8CVt1zcwwwbfEWUHVPxOoAYN3iHWDdPRErD1h3+Ayo+icS4QGb7okoPGDT4gDYdk8kPGDb4gDYdk+kB+y6J6L0gF2LA2DXPZHwgH2LA2DfPZEeELonEuEBYYsDIO6eSA8I3ROJ8IC4xQEQd0+kB6TuiUR4QNriAIi7J9IDUvdEIjwgbfEREHdPpAek7olEeEDa4gCI3BMhqcUBELknQmiLAyByT4TQFgdA5J4I6QF590RID8i7J0J6QN49EdID8u6JkB6Qd0+E9IC8eyKkB+TdEyGsxQEQuSdCWIsDIHJPhLAWB0DknghhLQ6AyD0RwlocAJF7IoS1OAAi90QIa3EARO6JENbiAIjcEyGsxQEQuSdCWIsDIHJPhLAWB0DknghhLQ6AyD0R8h/AH/2qX/0BKnKqbAP+QSIAAAAASUVORK5CYII=")
          8 stretch;
        padding: 20px;
        color: #00ffff;
        z-index: 1000;
        display: none;
        font-family: "Luminari", "Georgia", serif;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }
      #inventoryScreen h2 {
        text-align: center;
        margin-bottom: 15px;
        font-size: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
      }
      .inventory-item {
        display: flex;
        align-items: center;
        padding: 10px;
        margin-bottom: 10px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(0, 210, 211, 0.3);
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .inventory-item:hover {
        background: rgba(0, 0, 0, 0.7);
        border-color: rgba(0, 210, 211, 0.6);
        transform: translateX(5px);
      }
      .item-icon {
        width: 32px;
        height: 32px;
        margin-right: 10px;
        border: 2px solid rgba(0, 210, 211, 0.6);
        border-radius: 4px;
      }
      .item-details {
        flex-grow: 1;
      }
      .item-name {
        font-size: 12px;
        margin-bottom: 4px;
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .item-description {
        font-size: 12px;
        color: #daa520;
        margin-bottom: 4px;
      }
      .item-quantity {
        font-size: 12px;
        color: #00ffff;
      }
      .nav-arrow {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: #00ffff;
        font-size: 24px;
        cursor: pointer;
        padding: 10px;
        z-index: 3;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
      }
      .nav-arrow:hover {
        color: #fff7d6;
        text-shadow: 0 0 15px #00ffff;
        transform: translateY(-50%) scale(1.1);
      }
      .nav-arrow.prev {
        left: -40px;
      }
      .nav-arrow.next {
        right: -40px;
      }
      .choose-button {
        margin-top: 20px;
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid rgba(0, 210, 211, 0.6);
        color: #fff;
        padding: 8px 20px;
        font-size: 12px;
        cursor: pointer;
        border-radius: 4px;
      }
      .choose-button:hover {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 0 20px rgba(0, 210, 211, 0.4);
      }
      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: #00ffff;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 100;
        pointer-events: none;
        border: 1px solid #00ffff;
        display: none;
      }
      .stat-box {
        border: 1px solid #00ffff;
        padding: 8px;
        display: flex;
        justify-content: space-between;
        background: rgba(0, 0, 0, 0.5);
        cursor: help;
        position: relative;
      }
      .stats-table {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin: 15px 0;
      }
      .resources-box {
        display: flex;
        justify-content: space-between;
        margin: 15px 0;
        color: #00ffff;
      }
      .description-box {
        border: 1px solid #00ffff;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        color: #00ffff;
        font-size: 12px;
        text-align: center;
        font-style: italic;
        margin-top: 15px;
      }
      #messageBox {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: #00ffff;
        padding: 10px 20px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 1000;
        border: 1px solid #00ffff;
        display: none;
        text-align: center;
        max-width: 80%;
      }
      .progress-stats {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .progress-stat {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }
      .progress-label {
        display: flex;
        justify-content: space-between;
        font-size: 0.9em;
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .progress-bar {
        height: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 5px;
        overflow: hidden;
      }
      .hp-fill {
        height: 100%;
        background: linear-gradient(to right, #00ff00, #00ffff);
        transition: width 0.3s ease;
      }
      .mp-fill {
        height: 100%;
        background: linear-gradient(to right, #00ffff, #00ffff);
        transition: width 0.3s ease;
      }
      .xp-fill {
        height: 100%;
        background: linear-gradient(to right, #00ffff, #00ff00);
        transition: width 0.3s ease;
      }
      .equipment-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 4px;
        margin-top: 4px;
        font-size: 11px;
        height: calc(100% - 100px);
        padding: 0 5px;
        margin-bottom: 85px;
      }
      .equipment-item {
        display: flex;
        align-items: center;
        gap: 1px;
        padding: 1px 3px;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid #333;
        cursor: pointer;
        min-height: 16px;
        position: relative;
      }
      .equipment-item:hover {
        border-color: #00ffff;
      }
      .slot-label {
        min-width: 70px;
        font-weight: bold;
        color: #00ff00;
        font-size: 12px;
        text-transform: capitalize;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }
      .item {
        display: flex;
        align-items: center;
        flex: 1;
      }
      .item-name {
        font-size: 11px;
        color: #00ffff;
        line-height: 1;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .empty-slot {
        color: #666;
        font-style: italic;
        font-size: 11px;
        line-height: 1;
        flex: 1;
        text-align: right;
        padding-right: 5px;
      }
      .equipment-info-box {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.9);

        padding: 8px;
        min-height: 70px;
        font-size: 11px;
        color: #fff;
      }
      .equipment-info-box .title {
        color: #00ffff;
        margin-bottom: 4px;
        font-size: 12px;
        font-weight: bold;
      }
      .equipment-info-box .requirements {
        color: #999;
        font-style: italic;
        margin-top: 2px;
        font-size: 10px;
      }
      .equipment-info-box .stats {
        color: #fff;
        margin-top: 4px;
        font-size: 10px;
      }
      .equipment-info-box .description {
        color: #999;
        font-style: italic;
        font-size: 10px;
      }
      #itemTooltip, #skillTooltip, #spellTooltip, #equipmentTooltip, .equipment-tooltip {
        position: absolute;
        bottom: 0px;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #00ffff;
        padding: 10px;
        color: #00ff00;
        font-size: 11px;
        min-height: 90px;
        margin: 0 5px 5px 5px;
      }
      .equipment-tooltip .title {
        color: #00ffff;
        font-size: 12px;
        margin-bottom: 5px;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }
      .equipment-tooltip .requirements {
        color: #00ff00;
        font-size: 11px;
        margin-bottom: 5px;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }
      .equipment-tooltip .stats {
        color: #fff;
        font-size: 11px;
      }
      .equipment-tooltip .description {
        color: #00ff00;
        font-style: italic;
        font-size: 11px;
        margin-top: 5px;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }
      .menu-buttons {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
      }
      .menu-button {
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #00ffff;
        color: #00ffff;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .menu-button:hover {
        background: rgba(0, 210, 211, 0.2);
      }
      .character-header {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
      }
      .character-header h2 {
        margin: 0;
        color: #00ffff;
      }
      .character-portrait {
        width: 64px;
        height: 96px;
        overflow: hidden;
        flex-shrink: 0;
      }
      .character-portrait img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .top-nav-buttons {
        display: flex;
        gap: 10px;
        margin-left: auto;
      }
      .top-nav-button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid #00ffff;
        color: #00ffff;
        padding: 8px 16px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: "Luminari", "Georgia", serif;
      }
      .top-nav-button:hover {
        background: rgba(0, 210, 211, 0.2);
      }
      .character-select-buttons {
        display: flex;
        gap: 10px;
        margin: 10px 0;
      }
      .character-select-button {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid rgba(0, 210, 211, 0.6);
        color: #fff;
        padding: 4px 12px;
        font-size: 12px;
        cursor: pointer;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        transition: all 0.3s ease;
        font-family: "Luminari", "Georgia", serif;
      }
      .character-select-button:hover {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(0, 210, 211, 0.4);
      }
      .stat-controls {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .stat-button {
        background: none;
        border: none;
        color: #00ffff;
        font-size: 12px;
        cursor: pointer;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }

      .stat-button.plus {
        color: #00ff00;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }

      .stat-button.minus {
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }

      .stat-value {
        min-width: 20px;
        text-align: center;
      }
      .item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
        margin-bottom: 5px;
      }
      .item-name {
        font-weight: bold;
        color: #00ffff;
      }
      .item-description {
        color: #aaa;
        font-size: 0.9em;
      }
      .item-stats {
        color: #4caf50;
        font-size: 0.9em;
      }
      .item-requirements {
        color: #ff9800;
        font-size: 0.9em;
      }
      .item-quantity {
        color: #2196f3;
        font-weight: bold;
      }
      .use-button,
      .equip-button,
      .unequip-button {
        padding: 5px 10px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-weight: bold;
        margin-left: auto;
      }
      .use-button {
        background: #4caf50;
        color: white;
      }
      .equip-button {
        background: #2196f3;
        color: white;
      }
      .unequip-button {
        background: #f44336;
        color: white;
      }
      .use-button:hover,
      .equip-button:hover,
      .unequip-button:hover {
        opacity: 0.8;
      }
      .equipment-screen-content {
        position: relative;
        height: 100%;
        padding-bottom: 90px; /* Make room for tooltip */
      }
      .equipment-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 4px;
        margin-top: 4px;
        font-size: 11px;
        padding: 0 5px;
      }
      .equipment-tooltip {
        position: absolute;
        bottom: 10px;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #00ffff;
        padding: 10px;
        color: #00ff00;
        font-size: 11px;
        min-height: 90px;
        margin: 0 5px 5px 5px;
      }
      .equipment-message-box {
        position: absolute;
        bottom: 0; /* Changed from 5px to 0 to be at the very bottom */
        left: 5px;
        right: 5px;
        background: rgba(0, 0, 0, 0.9);
        border: 1px solid #00ffff;
        border-radius: 3px;
        padding: 8px;
        min-height: 70px;
        font-size: 11px;
        color: #fff;
      }
      .equipment-message-box .title {
        color: #00ffff;
        font-size: 12px;
        margin-bottom: 5px;
      }
      .equipment-message-box .description {
        color: #ccc;
        font-size: 12px;
        margin-bottom: 5px;
      }
      .equipment-message-box .stats {
        color: #fff;
        font-size: 12px;
      }
      .character-screen {
        position: fixed;
        top: calc(40px + 2px); /* topNav height + 2px gap */
        left: 50%;
        transform: translateX(-50%);
        width: 300px;
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid #00ffff;
        border-radius: 5px;
        padding: 10px;
        color: #fff;
        display: none;
        z-index: 100;
      }
      .equipment-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 4px;
        margin-top: 4px;
        font-size: 11px;
        height: calc(100% - 100px);
        padding: 0 5px;
        margin-bottom: 85px;
      }
      .equipment-message-box {
        position: absolute;
        bottom: 0; /* Changed from 5px to 0 to be at the very bottom */
        left: 5px;
        right: 5px;
        background: rgba(0, 0, 0, 0.9);
        border: 1px solid #00ffff;
        border-radius: 3px;
        padding: 8px;
        min-height: 70px;
        font-size: 11px;
        color: #fff;
      }
      .items-list {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 10px;
        padding: 10px;
      }
      .item {
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        border-radius: 4px;
        padding: 8px;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
      .item-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .item-actions {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .item-name {
        color: #00ffff;
        font-size: 12px;
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 150px;
      }
      .item-quantity {
        color: #fff;
        font-size: 12px;
      }
      .use-button,
      .equip-button,
      .unequip-button {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #00ffff;
        border-radius: 4px;
        color: #00ffff;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
        white-space: nowrap;
      }
      .use-button:hover,
      .equip-button:hover,
      .unequip-button:hover {
        background: rgba(0, 210, 211, 0.2);
      }
      #introScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        font-family: "Courier New", monospace;
      }

      .command-prompt {
        color: #00ffff;
        font-size: 12px;
        line-height: 1.5;
        max-width: 800px;
        padding: 20px;
      }

      .text-container {
        white-space: pre-wrap;
        overflow: hidden;
      }

      .cursor {
        display: inline-block;
        animation: blink 1s step-end infinite;
      }

      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
      }

      .character-select {
        border: 2px solid #00ffff;
        background: rgba(0, 0, 0, 0.8);
      }

      .character-select h2 {
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }

      .character-select .description {
        color: #00ff00;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ff00;
      }

      .character-select .stats {
        color: #00ffff;
      }

      .character-select .button {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid #00ffff;
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }

      .character-select .button:hover {
        background: linear-gradient(135deg, #00ff00 0%, #00ffff 100%);
      }

      #characterScreen {
        border: 2px solid #00ffff;
        background: rgba(0, 0, 0, 0.9);
      }

      .character-header {
        border-bottom: 2px solid #00ffff;
      }

      .level-class {
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }

      #battleScreen {
        border: 2px solid #00ffff;
        background: rgba(0, 0, 0, 0.9);
      }

      .battle-message {
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }

      .battle-actions button {
        background: linear-gradient(135deg, #00ffff 0%, #00ffff 100%);
        border: 2px solid #00ffff;
        color: #00ffff;
        text-shadow:
          0 0 5px #000,
          0 0 10px #00ffff;
      }

      .battle-actions button:hover {
        background: linear-gradient(135deg, #00ff00 0%, #00ffff 100%);
      }

      .enemy-health {
        border: 2px solid #00ffff;
        background: rgba(0, 0, 0, 0.8);
      }

      .enemy-health .fill {
        background: linear-gradient(to right, #00ffff, #00ff00);
      }

      .player-health {
        border: 2px solid #00ffff;
        background: rgba(0, 0, 0, 0.8);
      }

      .defeat-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }

      .defeat-content {
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #ff0000;
        padding: 30px;
        text-align: center;
        animation: fadeIn 0.5s ease-out;
      }

      .defeat-content h2 {
        color: #ff0000;
        font-size: 24px;
        margin-bottom: 20px;
        text-shadow: 0 0 10px #ff0000;
      }

      .defeat-options {
        display: flex;
        gap: 20px;
        justify-content: center;
      }

      .defeat-options button {
        background: linear-gradient(135deg, #ff0000 0%, #800000 100%);
        border: 2px solid #ff0000;
        color: #fff;
        padding: 10px 20px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-shadow: 0 0 5px #000;
      }

      .defeat-options button:hover {
        background: linear-gradient(135deg, #ff3333 0%, #ff0000 100%);
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      .player-health .fill {
        background: linear-gradient(to right, #00ff00, #00ffff);
      }

      #characterScreen {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 800px;
        height: 600px;
        background: rgba(0, 0, 0, 0.95);
        border: 2px solid #00ffff;
        color: #00ffff;
        z-index: 1000;
        display: none;
        padding: 20px;
        box-sizing: border-box;
        overflow: hidden;
      }

      .tab-navigation {
        display: flex;
        width: 100%;
        gap: 0;
        border: none;
        background: none;
        margin-bottom: 20px;
        align-items: center;
      }

      .tab-scroll {
        display: flex;
        flex: 1;
        overflow-x: hidden;
        scroll-behavior: smooth;
      }

      .tab-arrow {
        background: rgba(0, 0, 0, 0.8);
        color: #00ffff;
        border: 1px solid #00ffff;
        height: 40px;
        width: 30px;
        margin: 0 5px;
        cursor: pointer;
        font-size: 16px;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: all 0.2s ease;
      }

      .tab-arrow:hover {
        background: rgba(0, 255, 255, 0.2);
      }

      .tab-button {
        flex: 1 1 0;
        min-width: 0;
        padding: 12px 0;
        background: rgba(0, 0, 0, 0.8);
        border: none;
        color: #00ffff;
        cursor: pointer;
        font-size: 15px;
        text-align: center;
        border-bottom: 2px solid transparent;
        border-radius: 0;
        outline: none;
        margin: 0;
        box-shadow: none;
        transition:
          background 0.2s,
          color 0.2s,
          border-bottom 0.2s;
      }
      .tab-button[data-tab="stats-tab"] {
        flex: 0.8 1 0;
      }
      .tab-button[data-tab="equipment-tab"] {
        flex: 1.3 1 0;
      }

      .tab-button.active,
      .tab-button:hover {
        border-bottom: 2px solid #00ffff;
        color: #fff;
        background: rgba(0, 210, 211, 0.2);
      }
    </style>

    <style>
      /* Targeted fixes for equipment and relics tabs */
      /* Fix equipment grid - force 2 column layout */
      #equipment-tab .equipment-list {
        display: grid !important;
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 10px !important;
        margin-bottom: 80px !important;
      }
      
      /* Fix relics tab */
      #relics-tab .relic-item,
      .equipment-list .relic-item,
      div[class*="relic-item"] {
        width: 92% !important;
        box-sizing: border-box !important;
        margin: 5px auto 70px auto !important; /* More space for tooltip below */
        padding: 8px !important;
        max-width: 92% !important;
        position: relative !important;
        display: flex !important;
        flex-direction: column !important;
        top: 0 !important; /* Reset top positioning */
      }
      
      /* Ensure all ability names are left-aligned regardless of template */
      .relic-abilities .ability-name,
      .ability-item .ability-name,
      .ability-info .ability-name,
      div[class*="ability-name"],
      [class*="ability"] [class*="name"],
      [data-ability-name],
      #relics-tab *[class*="name"],
      *[class*="ability"] *[class*="name"] {
        text-align: left !important;
        margin-left: 0 !important; /* Remove margin that was shifting names */
        text-align-last: left !important;
        text-justify: none !important;
        direction: ltr !important;
      }
      
      /* Force center-aligned text to be left-aligned within the relics tab */
      #relics-tab div {
        text-align: left !important;
      }
      
      /* Override any inline styles with !important */
      #relics-tab div[style*="text-align"] {
        text-align: left !important;
      }
      
      #relics-tab .equipment-list {
        padding: 0 !important;
        margin: 0 !important;
      }
      
      #relics-tab .equipment-screen-content {
        padding: 0 2px !important;
      }
      
      /* Fix relic tooltip positioning */
      #relics-tab .equipment-tooltip, 
      #relicTooltip,
      .relic-item .tooltip,
      .equipment-tooltip,
      div[class*="tooltip"],
      .relic-tooltip,
      .tooltip-relic-fusion,
      div[class*="tooltip-fusion"] {
        position: absolute !important;
        top: 100% !important; /* Position exactly at the bottom of the parent */
        bottom: auto !important; /* Reset any bottom positioning */
        left: 0 !important;
        right: 0 !important;
        width: 100% !important; /* Match relic card width */
        max-width: 100% !important;
        margin-top: 5px !important; /* Exactly 5px below the card */
        padding: 4px 8px !important;
        background: rgba(0, 0, 0, 0.9) !important;
        border: 1px solid #00ffff !important;
        z-index: 1000 !important; /* Higher z-index to ensure visibility */
        box-sizing: border-box !important;
        height: 62px !important; /* Further increased height to fit content */
        min-height: 62px !important; /* Override any min-height */
        max-height: 62px !important; /* Increased max height */
        color: #00ff00 !important;
        display: none !important; /* Hide by default */
        pointer-events: none !important; /* So it doesn't block hover on other elements */
        font-size: 11px !important; /* Smaller font to fit */
        white-space: normal !important; /* Allow text wrapping */
        overflow: visible !important; /* Show all content */
        text-overflow: clip !important; /* Don't use ellipsis */
        line-height: 14px !important;
      }
      
      /* Special handling for any elements with tooltip-relic-fusion class */
      .tooltip-relic-fusion,
      div[class*="tooltip-fusion"],
      .tooltip-special {
        display: none !important; /* Force hide these special tooltips */
      }
      
      /* Show tooltips only on hover */
      .relic-item:hover .relic-tooltip,
      .relic-item:hover .equipment-tooltip,
      .relic-item:hover .tooltip,
      .relic-item:hover div[class*="tooltip"],
      div:hover > #relicTooltip,
      div:hover > .equipment-tooltip,
      div:hover > div[class*="tooltip"] {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      /* Fix ability grid layout */
      .relic-grid {
        display: grid !important;
        grid-template-columns: repeat(2, 1fr) !important;
        grid-template-rows: repeat(3, auto) !important;
        gap: 8px !important;
        width: 95% !important;
        margin: 10px auto 40px auto !important; /* Space above and below the grid */
        max-width: 95% !important; /* Prevent overflow */
      }
      
      /* Ensure grid items stay in their cells and don't span */
      .relic-grid > div,
      .relic-grid .ability-item,
      .relic-grid [class*="ability"] {
        grid-column: span 1 !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
        overflow: hidden !important;
      }
      
      /* Fix ability display */
      .ability-item,
      .relic-grid > div,
      [class*="ability-container"],
      div[data-ability-id] {
        position: relative !important;
        height: 35px !important;
        width: 100% !important;
        margin: 0 !important;
        overflow: hidden !important;
        box-sizing: border-box !important;
        display: flex !important;
        flex-direction: row !important;
        align-items: center !important;
        max-width: 100% !important;
      }
      
      /* Style ability level boxes */
      .ability-level {
        position: relative !important;
        border-radius: 0 !important;
        background: rgba(0, 0, 0, 0.7) !important;
        border: 1px solid #00ffff !important;
        height: 100% !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
      }
      
      /* Fix level number positioning - small number in corner */
      .level-number {
        position: absolute !important;
        top: 2px !important;
        left: 4px !important;
        font-size: 10px !important;
        color: #999 !important;
        z-index: 1 !important;
      }
      
      /* Hide level number boxes completely */
      .ability-level {
        display: none !important;
        width: 0 !important;
        min-width: 0 !important;
        margin: 0 !important;
        padding: 0 !important;
        border: none !important;
      }
      
      /* Style ability name div */
      .ability-name {
        height: 35px !important;
        box-sizing: border-box !important;
        text-align: left !important;
        font-size: 12px !important;
        line-height: 35px !important;
        color: #00ffff !important;
        font-weight: bold !important;
        text-shadow: 1px 1px 1px rgba(0,0,0,0.8) !important;
        padding: 0 8px !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
        width: 100% !important; /* Full width since level boxes are removed */
        flex: 1 !important;
        background: rgba(0, 0, 0, 0.7) !important;
        border: 1px solid #00ffff !important;
        direction: ltr !important; /* Force left-to-right text direction */
        position: relative !important;
        margin: 0 !important;
        border-radius: 0 !important;
        border-left: 1px solid #00ffff !important; /* Explicitly set left border */
      }
      
      /* Force all sides of border to display */
      .ability-item div,
      .relic-grid div,
      [class*="ability"] div,
      .ability-name {
        border-left: 1px solid #00ffff !important;
        border-right: 1px solid #00ffff !important;
        border-top: 1px solid #00ffff !important;
        border-bottom: 1px solid #00ffff !important;
      }
      
      /* Fix for nested ability names inside level box */
      .ability-level .ability-name,
      div[class*="ability"] .ability-name,
      .relic-grid div .ability-name {
        margin-left: 0 !important;
        text-align: left !important;
        border-left: none !important;
      }
      
      /* Fix any specific ability types that might be breaking the layout */
      div[data-ability-type],
      .ability-locked,
      .ability-unlocked {
        display: flex !important;
        flex-direction: row !important;
        height: 35px !important;
        width: 100% !important;
        overflow: hidden !important;
      }
      
      /* Style for locked abilities */
      .ability-name.locked {
        color: #777 !important;
        text-shadow: none !important;
      }
      
      /* Add spacing between relic cards */
      .relic-item {
        margin-bottom: 35px !important;
      }
      
      /* Add more spacing to the bottom ability row */
      .relic-grid {
        margin-bottom: 10px !important;
      }
      
      /* Fix tooltip spacing */
      #relics-tab .equipment-tooltip {
        margin-top: 25px !important;
        padding-top: 5px !important;
      }
      
      /* Fix ALL tab tooltips to appear below parent items */
      #equipment-tab .equipment-tooltip,
      #equipment-tab .tooltip,
      #spells-tab .tooltip,
      #items-tab .tooltip,
      #skills-tab .tooltip {
        position: absolute !important;
        top: 100% !important; /* Position below parent */
        bottom: auto !important; /* Override bottom positioning */
        left: 0 !important;
        right: 0 !important;
        margin-top: 5px !important; /* Space between item and tooltip */
        max-width: 100% !important;
        width: 100% !important;
      }
      
      /* Hide any duplicate relic slots - but keep legs and feet visible */
      .equipment-item[onclick*="toggleRelicEquip"]:not([data-slot]) {
        display: none !important;
      }
      
      /* Force custom relic slots to ALWAYS display, with highest priority */
      .equipment-item.custom-relic-slot,
      div[data-is-relic="true"],
      div[data-slot^="relic_"] {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        z-index: 100 !important;
      }
      
      /* Extra specific fixes for tooltips in relic items */
      .relic-item .relic-tooltip,
      div[class*='relic'] .tooltip,
      div[class*='tooltip'][style*='display: block'],
      #relics-tab .tooltip[style*='display: block'] {
        white-space: normal !important;
        overflow: visible !important;
        text-overflow: clip !important;
        word-break: break-word !important;
        word-wrap: break-word !important;
        height: 62px !important;
        min-height: 62px !important;
        max-height: 62px !important;
        line-height: 14px !important;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <!-- We've integrated relic functionality directly into this file -->
    <!-- Audio elements for game sounds -->
    <audio id="bgMusic" loop preload="auto">
      <source
        src="https://storage.googleapis.com/files.tinycode.dev/free/Rolemusic-01-Shipwreck-In-The-Pacific-Ocean.mp3"
        type="audio/mpeg"
      />
    </audio>
    <audio id="clickSound" preload="auto">
      <source src="https://storage.googleapis.com/files.tinycode.dev/free/click.mp3" type="audio/mpeg" />
    </audio>
    <audio id="combatSound" preload="auto">
      <source src="https://storage.googleapis.com/files.tinycode.dev/free/combat.mp3" type="audio/mpeg" />
    </audio>
    <audio id="levelUpSound" preload="auto">
      <source src="https://storage.googleapis.com/files.tinycode.dev/free/levelup.mp3" type="audio/mpeg" />
    </audio>
    <audio id="powerupSound" preload="auto">
      <source src="https://storage.googleapis.com/files.tinycode.dev/free/powerup.mp3" type="audio/mpeg" />
    </audio>
    <!-- Version check script to verify changes are loaded -->
  <script src="version-check.js?v=20250513"></script>
  <script src="debug-fix.js?v=20250517"></script>
  <script src="relic-debug.js?v=20250519"></script>
  <!-- Inline script to fix relic system issues -->
  <script>
  // Relic System Fixes - v1.1 (2025-05-22 08:55)
  document.addEventListener('DOMContentLoaded', function() {
    console.log('[INLINE-FIX] Applying inline relic system fixes');
    
    // Function to combine level number and name divs
    function combineAbilityDivs() {
      console.log('[INLINE-FIX] Combining ability level and name divs');
      
      // Find all ability items with level and name divs
      const abilityItems = document.querySelectorAll('.ability-item, [class*="ability-container"], div[data-ability-id], .relic-grid > div');
      
      abilityItems.forEach(item => {
        const levelDiv = item.querySelector('.ability-level');
        const nameDiv = item.querySelector('.ability-name');
        
        if (levelDiv && nameDiv) {
          // Get the level number
          const levelNum = levelDiv.textContent.trim();
          
          // Get the ability name
          const abilityName = nameDiv.textContent.trim();
          
          // Only prepend the level number if it's not already part of the name
          if (!abilityName.startsWith(levelNum)) {
            nameDiv.textContent = levelNum + ' ' + abilityName;
          }
          
          // Remove the level div completely
          if (levelDiv.parentNode) {
            levelDiv.parentNode.removeChild(levelDiv);
          }
          
          // Apply full styling to the name div
          nameDiv.style.width = '100%';
          nameDiv.style.border = '1px solid #00ffff';
          nameDiv.style.padding = '0 8px';
          nameDiv.style.boxSizing = 'border-box';
        }
        
        // Also handle any other level number divs that might have different class names
        const allDivs = item.querySelectorAll('div');
        allDivs.forEach(div => {
          if (div.clientWidth < 30 && div.textContent.trim().match(/^\d+$/)) {
            // This is likely a level number div - remove it
            if (div.parentNode) {
              div.parentNode.removeChild(div);
            }
          }
        });
      });
      
      // After combining divs, add tooltips to the grid items
      addTooltipsToGridItems();
    }
    
    // Function to add a single tooltip to the relic card that updates based on hover
    // GLOBAL HELPER: Access ability descriptions from anywhere in the code
    window.getAbilityDescription = function(abilityName) {
      console.log(`[TOOLTIP] Getting description for: ${abilityName}`);
      
      // First try to get data from player object
      const player = GameStateManager?.state?.player;
      if (player && player.relics) {
        // Check each relic for the ability
        for (const relicKey in player.relics) {
          const relic = player.relics[relicKey];
          if (relic && relic.abilities) {
            // Find the ability with this name
            const ability = relic.abilities.find(a => {
              // Try to match with or without level prefix
              const nameWithoutLevel = a.name;
              const regex = new RegExp(`^\d+\s+${nameWithoutLevel}$`);
              return a.name === abilityName || abilityName.match(regex) || 
                     abilityName.includes(nameWithoutLevel);
            });
            if (ability && ability.description) {
              console.log(`[TOOLTIP] Found description for ${abilityName} in player data: ${ability.description}`);
              return ability.description;
            }
          }
        }
      }
      
      // Fallback to predefined descriptions
      const tooltipTexts = {
        'Reality Guide': '+1 to all stats, summon your guide to give you a hint about what to do next',
        'Visit the Bodega': '+2 to all stats, summon your guide who will let you access a shop to buy and sell consumable items',
        'Get to Work': '+3 to all stats, summon your guide who will let you access a shop to buy and sell consumable items, armor, and weapons',
        'Bodega Superstore': '+4 to all stats, summon your guide who will let you access a shop to buy and sell consumable items, armor, and weapons',
        'Relic Fusion': '+5 to all stats, summon your guide who will let you fuse relic pieces together to create new relics',
        'Guide\'s Blessing': '+6 to all stats, summon your guide to heal you and your party and restore your MP, this can only be used once every 20 fights'
      };
      
      // Try to match by extracting name without level
      const nameMatch = abilityName.match(/^\d+\s+(.+)$/);
      if (nameMatch) {
        const nameWithoutLevel = nameMatch[1];
        if (tooltipTexts[nameWithoutLevel]) {
          console.log(`[TOOLTIP] Found description for ${abilityName} in predefined texts: ${tooltipTexts[nameWithoutLevel]}`);
          return tooltipTexts[nameWithoutLevel];
        }
      }
      
      // Direct lookup
      if (tooltipTexts[abilityName]) {
        return tooltipTexts[abilityName];
      }
      
      // Last resort
      console.log(`[TOOLTIP] No description found for ${abilityName}, using default`); 
      return abilityName + ' - Unlock new possibilities';
    };
    
    function addTooltipsToGridItems() {
      console.log('[INLINE-FIX] Adding single dynamic tooltip to relic cards');
      
      // Find all relic items
      const relicItems = document.querySelectorAll('.relic-item');
      
      relicItems.forEach(relicItem => {
        // Create a single tooltip for each relic item
        let relicTooltip = relicItem.querySelector('.relic-tooltip');
        if (!relicTooltip) {
          relicTooltip = document.createElement('div');
          relicTooltip.className = 'relic-tooltip';
          relicItem.appendChild(relicTooltip);
          
          // Style the tooltip - enhanced for proper text wrapping
          relicTooltip.style.position = 'absolute';
          relicTooltip.style.top = '100%';
          relicTooltip.style.left = '0';
          relicTooltip.style.width = '100%';
          relicTooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
          relicTooltip.style.border = '1px solid #00ffff';
          relicTooltip.style.color = '#00ff00';
          relicTooltip.style.padding = '4px 8px';
          relicTooltip.style.marginTop = '5px';
          relicTooltip.style.boxSizing = 'border-box';
          relicTooltip.style.zIndex = '1000';
          relicTooltip.style.fontSize = '11px';
          relicTooltip.style.display = 'none'; // Hide by default
          relicTooltip.style.height = '62px';
          relicTooltip.style.minHeight = '62px';
          relicTooltip.style.maxHeight = '62px';
          relicTooltip.style.whiteSpace = 'normal !important';
          relicTooltip.style.overflow = 'visible !important';
          relicTooltip.style.textOverflow = 'clip !important';
          relicTooltip.style.lineHeight = '14px';
        }
        
        // Find all grid items within this relic
        const gridItems = relicItem.querySelectorAll('.relic-grid > div');
        
        // Set default tooltip text for the relic itself
        relicItem.addEventListener('mouseenter', (e) => {
          if (e.target === relicItem || !isGridItemHovered) {
            relicTooltip.textContent = relicItem.querySelector('h3')?.textContent || 'Relic Item';
            relicTooltip.style.display = 'block';
          }
        });
        
        // Hide tooltip when leaving the relic
        relicItem.addEventListener('mouseleave', () => {
          relicTooltip.style.display = 'none';
          isGridItemHovered = false;
        });
        
        // Flag to track if a grid item is being hovered
        let isGridItemHovered = false;
        
        // Add hover events to each grid item
        gridItems.forEach(item => {
          // Get the name div to extract the ability name
          const nameDiv = item.querySelector('.ability-name');
          if (!nameDiv) return;
          
          // Extract name without level number
          let abilityName = nameDiv.textContent.trim();
          const match = abilityName.match(/^\d+\s+(.+)$/);
          if (match) {
            abilityName = match[1]; // Get the name part after the level number
          }
          
          // Set tooltip text when hovering over this grid item
          item.addEventListener('mouseenter', () => {
            isGridItemHovered = true;
            relicTooltip.textContent = getAbilityDescription(abilityName);
            relicTooltip.style.display = 'block';
            
            // Ensure text wrapping properties are correctly applied every time
            relicTooltip.style.whiteSpace = 'normal';
            relicTooltip.style.overflow = 'visible';
            relicTooltip.style.textOverflow = 'clip';
            
            // Apply enhanced styling for ALL tooltips to ensure wrapping
            console.log('[INLINE-FIX] Applying enhanced tooltip styling for ' + abilityName);
            // Force text wrapping for all tooltips
            relicTooltip.style.wordBreak = 'break-word';
            relicTooltip.style.wordWrap = 'break-word';
            relicTooltip.style.whiteSpace = 'normal !important';
            relicTooltip.style.textOverflow = 'clip !important';
            relicTooltip.style.lineHeight = '14px';
            relicTooltip.style.height = '62px';
            relicTooltip.style.minHeight = '62px';
            relicTooltip.style.maxHeight = '62px';
          });
          
          // Reset flag when leaving the grid item
          item.addEventListener('mouseleave', () => {
            isGridItemHovered = false;
            // When leaving a grid item, show the default relic tooltip
            relicTooltip.textContent = relicItem.querySelector('h3')?.textContent || 'Relic Item';
          });
        });
      });
    }
    
    // Run when tabs change or after a short delay
    function setupAbilityDivCombiner() {
      // Initial combination
      setTimeout(combineAbilityDivs, 500);
      
      // Watch for tab changes
      const tabButtons = document.querySelectorAll('.tab-button');
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          setTimeout(combineAbilityDivs, 300);
          // Also refresh tooltips when tabs change
          setTimeout(function() {
            console.log('[TOOLTIP] Refreshing tooltips after tab change');
            if (window.setupTooltips) {
              window.setupTooltips();
            } else {
              console.error('[TOOLTIP] setupTooltips not found in window object!');
            }
          }, 400);
        });
      });
    }
    
    // Set up tooltips when the page loads
    document.addEventListener('DOMContentLoaded', function() {
      console.log('[TOOLTIP] DOM loaded - initializing tooltip system');
      // Initial tooltip setup
      setTimeout(window.setupTooltips, 1000);
      
      // Set up observer for DOM changes to relics and equipment
      const observer = new MutationObserver(function(mutations) {
        console.log(`[TOOLTIP] Mutation detected: ${mutations.length} mutations`);
        let needsTooltipRefresh = false;
        
        mutations.forEach(function(mutation) {
          const target = mutation.target;
          console.log(`[TOOLTIP] Mutation in: ${target.id || target.className || 'unnamed element'}`);
          
          // Be more aggressive about refreshing tooltips
          if (target.id === 'relics-container' || 
              target.id === 'equipment-tab' ||
              target.id === 'relics-tab' ||
              target.classList?.contains('relic-item') ||
              target.classList?.contains('relic-grid') ||
              target.classList?.contains('equipment-item') ||
              target.classList?.contains('tab-content') ||
              (target.tagName === 'DIV' && target.parentElement && 
               (target.parentElement.classList?.contains('relic-grid') || 
                target.parentElement.id === 'relics-container'))) {
            console.log('[TOOLTIP] Detected relevant change - refreshing tooltips');
            needsTooltipRefresh = true;
          }
        });
        
        // Only call setupTooltips once per batch of mutations
        if (needsTooltipRefresh) {
          console.log('[TOOLTIP] Refreshing tooltips due to DOM changes');
          setTimeout(window.setupTooltips, 100);
          // Also run addTooltipsToGridItems directly
          if (typeof addTooltipsToGridItems === 'function') {
            setTimeout(addTooltipsToGridItems, 150);
          }
        }
      });
      
      // Start observing more aggressively - observe the entire character screen
      setTimeout(function() {
        const characterScreen = document.getElementById('characterScreen');
        if (characterScreen) {
          console.log('[TOOLTIP] Starting observation of entire character screen');
          observer.observe(characterScreen, { childList: true, subtree: true });
        }
        
        // Also observe specific containers
        const containers = [
          'relics-container', 'equipment-tab', 'relics-tab', 
          'equipment-slots-container', 'tab-scroll'
        ];
        
        containers.forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            console.log(`[TOOLTIP] Starting observation of ${id}`);
            observer.observe(element, { childList: true, subtree: true, attributes: true });
          }
        });
        
        // Observe all tab content
        document.querySelectorAll('.tab-content').forEach(tab => {
          observer.observe(tab, { childList: true, subtree: true });
          console.log(`[TOOLTIP] Observing tab: ${tab.id}`);
        });
      }, 1000); // Reduced time for faster response
      
      // Set up equipment tab button click to ensure tooltips work after tab change
      document.querySelectorAll('.tab-button').forEach(button => {
        button.addEventListener('click', function() {
          console.log(`[TOOLTIP] Tab button clicked: ${button.getAttribute('data-tab')}`);
          setTimeout(window.setupTooltips, 200);
          setTimeout(addTooltipsToGridItems, 250);
        });
      });
    });
    
    // Run setup after a short delay
    setTimeout(setupAbilityDivCombiner, 1000);
    
    // Wait a moment for game systems to initialize
    setTimeout(() => {
      console.log('Checking for relic system');
      
      // Add the EquipmentManager for unequipping items
      window.EquipmentManager = {
        // Unequip an item from a specific slot
        unequip: function(player, slot) {
          console.log(`[Equipment] Attempting to unequip item from slot: ${slot}`);
          
          if (!player || !player.equipment) {
            console.error('[Equipment] Cannot unequip: Player or equipment not found');
            return false;
          }
          
          // First try exact match
          if (player.equipment[slot]) {
            const item = player.equipment[slot];
            player.equipment[slot] = null;
            
            // Add item back to inventory
            if (item) {
              player.inventory.push(item);
              console.log(`[Equipment] Unequipped ${item.name} from ${slot} slot`);
              
              // Update UI after unequipping
              updateCharacterScreen();
              return true;
            }
          } else {
            // Try case-insensitive match if exact match failed
            const upperSlot = slot.toUpperCase();
            for (const [equipSlot, equipItem] of Object.entries(player.equipment)) {
              if (equipSlot.toUpperCase() === upperSlot && equipItem) {
                const item = equipItem;
                player.equipment[equipSlot] = null;
                
                // Add item back to inventory
                player.inventory.push(item);
                console.log(`[Equipment] Unequipped ${item.name} from ${equipSlot} slot (case-insensitive match)`);
                
                // Update UI after unequipping
                updateCharacterScreen();
                return true;
              }
            }
          }
          
          console.warn(`[Equipment] No item found in slot: ${slot}`);
          return false;
        }
      };
      
      // Create a general updateCharacterScreen function if it doesn't exist
      if (typeof updateCharacterScreen !== 'function') {
        window.updateCharacterScreen = function() {
          const characterScreen = document.getElementById("characterScreen");
          if (!characterScreen || characterScreen.style.display === "none") return;
          
          // Force redraw the character screen
          const player = GameStateManager.state.player;
          if (!player) return;
          
          // Update equipment stats and refresh the UI
          document.getElementById("char-name").textContent = player.name;
          document.getElementById("char-level").textContent = player.level;
          document.getElementById("char-class").textContent = player.class;
          
          // Update stats display
          document.getElementById("player-health-display").textContent = `${player.hp}/${player.derivedStats.maxHp}`;
          document.getElementById("player-mana-display").textContent = `${player.mp}/${player.derivedStats.maxMp}`;
        };
      }
      
      if (window.RELIC_SYSTEM) {
        const originalApply = window.RELIC_SYSTEM.applyRelicBonuses;
        window.RELIC_SYSTEM.applyRelicBonuses = function(player, relicName) {
          console.log(`[INLINE-FIX] Applying relic ${relicName} with fixed function`);
          
          // Get the relic
          const relic = player.relics[relicName];
          if (!relic) return false;
          
          // Initialize equipment object if needed
          if (!player.equipment) player.equipment = {};
          
          // Setup relic slots
          if (player.equipment.relic_1 === undefined) player.equipment.relic_1 = null;
          if (player.equipment.relic_2 === undefined) player.equipment.relic_2 = null;
          
          // Setup applied bonuses tracking
          if (!player.appliedRelicBonuses) player.appliedRelicBonuses = {};
          
          // Check if already applied
          if (player.appliedRelicBonuses[relicName]) {
            console.log(`[INLINE-FIX] Relic ${relicName} already applied`);
            return false;
          }
          
          // Count equipped relics
          let equippedCount = 0;
          for (const key in player.appliedRelicBonuses) {
            if (player.appliedRelicBonuses[key] === true) equippedCount++;
          }
          
          if (equippedCount >= 2) {
            console.log('[INLINE-FIX] Cannot equip more than 2 relics');
            if (typeof UIManager !== 'undefined' && UIManager.log) {
              UIManager.log('You cannot equip more than 2 relics at once. Unequip one first.');
            }
            return false;
          }
          
          // Remember HP/MP status
          const wasAtMaxHP = player.derivedStats && player.hp >= player.derivedStats.maxHp - 1;
          const wasAtMaxMP = player.derivedStats && player.mp >= player.derivedStats.maxMp - 1;
          
          // Apply stat bonuses
          player.stats.strength += relic.level;
          player.stats.dexterity += relic.level;
          player.stats.intelligence += relic.level;
          player.stats.vitality += relic.level;
          player.stats.fortune += relic.level;
          player.stats.charisma += relic.level;
          
          // Add to equipment slots
          if (player.equipment.relic_1 === null) {
            console.log(`[INLINE-FIX] Adding ${relicName} to relic_1 slot`);
            player.equipment.relic_1 = {
              name: relic.name,
              type: 'relic',
              relicId: relicName,
              level: relic.level
            };
          } else if (player.equipment.relic_2 === null) {
            console.log(`[INLINE-FIX] Adding ${relicName} to relic_2 slot`);
            player.equipment.relic_2 = {
              name: relic.name,
              type: 'relic',
              relicId: relicName,
              level: relic.level
            };
          } else {
            console.log('[INLINE-FIX] No available relic slots');
            return false;
          }
          
          // Mark as applied
          player.appliedRelicBonuses[relicName] = true;
          
          // Recalculate derived stats
          if (typeof LEVELING_SYSTEM !== 'undefined' && LEVELING_SYSTEM.updateCharacterStats) {
            LEVELING_SYSTEM.updateCharacterStats(player);
            
            // Maintain max HP/MP
            if (wasAtMaxHP && player.derivedStats) player.hp = player.derivedStats.maxHp;
            if (wasAtMaxMP && player.derivedStats) player.mp = player.derivedStats.maxMp;
          }
          
          // CRITICAL FIX: Make sure the relics tab stays visible
          setTimeout(function() {
            const relicsTab = document.getElementById('relics-tab');
            if (relicsTab) {
              console.log('[INLINE-FIX] Ensuring relics tab stays visible after equipping');
              // Keep any equipped relics visible in the tab
              // This prevents the tab from going empty and disappearing
              keepRelicsVisibleInTab(player);
            } else {
              console.error('[INLINE-FIX] Failed to find relics-tab element! Tab might disappear.');
            }
          }, 100); // Increased timeout to give DOM time to update
          
          return true;
        };
        
        // Override the removeRelicBonuses function to properly remove stat bonuses
        const originalRemove = window.RELIC_SYSTEM.removeRelicBonuses;
        window.RELIC_SYSTEM.removeRelicBonuses = function(player, relicName) {
          console.log(`[INLINE-FIX] Removing relic ${relicName} with fixed function`);
          
          // Get the relic
          const relic = player.relics[relicName];
          if (!relic) return false;
          
          // Make sure it's actually equipped/applied
          if (!player.appliedRelicBonuses || player.appliedRelicBonuses[relicName] !== true) {
            console.log(`[INLINE-FIX] Relic ${relicName} is not currently applied`);
            return false;
          }
          
          // Get the exact bonus amount to remove
          const bonusAmount = relic.level;
          
          // Remove from equipment slots
          let removed = false;
          if (player.equipment) {
            if (player.equipment.relic_1 && player.equipment.relic_1.relicId === relicName) {
              console.log(`[INLINE-FIX] Removing ${relicName} from relic_1 slot`);
              player.equipment.relic_1 = null;
              removed = true;
            } else if (player.equipment.relic_2 && player.equipment.relic_2.relicId === relicName) {
              console.log(`[INLINE-FIX] Removing ${relicName} from relic_2 slot`);
              player.equipment.relic_2 = null;
              removed = true;
            }
          }
          
          // CRITICAL FIX: Explicitly subtract the exact bonus amount
          console.log(`[INLINE-FIX] Removing ${bonusAmount} points from all stats`);
          player.stats.strength -= bonusAmount;
          player.stats.dexterity -= bonusAmount;
          player.stats.intelligence -= bonusAmount;
          player.stats.vitality -= bonusAmount;
          player.stats.fortune -= bonusAmount;
          player.stats.charisma -= bonusAmount;
          
          // Mark as not applied
          player.appliedRelicBonuses[relicName] = false;
          
          // Recalculate derived stats
          if (typeof LEVELING_SYSTEM !== 'undefined' && LEVELING_SYSTEM.updateCharacterStats) {
            LEVELING_SYSTEM.updateCharacterStats(player);
            
            // Cap HP/MP at new maximums
            if (player.derivedStats) {
              if (player.hp > player.derivedStats.maxHp) {
                player.hp = player.derivedStats.maxHp;
              }
              if (player.mp > player.derivedStats.maxMp) {
                player.mp = player.derivedStats.maxMp;
              }
            }
          }
          
          // CRITICAL FIX: Immediately ensure the relics tab is properly maintained
          // This is a high-priority fix that ensures the tab remains visible
          ensureRelicsTab(); // Make sure the tab exists before anything else
          
          // Log the DOM state for debugging
          console.log('[CRITICAL] Debugging DOM state before UI update:');
          console.log('Relics tab exists:', !!document.getElementById('relics-tab'));
          
          // Update UI with the relic shown in the tab as unequipped - with longer timeout
          // and more robust error handling
          setTimeout(function() {
            try {
              console.log('[DEBUG] Running keepRelicsVisibleInTab with delayed timing');
              keepRelicsVisibleInTab(player);
              
              // Double-check that it worked
              setTimeout(function() {
                if (!document.getElementById('relics-tab')) {
                  console.log('[CRITICAL] Tab still missing after first attempt, recreating...');
                  ensureRelicsTab();
                  updateRelicsTab(player);
                }
              }, 100);
            } catch (e) {
              console.error('[ERROR] Failed in setTimeout callback:', e);
              // Emergency recovery
              ensureRelicsTab();
              updateRelicsTab(player);
            }
          }, 200); // Longer timeout for more stability
          
          return true;
        };
        
        // DEBUG FUNCTION: Log the DOM state for debugging
        window.debugDOMState = function(message) {
          console.log('==== DOM STATE DEBUG: ' + message + ' ====');
          console.log('Character screen exists:', !!document.getElementById('characterScreen'));
          console.log('Relics tab exists:', !!document.getElementById('relics-tab'));
          console.log('Relics container exists:', !!document.getElementById('relics-container'));
          console.log('Tab buttons:', document.querySelectorAll('.tab-button').length);
          console.log('Active tabs:', document.querySelectorAll('.tab-content.active').length);
          
          // Check all tabs
          const allTabs = document.querySelectorAll('.tab-content');
          console.log('All tabs:', Array.from(allTabs).map(tab => tab.id));
          
          // Check all tab buttons
          const allButtons = document.querySelectorAll('.tab-button');
          console.log('All buttons:', Array.from(allButtons).map(btn => btn.getAttribute('data-tab')));
        };
        
        // Function to ensure relics remain visible in the tab even when equipped
        window.keepRelicsVisibleInTab = function(player) {
          console.log('[INLINE-FIX] Ensuring relics remain visible in tab');
          
          // DEBUG: Log DOM state before any changes
          debugDOMState('Before keepRelicsVisibleInTab');
          
          // Critical: Get the equipped relics first
          if (!player || !player.relics) {
            console.warn('[INLINE-FIX] Player or relics not defined');
            return;
          }
          
          // Remember ALL active tabs to make sure we don't disrupt UI
          const activeTabs = [];
          document.querySelectorAll('.tab-content.active').forEach(tab => {
            activeTabs.push(tab.id);
            console.log('Active tab found:', tab.id);
          });
          
          // Remember ALL active tab buttons
          const activeButtons = [];
          document.querySelectorAll('.tab-button.active').forEach(btn => {
            activeButtons.push(btn.getAttribute('data-tab'));
            console.log('Active button found:', btn.getAttribute('data-tab'));
          });

          // CRITICAL FIX: First ensure relics tab EXISTS in DOM before trying to update it
          // If it doesn't exist, we need to create it
          let relicsTab = document.getElementById('relics-tab');
          if (!relicsTab) {
            console.warn('[INLINE-FIX] Relics tab not found - attempting to recreate it');
            
            // Find character screen container
            const characterScreen = document.getElementById('characterScreen');
            if (characterScreen) {
              // Create the tab if it doesn't exist
              relicsTab = document.createElement('div');
              relicsTab.id = 'relics-tab';
              relicsTab.className = 'tab-content';
              relicsTab.innerHTML = `
                <div class="equipment-screen-content">
                  <div class="equipment-list">
                    <div id="relics-container"></div>
                  </div>
                  <div class="equipment-tooltip" id="relicTooltip">
                    <div class="title">Relic Ability Information</div>
                    <div class="description">Click on a relic ability to see details</div>
                  </div>
                </div>
              `;
              characterScreen.appendChild(relicsTab);
              console.log('[INLINE-FIX] Recreated missing relics tab');
            }
          }

          // Check again because we might have recreated it
          relicsTab = document.getElementById('relics-tab');
          if (!relicsTab) {
            console.error('[INLINE-FIX] Failed to find or create relics-tab!');
            return; // Nothing more we can do
          }
          
          // NOW we can safely get the active state, AFTER confirming tab exists
          // DEFENSIVE: Check if classList exists before using it
          let relicsTabWasActive = false;
          try {
            if (relicsTab && relicsTab.classList) {
              relicsTabWasActive = relicsTab.classList.contains('active');
              console.log('[DEBUG] relicsTab.classList exists:', !!relicsTab.classList);
              console.log('[DEBUG] relicsTabWasActive:', relicsTabWasActive);
            } else {
              console.error('[ERROR] relicsTab or relicsTab.classList is null/undefined!');
              console.log('[DEBUG] relicsTab:', relicsTab);
              // Emergency fix: recreate the tab again
              window.ensureRelicsTab();
              relicsTab = document.getElementById('relics-tab'); // refresh reference
            }
          } catch (e) {
            console.error('[CRITICAL] Error checking tab active state:', e);
          }
          
          // DEBUG: Log DOM state after potential fix but before updateRelicsTab
          debugDOMState('After potential classList fix');
          
          if (typeof updateRelicsTab === 'function') {
            // Update the tab with relics
            try {
              console.log('[DEBUG] Calling updateRelicsTab from keepRelicsVisibleInTab');
              updateRelicsTab(player);
            } catch (e) {
              console.error('[CRITICAL] Error in updateRelicsTab:', e);
            }
            
            // DEBUG: Log DOM state after updateRelicsTab
            debugDOMState('After updateRelicsTab');
            
            // CRITICAL: Restore ALL tabs that were active
            console.log('[DEBUG] Restoring active tabs:', activeTabs);
            activeTabs.forEach(tabId => {
              try {
                const tab = document.getElementById(tabId);
                if (tab && tab.classList) {
                  tab.classList.add('active');
                  console.log('[DEBUG] Restored active state to tab:', tabId);
                } else {
                  console.warn('[WARN] Could not restore active state to tab, missing classList:', tabId);
                }
              } catch (e) {
                console.error('[ERROR] Error restoring tab active state:', e);
              }
            });
            
            // Restore ALL buttons that were active
            console.log('[DEBUG] Restoring active buttons:', activeButtons);
            document.querySelectorAll('.tab-button').forEach(btn => {
              try {
                if (activeButtons.includes(btn.getAttribute('data-tab')) && btn.classList) {
                  btn.classList.add('active');
                  console.log('[DEBUG] Restored active state to button:', btn.getAttribute('data-tab'));
                }
              } catch (e) {
                console.error('[ERROR] Error restoring button active state:', e);
              }
            });
            
            // Ensure relics tab button exists
            const tabScroll = document.getElementById('tab-scroll');
            let relicsTabButton = null;
            document.querySelectorAll('.tab-button').forEach(btn => {
              if (btn.getAttribute('data-tab') === 'relics-tab') {
                relicsTabButton = btn;
              }
            });
            
            if (!relicsTabButton && tabScroll) {
              relicsTabButton = document.createElement('button');
              relicsTabButton.className = 'tab-button';
              relicsTabButton.setAttribute('data-tab', 'relics-tab');
              relicsTabButton.textContent = 'Relics';
              tabScroll.appendChild(relicsTabButton);
            }
            
            // Double-ensure the relics tab stays active if it was active
            if (relicsTabWasActive && relicsTab) {
              relicsTab.classList.add('active');
              
              // Make the button active too if it was active
              if (relicsTabButton) {
                relicsTabButton.classList.add('active');
              }
            }
          }
        };
        
        console.log('[INLINE-FIX] Successfully patched relic system functions');
      } else {
        console.warn('[INLINE-FIX] RELIC_SYSTEM not found, could not apply fixes');
      }
    }, 1000);  // Wait 1 second for initialization
  });
  </script>
</head>
  <body>
    <div id="game-container">
      <div id="topNav">
        <div class="stat-group">
          <img
            src="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/HP-1ZKK6dAxTTGqM7n16hCEnobDxYAsv2.png?I1UO"
            class="stat-icon"
            alt="HP"
          />
          <span class="stat-value" id="hp">100</span>
        </div>
        <div class="stat-group">
          <img
            src="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/MP-ziN5NpopfuoTWmE8fTlnoncWgLhFM7.png?wMfk"
            class="stat-icon"
            alt="MP"
          />
          <span class="stat-value" id="mp">100</span>
        </div>
        <div class="stat-group">
          <img
            src="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Level-cbODOeFY5BPWUMvVTR1sUrSH22hjZI.png?8KWg"
            class="stat-icon"
            alt="Level"
          />
          <span class="stat-value" id="level">1</span>
        </div>
        <div class="stat-group">
          <img
            src="https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/xp-TLepOWPV6xaLjEYdvwLpLf8hxLl55F.png?kCJy"
            class="stat-icon"
            alt="XP"
          />
          <span class="stat-value" id="xp">0</span>
        </div>
      </div>
      <canvas id="gameCanvas"></canvas>
      <div id="gameLog"></div>
      <div id="startScreen">
        <div class="start-content">
          <button
            class="button"
            onclick="startGame()"
            style="
              color: #edd628;
              border-color: #9932cc;
              background: linear-gradient(135deg, rgba(153, 50, 204, 0.8) 0%, rgba(153, 50, 204, 0.4) 100%);
              text-shadow:
                0 0 10px #000,
                0 0 20px #000,
                0 0 30px #9932cc;
              box-shadow: 0 0 20px rgba(153, 50, 204, 0.5);
            "
          >
            Start Game
          </button>
          <h1
            style="
              color: #edd628;
              text-shadow:
                0 0 7px #9932cc,
                0 0 10px #9932cc,
                0 0 21px #9932cc,
                0 0 42px #9932cc;
            "
          >
            Glitter Cloud Adventure
          </h1>
        </div>
      </div>
      <div id="characterSelect" style="display: none">
        <h2>Choose Your Character</h2>
        <h3>Change Characters to Reroll Stats</h3>
        <div id="characterList"></div>
      </div>
      <div id="characterScreen">
        <button class="close-button" onclick="toggleCharacterScreen()">×</button>
        <div class="character-header">
          <h2 id="char-name">Character Name</h2>
          <div class="level-class">Level <span id="char-level">1</span> <span id="char-class">Class</span></div>
          <div class="character-portrait">
            <img
              src="${player.sprite || 'https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flexecutioner-YTnx5DSfVR0ALUTlZc9Kt5xLlJFP4m.png?DUxz'}"
              alt="${player.class} portrait"
            />
          </div>
        </div>
        <div class="tab-navigation">
          <button class="tab-arrow left" id="tab-nav-left" onclick="scrollTabs('left')">&#10094;</button>
          <div class="tab-scroll" id="tab-scroll">
            <button class="tab-button active" data-tab="stats-tab">Stats</button>
            <button class="tab-button" data-tab="equipment-tab">Equipment</button>
            <button class="tab-button" data-tab="items-tab">Items</button>
            <button class="tab-button" data-tab="skills-tab">Skills</button>
            <button class="tab-button" data-tab="spells-tab">Spells</button>
            <button class="tab-button" data-tab="relics-tab">Relics</button>
          </div>
          <button class="tab-arrow right" id="tab-nav-right" onclick="scrollTabs('right')">&#10095;</button>
        </div>
        <div class="tab-content active" id="stats-tab">
          <div class="stats-grid">
            <div class="stat-box">
              <span class="stat-label">Strength</span>
              <span class="stat-controls">
                <button
                  class="stat-button minus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'strength', -1)"
                >
                  -
                </button>
                <span class="stat-value">${player.stats.strength}</span>
                <button
                  class="stat-button plus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'strength', 1)"
                >
                  +
                </button>
              </span>
            </div>
            <div class="stat-box">
              <span class="stat-label">Intelligence</span>
              <span class="stat-controls">
                <button
                  class="stat-button minus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'intelligence', -1)"
                >
                  -
                </button>
                <span class="stat-value">${player.stats.intelligence}</span>
                <button
                  class="stat-button plus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'intelligence', 1)"
                >
                  +
                </button>
              </span>
            </div>
            <div class="stat-box">
              <span class="stat-label">Vitality</span>
              <span class="stat-controls">
                <button
                  class="stat-button minus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'vitality', -1)"
                >
                  -
                </button>
                <span class="stat-value">${player.stats.vitality}</span>
                <button
                  class="stat-button plus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'vitality', 1)"
                >
                  +
                </button>
              </span>
            </div>
            <div class="stat-box">
              <span class="stat-label">Dexterity</span>
              <span class="stat-controls">
                <button
                  class="stat-button minus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'dexterity', -1)"
                >
                  -
                </button>
                <span class="stat-value">${player.stats.dexterity}</span>
                <button
                  class="stat-button plus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'dexterity', 1)"
                >
                  +
                </button>
              </span>
            </div>
            <div class="stat-box">
              <span class="stat-label">Fortune</span>
              <span class="stat-controls">
                <button
                  class="stat-button minus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'fortune', -1)"
                >
                  -
                </button>
                <span class="stat-value">${player.stats.fortune}</span>
                <button
                  class="stat-button plus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'fortune', 1)"
                >
                  +
                </button>
              </span>
            </div>
            <div class="stat-box">
              <span class="stat-label">Charisma</span>
              <span class="stat-controls">
                <button
                  class="stat-button minus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'charisma', -1)"
                >
                  -
                </button>
                <span class="stat-value">${player.stats.charisma}</span>
                <button
                  class="stat-button plus"
                  onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'charisma', 1)"
                >
                  +
                </button>
              </span>
            </div>
          </div>
          <div class="progress-stats">
            <div class="progress-stat">
              <div class="progress-label">
                <span>Health</span>
                <span id="player-health-display">0/0</span>
              </div>
              <div class="progress-bar">
                <div class="hp-fill" style="width: 100%"></div>
              </div>
            </div>
            <div class="progress-stat">
              <div class="progress-label">
                <span>Magic</span>
                <span id="player-mana-display">0/0</span>
              </div>
              <div class="progress-bar">
                <div class="mp-fill" id="mp-fill-bar" style="width: 0%"></div>
              </div>
            </div>
            <div class="progress-stat">
              <div class="progress-label">
                <span>Experience</span>
                <span id="player-xp-display">0/0</span>
              </div>
              <div class="progress-bar">
                <div class="xp-fill" id="xp-fill-bar" style="width: 0%"></div>
              </div>
            </div>
            <div class="progress-stat">
              <div class="progress-label">
                <span>Stat Points</span>
                <span id="player-statpoints-display">0</span>
              </div>
            </div>
          </div>
          <div class="menu-buttons">
            <button class="menu-button" onclick="saveGame()">Save</button>
            <button class="menu-button" onclick="loadGame()">Load</button>
            ${player.statPoints === 0 && !player.statsLocked ? '<button
              class="menu-button confirm"
              onclick="confirmStatAllocation()"
            >
              Confirm</button
            >' : ''}
          </div>
        </div>
        <div class="tab-content" id="equipment-tab">
          <div class="equipment-screen-content">
            <div class="equipment-list">
              <script>
                // Function to populate equipment slots when this tab is opened
                function populateEquipmentSlots() {
                  const player = GameStateManager.state.player;
                  if (!player || !player.equipment) return;
                  
                  const container = document.getElementById('equipment-slots-container');
                  if (!container) return;
                  
                  // IMPORTANT: Ensure all required slots exist in player equipment
                  // Full bidirectional synchronization between uppercase and lowercase slots
                  
                  // Main hand slot sync
                  if (player.equipment.main_hand && !player.equipment.MAIN_HAND) {
                    player.equipment.MAIN_HAND = player.equipment.main_hand;
                  } else if (!player.equipment.main_hand && player.equipment.MAIN_HAND) {
                    player.equipment.main_hand = player.equipment.MAIN_HAND;
                  }
                  
                  // Off hand slot sync
                  if (player.equipment.off_hand && !player.equipment.OFF_HAND) {
                    player.equipment.OFF_HAND = player.equipment.off_hand;
                  } else if (!player.equipment.off_hand && player.equipment.OFF_HAND) {
                    player.equipment.off_hand = player.equipment.OFF_HAND;
                  }
                  
                  // Head slot sync
                  if (player.equipment.head && !player.equipment.HEAD) {
                    player.equipment.HEAD = player.equipment.head;
                  } else if (!player.equipment.head && player.equipment.HEAD) {
                    player.equipment.head = player.equipment.HEAD;
                  }
                  
                  // Body slot sync
                  if (player.equipment.body && !player.equipment.BODY) {
                    player.equipment.BODY = player.equipment.body;
                  } else if (!player.equipment.body && player.equipment.BODY) {
                    player.equipment.body = player.equipment.BODY;
                  }
                  
                  // Legs slot sync
                  if (player.equipment.legs && !player.equipment.LEGS) {
                    player.equipment.LEGS = player.equipment.legs;
                  } else if (!player.equipment.legs && player.equipment.LEGS) {
                    player.equipment.legs = player.equipment.LEGS;
                  }
                  
                  // Feet slot sync
                  if (player.equipment.feet && !player.equipment.FEET) {
                    player.equipment.FEET = player.equipment.feet;
                  } else if (!player.equipment.feet && player.equipment.FEET) {
                    player.equipment.feet = player.equipment.FEET;
                  }
                  
                  // Relic slot sync
                  if (player.equipment.relic_1 && !player.equipment.RELIC_1) {
                    player.equipment.RELIC_1 = player.equipment.relic_1;
                  } else if (!player.equipment.relic_1 && player.equipment.RELIC_1) {
                    player.equipment.relic_1 = player.equipment.RELIC_1;
                  }
                  
                  if (player.equipment.relic_2 && !player.equipment.RELIC_2) {
                    player.equipment.RELIC_2 = player.equipment.relic_2;
                  } else if (!player.equipment.relic_2 && player.equipment.RELIC_2) {
                    player.equipment.relic_2 = player.equipment.RELIC_2;
                  }
                  
                  // Create any missing slots
                  if (!player.equipment.main_hand) player.equipment.main_hand = null;
                  if (!player.equipment.off_hand) player.equipment.off_hand = null;
                  if (!player.equipment.head) player.equipment.head = null;
                  if (!player.equipment.body) player.equipment.body = null;
                  if (!player.equipment.legs) player.equipment.legs = null;
                  if (!player.equipment.feet) player.equipment.feet = null;
                  if (!player.equipment.relic_1) player.equipment.relic_1 = null;
                  if (!player.equipment.relic_2) player.equipment.relic_2 = null;
                  
                  // Ensure uppercase versions also exist
                  if (!player.equipment.MAIN_HAND) player.equipment.MAIN_HAND = null;
                  if (!player.equipment.OFF_HAND) player.equipment.OFF_HAND = null;
                  if (!player.equipment.HEAD) player.equipment.HEAD = null;
                  if (!player.equipment.BODY) player.equipment.BODY = null;
                  if (!player.equipment.LEGS) player.equipment.LEGS = null;
                  if (!player.equipment.FEET) player.equipment.FEET = null;
                  if (!player.equipment.RELIC_1) player.equipment.RELIC_1 = null;
                  if (!player.equipment.RELIC_2) player.equipment.RELIC_2 = null;
                  
                  // Define all slots to ensure legs and feet always appear
                  const slots = ['main_hand', 'off_hand', 'head', 'body', 'legs', 'feet', 'relic_1', 'relic_2'];
                  
                  let html = '';
                  slots.forEach(slot => {
                    // Use lowercase slot directly now that we've ensured it exists
                    let item = player.equipment[slot];
                    
                    const isRelic = slot.startsWith('relic_');
                    const displaySlot = isRelic ? (slot === 'relic_1' ? 'Relic 1' : 'Relic 2') : slot.replace(/_/g, " ");
                    
                    // Force relic slots to ALWAYS have the custom-relic-slot class
                    html += `
                      <div class="equipment-item ${isRelic ? 'custom-relic-slot' : ''}" 
                           data-slot="${slot}"
                           ${isRelic ? 'data-is-relic="true"' : ''}
                           onmouseover="showEquipmentInfo('${slot}', ${item ? JSON.stringify(item).replace(/"/g, '&quot;') : null})"
                           onmouseout="hideEquipmentInfo()"
                           onclick="${item ? (isRelic ? `toggleRelicEquip('${item.relicId}')` : `unequipItem('${slot}')`): ''}"
                      >
                        <span class="slot-label">${displaySlot}</span>
                        ${item
                            ? isRelic 
                                ? `<div class="item">
                                    <span class="item-name relic-name" title="${item.name} (Level ${item.level}) - Click to unequip">${item.name}</span>
                                  </div>` 
                                : `<div class="item"><span class="item-name" title="${item.name}">${getItemAcronym(item.name)}</span></div>`
                            : '<span class="empty-slot">Empty</span>'
                        }
                      </div>
                    `;
                  });
                  
                  container.innerHTML = html;
                }
                
                // Function to unequip items (direct implementation to avoid relying on EquipmentManager)
                function unequipItem(slot) {
                  const player = GameStateManager.state.player;
                  if (!player || !player.equipment) {
                    console.error('[Equipment] Cannot unequip: Player or equipment not found');
                    return;
                  }
                  
                  // Check if the item is a two-handed weapon (not just dumbbells)
                  let isTwoHandedWeapon = false;
                  let itemToUnequip = null;
                  if (player.equipment[slot]) {
                    const item = player.equipment[slot];
                    itemToUnequip = item;
                    // Check weapon type or properties to determine if it's two-handed
                    isTwoHandedWeapon = item.weaponType === '2h' || 
                                        item.isTwoHanded === true || 
                                        (item.properties && item.properties.includes('two-handed')) ||
                                        (item.name && (
                                          item.name.toLowerCase().includes('two-handed') ||
                                          item.name.toLowerCase().includes('2h') ||
                                          item.name.toLowerCase().includes('two handed') ||
                                          item.name.toLowerCase().includes('greatsword') ||
                                          item.name.toLowerCase().includes('battleaxe') ||
                                          item.name.toLowerCase().includes('greataxe') ||
                                          item.name.toLowerCase().includes('dumbbell') ||
                                          item.name.toLowerCase().includes('dumbell')
                                        ));
                    console.log(`[EQUIPMENT] Checking if ${item.name} is two-handed: ${isTwoHandedWeapon}`);
                  }
                  
                  // SPECIAL HANDLING: Also check other slot for dumbbells
                  if (!isTwoHandedWeapon) {
                    // Check both weapon slots for dumbbells by name
                    const slots = ['main_hand', 'off_hand', 'MAIN_HAND', 'OFF_HAND'];
                    for (const checkSlot of slots) {
                      if (player.equipment[checkSlot] && player.equipment[checkSlot].name && 
                          (player.equipment[checkSlot].name.toLowerCase().includes('dumbbell') || 
                           player.equipment[checkSlot].name.toLowerCase().includes('dumbell'))) {
                        console.log(`[EQUIPMENT] Found dumbbell in ${checkSlot}, treating as two-handed`);
                        isTwoHandedWeapon = true;
                        itemToUnequip = player.equipment[checkSlot];
                        break;
                      }
                    }
                  }
                  
                  if (isTwoHandedWeapon) {
                    console.log('[EQUIPMENT] Unequipping two-handed weapon from all slots');
                    let found = false;
                    
                    // IMPORTANT: First add one copy to inventory to avoid duplicates
                    if (itemToUnequip) {
                      console.log(`[EQUIPMENT] Adding ${itemToUnequip.name} to inventory`);
                      player.inventory.push(itemToUnequip);
                      found = true;
                    }
                    
                    // Clear main_hand and off_hand slots for two-handed weapons
                    // Only weapon slots need to be cleared for two-handed weapons
                    const weaponSlots = ['main_hand', 'MAIN_HAND', 'off_hand', 'OFF_HAND'];
                    
                    weaponSlots.forEach(equipSlot => {
                      // Clear all weapon slots when unequipping a two-handed weapon
                      if (player.equipment[equipSlot]) {
                        console.log(`[EQUIPMENT] Clearing ${equipSlot} slot`);
                        player.equipment[equipSlot] = null;
                      }
                    });
                    
                    if (found) {
                      console.log('[EQUIPMENT] Two-handed weapon successfully unequipped');
                      // Update display
                      populateEquipmentSlots();
                      
                      // IMPORTANT: Update character stats after unequipping
                      if (typeof LEVELING_SYSTEM !== 'undefined' && 
                          typeof LEVELING_SYSTEM.updateCharacterStats === 'function') {
                        LEVELING_SYSTEM.updateCharacterStats(player);
                      }
                      
                      // Show success message
                      if (typeof UIManager !== 'undefined' && UIManager.log) {
                        UIManager.log(`Successfully unequipped ${itemToUnequip ? itemToUnequip.name : 'two-handed weapon'}`);
                      }
                      return;
                    }
                  }
                  
                  // Standard unequip process for non-dumbbell items
                  // First check: Try direct lowercase slot match
                  if (player.equipment[slot]) {
                    const item = player.equipment[slot];
                    player.equipment[slot] = null;
                    
                    // Also clear the uppercase version if it exists
                    const upperSlot = slot.toUpperCase();
                    if (player.equipment[upperSlot]) {
                      player.equipment[upperSlot] = null;
                    }
                    
                    // Add to inventory
                    if (item) {
                      player.inventory.push(item);
                      console.log(`Unequipped ${item.name} from ${slot}`);
                      
                      // Update display
                      populateEquipmentSlots();
                      return;
                    }
                  } 
                  
                  // Second check: Try uppercase version directly
                  const upperSlot = slot.toUpperCase();
                  if (player.equipment[upperSlot]) {
                    const item = player.equipment[upperSlot];
                    player.equipment[upperSlot] = null;
                    
                    // Also clear the lowercase version if it exists
                    if (player.equipment[slot]) {
                      player.equipment[slot] = null;
                    }
                    
                    // Add to inventory
                    if (item) {
                      player.inventory.push(item);
                      console.log(`Unequipped ${item.name} from ${upperSlot}`);
                      
                      // Update display
                      populateEquipmentSlots();
                      return;
                    }
                  }
                  
                  // Third check: Try a case-insensitive search as last resort
                  const lowerSlot = slot.toLowerCase();
                  for (const [equipSlot, equipItem] of Object.entries(player.equipment)) {
                    if (equipSlot.toLowerCase() === lowerSlot && equipItem) {
                      const item = equipItem;
                      player.equipment[equipSlot] = null;
                      
                      // Add to inventory
                      player.inventory.push(item);
                      console.log(`Unequipped ${item.name} from ${equipSlot} (case-insensitive match)`);
                      
                      // Update display
                      populateEquipmentSlots();
                      return;
                    }
                  }
                  
                  console.error(`[Equipment] Could not find item in slot: ${slot}`);
                }
                
                // Function to equip an item from inventory
                function equipItem(slot, inventoryIndex) {
                  const player = GameStateManager.state.player;
                  if (!player || !player.inventory || !player.equipment) return;
                  
                  // Get the item from inventory
                  const item = player.inventory[inventoryIndex];
                  if (!item) return;
                  
                  // Check if slot is already occupied
                  if (player.equipment[slot]) {
                    // Remove existing item and add to inventory
                    player.inventory.push(player.equipment[slot]);
                  }
                  
                  // FORCED FIX: Special case for dumbbells to ensure they're always treated as two-handed
                  let isTwoHandedWeapon = false;
                  
                  // First check by explicit property
                  if (item.weaponType === '2h' || item.isTwoHanded === true || 
                      (item.properties && item.properties.includes('two-handed'))) {
                    isTwoHandedWeapon = true;
                  }
                  
                  // Then check by name for various two-handed weapons
                  if (item.name) {
                    const itemNameLower = item.name.toLowerCase();
                    if (itemNameLower.includes('two-handed') || 
                        itemNameLower.includes('2h') || 
                        itemNameLower.includes('two handed') || 
                        itemNameLower.includes('greatsword') || 
                        itemNameLower.includes('battleaxe') || 
                        itemNameLower.includes('greataxe')) {
                      isTwoHandedWeapon = true;
                    }
                    
                    // SPECIAL HANDLING: Always treat dumbbells as two-handed no matter what
                    if (itemNameLower.includes('dumbbell') || itemNameLower.includes('dumbell')) {
                      console.log('[EQUIPMENT] Detected dumbbell - FORCING two-handed treatment');
                      isTwoHandedWeapon = true;
                      // Explicitly mark as two-handed
                      item.isTwoHanded = true;
                    }
                  }
                  
                  // Equip the item
                  player.equipment[slot] = item;
                  
                  // If it's a two-handed weapon, also equip in off_hand AND all uppercase versions
                  if (isTwoHandedWeapon) {
                    console.log(`[EQUIPMENT] Equipping two-handed weapon ${item.name} in multiple slots`);
                    
                    // Make sure both hands are equipped
                    if (slot === 'main_hand' || slot === 'MAIN_HAND') {
                      if (player.equipment.off_hand) {
                        player.inventory.push(player.equipment.off_hand);
                      }
                      player.equipment.off_hand = item;
                      player.equipment.OFF_HAND = item;
                      
                      // Also ensure uppercase version
                      player.equipment.MAIN_HAND = item;
                    }
                    
                    if (slot === 'off_hand' || slot === 'OFF_HAND') {
                      if (player.equipment.main_hand) {
                        player.inventory.push(player.equipment.main_hand);
                      }
                      player.equipment.main_hand = item;
                      player.equipment.MAIN_HAND = item;
                      
                      // Also ensure uppercase version
                      player.equipment.OFF_HAND = item;
                    }
                    
                    console.log(`[EQUIPMENT] Two-handed weapon ${item.name} equipped in both main and off hand slots`);
                  }
                  
                  // Remove from inventory
                  player.inventory.splice(inventoryIndex, 1);
                  
                  // Refresh the UI
                  updateInventory();
                  populateEquipmentSlots();
                  
                  // IMPORTANT: Update character stats after equipping
                  if (typeof LEVELING_SYSTEM !== 'undefined' && 
                      typeof LEVELING_SYSTEM.updateCharacterStats === 'function') {
                    LEVELING_SYSTEM.updateCharacterStats(player);
                  }
                }
                
                // Add event listener to populate slots when the tab is shown
                document.addEventListener('DOMContentLoaded', function() {
                  const equipmentTabButton = document.querySelector('.tab-button[data-tab="equipment-tab"]');
                  if (equipmentTabButton) {
                    equipmentTabButton.addEventListener('click', populateEquipmentSlots);
                  }
                  
                  // Also populate on character screen open
                  const characterButton = document.querySelector('#characterButton');
                  if (characterButton) {
                    characterButton.addEventListener('click', function() {
                      setTimeout(populateEquipmentSlots, 100);
                    });
                  }
                });
                
                // Initial population
                setTimeout(populateEquipmentSlots, 1000);
              </script>
              <div id="equipment-slots-container"></div>
            </div>
            <div class="equipment-tooltip" id="equipmentTooltip">
              <div class="title">Equipment Information</div>
              <div class="description">Hover over equipment to see details</div>
            </div>
          </div>
        </div>
        <div class="tab-content" id="items-tab">
          <div class="equipment-screen-content">
            <div class="equipment-list">
              <div id="equipment-items"></div>
              <span class="item-quantity"></span>
            </div>
            <div id="inventory-container"></div>
            <div class="equipment-tooltip" id="itemTooltip">
              <div class="title">Item Information</div>
              <div class="description">Hover over an item to see details</div>
            </div>
          </div>
        </div>
        <div class="tab-content" id="skills-tab">
          <div class="equipment-screen-content">
            <div class="equipment-list">
              <div id="skills-list"></div>
              <div id="skill-items"></div>
            </div>
            <div class="equipment-tooltip" id="skillTooltip">
              <div class="title">Skill Information</div>
              <div class="description">Click on a skill to see details</div>
            </div>
          </div>
        </div>
        <div class="tab-content" id="spells-tab">
          <div class="equipment-screen-content">
            <div class="equipment-list">
              <div id="spells-container">
                <p class="no-items">No spells learned yet</p>
              </div>
            </div>
            <div class="equipment-tooltip" id="spellTooltip">
              <div class="title">Spell Information</div>
              <div class="description">Click on a spell to see details</div>
            </div>
          </div>
        </div>
        <div class="tab-content" id="relics-tab">
          <div class="equipment-screen-content">
            <div class="equipment-list">
              <div id="relics-container"></div>
            </div>
            <div class="equipment-tooltip" id="relicTooltip">
              <div class="title">Relic Ability Information</div>
              <div class="description">Click on a relic ability to see details</div>
            </div>
          </div>
        </div>
      </div>
      <div id="inventoryScreen">
        <button class="close-button" onclick="toggleInventoryScreen()">×</button>
        <h2>Inventory</h2>
        <div id="inventoryList"></div>
      </div>
      <div id="introScreen" class="intro-screen">
        <div class="command-prompt">
          <div class="text-container"></div>
          <div class="cursor">_</div>
        </div>
      </div>
    </div>
    </div>

    <!-- Debug Mode Overlay -->
    <div id="debugOverlay" class="debug-overlay" style="display: none">
      <div>Debug Mode: <span id="debugStatus">OFF</span></div>
      <div>Selected Tile: <span id="selectedTileInfo">None</span></div>
      <div>Active Tiles: <span id="activeTileCount">0</span></div>
      <div>
        <button onclick="CollisionMapManager.resetMap();">Reset Map</button>
        <button onclick="console.log(CollisionMapManager.exportMap());">Export Map</button>
      </div>
    </div>
    
    <!-- Equipment Fix Tools - Hidden by default, toggle with F12 key -->
    <div id="equipmentFixTools" style="position: fixed; bottom: 10px; left: 10px; z-index: 9999; background: rgba(0,0,0,0.8); padding: 10px; border: 2px solid #00ffff; color: #ffffff; border-radius: 5px; display: none;">
      <h4 style="margin: 0 0 5px 0; color: #00ffff;">Equipment Fix Tools</h4>
      <button onclick="debugEquipment()" style="background: #333; color: #fff; border: 1px solid #00ffff; padding: 5px; margin: 2px; cursor: pointer;">Debug Equipment</button>
      <button onclick="fixEquipmentStructure()" style="background: #333; color: #fff; border: 1px solid #00ffff; padding: 5px; margin: 2px; cursor: pointer;">Fix Structure</button>
      <button onclick="unequipDumbbells()" style="background: #333; color: #fff; border: 1px solid #00ffff; padding: 5px; margin: 2px; cursor: pointer;">Unequip Dumbbells</button>
      <div style="margin-top: 5px; font-size: 10px; color: #aaa;">Press F12 to toggle this panel</div>
    </div>

    <style>
      .debug-overlay {
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: #00ff00;
        padding: 10px;
        border: 1px solid #00ff00;
        font-family: monospace;
        font-size: 12px;
        z-index: 1000;
      }
      .debug-overlay button {
        background: #003300;
        color: #00ff00;
        border: 1px solid #00ff00;
        padding: 5px;
        margin: 5px;
        cursor: pointer;
      }
      .debug-overlay button:hover {
        background: #004400;
      }
      .debug-tile {
        position: absolute;
        border: 1px solid rgba(255, 255, 255, 0.3);
        pointer-events: all;
        cursor: pointer;
        font-size: 10px;
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        text-shadow: 1px 1px 1px black;
      }
      
      @keyframes flash {
        0% {
          color: #00ff00;
          text-shadow: 0 0 10px #00ff00;
        }
        100% {
          color: #ffff00;
          text-shadow: 0 0 20px #ffff00;
        }
      }
    </style>

    <script>
      console.log("MEGA DEBUG: Main Game Script Block STARTED on Farcade - Test 1"); // Debug log to test script execution

      // Global functions for UI interaction
      function toggleCharacterScreen() {
        UIManager.toggleCharacterScreen();
      }

      // Global functions for UI interaction
      function toggleCharacterScreen() {
        UIManager.toggleCharacterScreen();
      }
      
      // DIRECT FIX FUNCTIONS - Added to fix equipment issues
      function debugEquipment() {
        const player = GameStateManager.state.player;
        if (!player) {
          alert("Player not found!");
          return;
        }
        
        // Show what's currently in the equipment
        let equipMsg = "Current equipment structure:\n";
        for (const [slot, item] of Object.entries(player.equipment)) {
          if (item) {
            equipMsg += `${slot}: ${item.name}\n`;
          } else {
            equipMsg += `${slot}: empty\n`;
          }
        }
        
        console.log(equipMsg);
        alert(equipMsg);
      }
      
      function fixEquipmentStructure() {
        const player = GameStateManager.state.player;
        if (!player) {
          alert("Player not found!");
          return;
        }
        
        // Fix the equipment structure
        if (!player.equipment) {
          player.equipment = {};
        }
        
        // Bidirectional synchronization between uppercase and lowercase slots
        // Keep both versions for compatibility with other code
        
        // Main hand slot sync
        if (player.equipment.main_hand && !player.equipment.MAIN_HAND) {
          player.equipment.MAIN_HAND = player.equipment.main_hand;
        } else if (!player.equipment.main_hand && player.equipment.MAIN_HAND) {
          player.equipment.main_hand = player.equipment.MAIN_HAND;
        }
        
        // Off hand slot sync
        if (player.equipment.off_hand && !player.equipment.OFF_HAND) {
          player.equipment.OFF_HAND = player.equipment.off_hand;
        } else if (!player.equipment.off_hand && player.equipment.OFF_HAND) {
          player.equipment.off_hand = player.equipment.OFF_HAND;
        }
        
        // Head slot sync
        if (player.equipment.head && !player.equipment.HEAD) {
          player.equipment.HEAD = player.equipment.head;
        } else if (!player.equipment.head && player.equipment.HEAD) {
          player.equipment.head = player.equipment.HEAD;
        }
        
        // Body slot sync
        if (player.equipment.body && !player.equipment.BODY) {
          player.equipment.BODY = player.equipment.body;
        } else if (!player.equipment.body && player.equipment.BODY) {
          player.equipment.body = player.equipment.BODY;
        }
        
        // Legs slot sync
        if (player.equipment.legs && !player.equipment.LEGS) {
          player.equipment.LEGS = player.equipment.legs;
        } else if (!player.equipment.legs && player.equipment.LEGS) {
          player.equipment.legs = player.equipment.LEGS;
        }
        
        // Feet slot sync
        if (player.equipment.feet && !player.equipment.FEET) {
          player.equipment.FEET = player.equipment.feet;
        } else if (!player.equipment.feet && player.equipment.FEET) {
          player.equipment.feet = player.equipment.FEET;
        }
        
        // Relic slot sync
        if (player.equipment.relic_1 && !player.equipment.RELIC_1) {
          player.equipment.RELIC_1 = player.equipment.relic_1;
        } else if (!player.equipment.relic_1 && player.equipment.RELIC_1) {
          player.equipment.relic_1 = player.equipment.RELIC_1;
        }
        
        if (player.equipment.relic_2 && !player.equipment.RELIC_2) {
          player.equipment.RELIC_2 = player.equipment.relic_2;
        } else if (!player.equipment.relic_2 && player.equipment.RELIC_2) {
          player.equipment.relic_2 = player.equipment.RELIC_2;
        }
        
        // Ensure all slots exist (both lowercase and uppercase)
        if (!player.equipment.main_hand) player.equipment.main_hand = null;
        if (!player.equipment.off_hand) player.equipment.off_hand = null;
        if (!player.equipment.head) player.equipment.head = null;
        if (!player.equipment.body) player.equipment.body = null;
        if (!player.equipment.legs) player.equipment.legs = null;
        if (!player.equipment.feet) player.equipment.feet = null;
        if (!player.equipment.relic_1) player.equipment.relic_1 = null;
        if (!player.equipment.relic_2) player.equipment.relic_2 = null;
        
        if (!player.equipment.MAIN_HAND) player.equipment.MAIN_HAND = null;
        if (!player.equipment.OFF_HAND) player.equipment.OFF_HAND = null;
        if (!player.equipment.HEAD) player.equipment.HEAD = null;
        if (!player.equipment.BODY) player.equipment.BODY = null;
        if (!player.equipment.LEGS) player.equipment.LEGS = null;
        if (!player.equipment.FEET) player.equipment.FEET = null;
        if (!player.equipment.RELIC_1) player.equipment.RELIC_1 = null;
        if (!player.equipment.RELIC_2) player.equipment.RELIC_2 = null;
        
        alert("Equipment structure fixed! Now try the Unequip Dumbbell function.");
      }
      
      // IMPROVED: Updated unequipDumbbells to use the main unequipItem function for consistency
      function unequipDumbbells() {
        console.log('[EQUIPMENT] Running improved unequipDumbbells function');
        const player = GameStateManager.state.player;
        if (!player) {
          alert("Player not found!");
          return;
        }
        
        // Find a slot containing a dumbbell - only need to find one since unequipItem handles both hands
        const weaponSlots = ['main_hand', 'off_hand', 'MAIN_HAND', 'OFF_HAND'];
        let found = false;
        
        // First try weapon slots which are most likely to contain dumbbells
        for (const slot of weaponSlots) {
          if (player.equipment[slot] && player.equipment[slot].name && 
              (player.equipment[slot].name.toLowerCase().includes('dumbbell') || 
               player.equipment[slot].name.toLowerCase().includes('dumbell'))) {
            console.log(`[EQUIPMENT] Found dumbbell in ${slot}, using unequipItem`);
            // Use the main unequipItem function which properly handles two-handed weapons
            unequipItem(slot);
            found = true;
            break;
          }
        }
        
        // If not found in primary slots, check all equipment slots
        if (!found) {
          for (const slot in player.equipment) {
            if (weaponSlots.includes(slot)) continue; // Skip already checked slots
            
            const item = player.equipment[slot];
            if (item && item.name && 
                (item.name.toLowerCase().includes('dumbbell') || 
                 item.name.toLowerCase().includes('dumbell'))) {
              console.log(`[EQUIPMENT] Found dumbbell in ${slot}, using unequipItem`);
              unequipItem(slot);
              found = true;
              break;
            }
          }
        }
        
        if (!found) {
          alert("No dumbbells found in equipment!");
        }
      }
      
      // Add the fix functions to the global scope
      window.debugEquipment = debugEquipment;
      window.fixEquipmentStructure = fixEquipmentStructure;
      window.unequipDumbbells = unequipDumbbells;
      
      // Add keyboard shortcut to toggle equipment fix tools (F12 key)
      document.addEventListener('keydown', function(event) {
        // Check if it's F12 key (key code 123)
        if (event.keyCode === 123) {
          const toolsPanel = document.getElementById('equipmentFixTools');
          if (toolsPanel) {
            // Toggle visibility
            toolsPanel.style.display = toolsPanel.style.display === 'none' ? 'block' : 'none';
            event.preventDefault(); // Prevent default F12 behavior (dev tools)
          }
        }
      });

      function toggleInventoryScreen() {
        UIManager.toggleInventoryScreen();
      }

      function toggleMessages() {
        const gameLog = document.getElementById("gameLog");
        if (!gameLog) return;

        if (gameLog.style.display === "none" || gameLog.style.display === "") {
          gameLog.style.display = "block";
          UIManager._isManuallyToggled = true;
        } else {
          gameLog.style.display = "none";
          UIManager._isManuallyToggled = false;
        }
      }

      // Function to setup tooltips for relic abilities and equipment items
      // CONSOLIDATED TOOLTIP SYSTEM: Unified approach for all tooltips
      window.setupTooltips = function() {
        console.log('[TOOLTIP] Setting up consolidated tooltip system');
        
        // HELPER: Ensure tooltip containers exist
        function ensureTooltipContainers() {
          // 1. Make sure all relic items have tooltip containers
          const allRelicItems = document.querySelectorAll('.relic-item');
          console.log(`[TOOLTIP] Ensuring tooltips for ${allRelicItems.length} relic items`);
          
          allRelicItems.forEach(relicItem => {
            // Make sure each relic has a tooltip container
            let relicTooltip = relicItem.querySelector('.relic-tooltip');
            if (!relicTooltip) {
              relicTooltip = document.createElement('div');
              relicTooltip.className = 'relic-tooltip';
              relicItem.appendChild(relicTooltip);
              
              // Style the tooltip properly
              relicTooltip.style.position = 'absolute';
              relicTooltip.style.top = '100%';
              relicTooltip.style.left = '0';
              relicTooltip.style.width = '100%';
              relicTooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
              relicTooltip.style.border = '1px solid #00ffff';
              relicTooltip.style.color = '#00ff00';
              relicTooltip.style.padding = '4px 8px';
              relicTooltip.style.marginTop = '5px';
              relicTooltip.style.boxSizing = 'border-box';
              relicTooltip.style.zIndex = '1000';
              relicTooltip.style.fontSize = '11px';
              relicTooltip.style.display = 'none';
              relicTooltip.style.height = '62px';
              relicTooltip.style.minHeight = '62px';
              relicTooltip.style.maxHeight = '62px';
              relicTooltip.style.whiteSpace = 'normal !important';
              relicTooltip.style.overflow = 'visible !important';
              relicTooltip.style.textOverflow = 'clip !important';
              relicTooltip.style.lineHeight = '14px';
              console.log('[TOOLTIP] Created missing tooltip container for relic');
            }
          });
          
          // 2. Ensure the main tooltip divs exist and are properly styled
          const tooltipIds = ['relicTooltip', 'equipmentTooltip', 'itemTooltip', 'skillTooltip', 'spellTooltip'];
          tooltipIds.forEach(id => {
            const tooltip = document.getElementById(id);
            if (tooltip) {
              // Make sure it has the expected structure
              if (!tooltip.querySelector('.title')) {
                const title = document.createElement('div');
                title.className = 'title';
                title.textContent = id.replace('Tooltip', '') + ' Information';
                tooltip.appendChild(title);
              }
              if (!tooltip.querySelector('.description')) {
                const description = document.createElement('div');
                description.className = 'description';
                description.textContent = 'Hover over an item to see details';
                tooltip.appendChild(description);
              }
            }
          });
        }
        
        // HELPER: Bind tooltip event handlers to all relevant elements
        function bindTooltipEventHandlers() {
          // Use a comprehensive selector to catch all tooltippable elements
          const tooltipElements = document.querySelectorAll(
            '.ability-item, [data-ability-id], .relic-grid > div, ' + 
            '.relic-item div[class*="ability"], .equipment-item, ' +
            '.inventory-item, .skill-item, .spell-item'
          );
          
          console.log(`[TOOLTIP] Binding tooltip handlers to ${tooltipElements.length} elements`);
          
          tooltipElements.forEach(element => {
            // Remove existing event listeners by cloning and replacing
            const newElement = element.cloneNode(true);
            if (element.parentNode) {
              element.parentNode.replaceChild(newElement, element);
            }
            
            // Determine element type and extract its name/ID
            const abilityId = newElement.getAttribute('data-ability-id');
            const abilityName = newElement.querySelector('.ability-name')?.textContent.trim();
            const equipmentSlot = newElement.getAttribute('data-slot');
            const itemId = newElement.getAttribute('data-item-id');
            
            // Add appropriate mouseover handler based on element type
            if (abilityId || abilityName) {
              // This is a relic ability element
              newElement.addEventListener('mouseenter', function() {
                const description = window.getAbilityDescription(abilityName || abilityId);
                const isUnlocked = !newElement.classList.contains('locked');
                
                // Update both the main tooltip and any local tooltips
                const relicTooltip = document.getElementById('relicTooltip');
                if (relicTooltip) {
                  relicTooltip.querySelector('.title').textContent = 'Relic Ability';
                  relicTooltip.querySelector('.description').textContent = description;
                }
                
                // Also find any parent relic-item and update its tooltip
                const relicItem = newElement.closest('.relic-item');
                if (relicItem) {
                  const localTooltip = relicItem.querySelector('.relic-tooltip');
                  if (localTooltip) {
                    localTooltip.textContent = description;
                    localTooltip.style.display = 'block';
                  }
                }
                
                // Call any existing tooltip functions as fallback
                if (typeof showAbilityTooltip === 'function') {
                  showAbilityTooltip(newElement, abilityName || abilityId, description, isUnlocked);
                }
              });
              
              newElement.addEventListener('mouseleave', function() {
                // Hide any local tooltips
                const relicItem = newElement.closest('.relic-item');
                if (relicItem) {
                  const localTooltip = relicItem.querySelector('.relic-tooltip');
                  if (localTooltip) {
                    localTooltip.style.display = 'none';
                  }
                }
                
                // Call any existing hide functions
                if (typeof hideAbilityTooltip === 'function') {
                  hideAbilityTooltip();
                }
              });
            } else if (equipmentSlot) {
              // This is an equipment slot element
              newElement.addEventListener('mouseenter', function() {
                // Find equipment info and display it
                const player = GameStateManager?.state?.player;
                if (player?.equipment && player.equipment[equipmentSlot]) {
                  const item = player.equipment[equipmentSlot];
                  const equipmentTooltip = document.getElementById('equipmentTooltip');
                  if (equipmentTooltip) {
                    equipmentTooltip.querySelector('.title').textContent = item.name || 'Equipment';
                    equipmentTooltip.querySelector('.description').textContent = 
                      `Type: ${item.type || 'Unknown'} | ` + 
                      `Stats: ${JSON.stringify(item.stats || {})}`;
                  }
                }
                
                // Call existing tooltip function if available
                if (typeof showEquipmentInfo === 'function') {
                  showEquipmentInfo(equipmentSlot);
                }
              });
              
              newElement.addEventListener('mouseleave', function() {
                if (typeof hideEquipmentInfo === 'function') {
                  hideEquipmentInfo();
                }
              });
            }
            // Add more cases for other element types as needed
          });
        }
        
        // EXECUTE HELPERS: Run the functions in sequence
        ensureTooltipContainers();
        bindTooltipEventHandlers();
        
        // Also run addTooltipsToGridItems for backward compatibility
        if (typeof addTooltipsToGridItems === 'function') {
          console.log('[TOOLTIP] Running addTooltipsToGridItems for compatibility');
          addTooltipsToGridItems();
        }
        
        console.log('[TOOLTIP] Consolidated tooltip system setup complete');
      };

      // Function to toggle relic equip/unequip status
      function toggleRelicEquip(relicKey) {
        const player = GameStateManager.state.player;
        if (!player || !player.relics || !player.relics[relicKey]) return;
        
        // Check if relic is currently equipped
        const isEquipped = player.appliedRelicBonuses && player.appliedRelicBonuses[relicKey] === true;
        
        console.log(`Toggling relic: ${relicKey}, currently equipped: ${isEquipped}`);
        
        if (isEquipped) {
          // Unequip the relic
          if (window.RELIC_SYSTEM) {
            // First remove from equipment slots
            if (player.equipment.relic_1 && player.equipment.relic_1.relicId === relicKey) {
              player.equipment.relic_1 = null;
              console.log(`Removed ${relicKey} from relic_1 slot`);
            } else if (player.equipment.relic_2 && player.equipment.relic_2.relicId === relicKey) {
              player.equipment.relic_2 = null;
              console.log(`Removed ${relicKey} from relic_2 slot`);
            }
            
            // Remove stat bonuses
            if (player.appliedRelicBonuses) {
              const relic = player.relics[relicKey];
              if (relic) {
                // Remove stat bonuses
                player.stats.strength -= relic.level;
                player.stats.dexterity -= relic.level;
                player.stats.intelligence -= relic.level;
                player.stats.vitality -= relic.level;
                player.stats.fortune -= relic.level;
                player.stats.charisma -= relic.level;
                
                // Mark as not applied
                player.appliedRelicBonuses[relicKey] = false;
                
                console.log(`Manually unequipped relic: ${relicKey}, removed ${relic.level} from all stats`);
                
                // Recalculate derived stats
                if (typeof LEVELING_SYSTEM !== 'undefined' && typeof LEVELING_SYSTEM.updateCharacterStats === 'function') {
                  LEVELING_SYSTEM.updateCharacterStats(player);
                }
              }
            }
          }
        } else {
          // Equip the relic
          if (window.RELIC_SYSTEM && typeof window.RELIC_SYSTEM.applyRelicBonuses === 'function') {
            window.RELIC_SYSTEM.applyRelicBonuses(player, relicKey);
            console.log(`Equipped relic: ${relicKey}`);
          }
        }
        
        // Update UI
        if (typeof UIManager !== 'undefined' && UIManager.updateCharacterScreen) {
          UIManager.updateCharacterScreen();
        }
        
        // Refresh tooltips after toggling relic state
        // This ensures tooltip functionality continues to work after DOM changes
        console.log('[TOOLTIP] Refreshing tooltips after relic toggle');
        // Use the global reference to ensure it's found
        setTimeout(function() {
          console.log('[TOOLTIP] Running delayed setupTooltips after toggle');
          if (window.setupTooltips) {
            window.setupTooltips();
          } else {
            console.error('[TOOLTIP] setupTooltips function not found on window object!');
          }
        }, 100); // Allow time for DOM to update
      }

      // Scene Definitions
      const SCENES = {
        ARCADE1: {
          id: "arcade1",
          name: "Arcade 1",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/arcade1-lEVXj4ZKpdccY28mxCeLWXn5qNWh4o.png?YRAf",
          map: null,
          transitions: {
            arcade2: { scene: "arcade2", x: 21, y: 2, targetSpawnId: "from_arcade1" },
            arcade3: { scene: "arcade3", x: 18, y: 20, targetSpawnId: "from_arcade1" },
          },
          spawnPoints: {
            from_arcade2: { x: 21, y: 4, direction: "up" },
            from_arcade3: { x: 2, y: 19, direction: "right" },
          },
          transitionTiles: {
            arcade2: [
              [21, 2],
              [22, 2],
            ],
            arcade3: [
              [0, 10],
              [0, 11],
              [0, 12],
              [0, 18],
              [0, 19],
              [0, 20],
              [0, 21],
            ],
          },
        },
        ARCADE2: {
          id: "arcade2",
          name: "Arcade 2",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/arcade2-9NAGoIh3IQIHdKubMphassnhuM2pTC.png?dnh7",
          map: {},
          transitions: {
            arcade1: { scene: "arcade1", x: 21, y: 4, targetSpawnId: "from_arcade2" },
          },
          spawnPoints: {
            from_arcade1: { x: 10, y: 19, direction: "up" },
          },
          transitionTiles: {
            arcade1: [
              [6, 20],
              [7, 20],
              [8, 20],
              [9, 20],
              [10, 20],
              [11, 20],
              [12, 20],
              [13, 20],
            ],
          },
          collisionMap: {
            "0,0": true,
            "1,0": true,
            "2,0": true,
            "3,0": true,
            "0,1": true,
            "1,1": true,
            "2,1": true,
            "3,1": true,
            "0,2": true,
            "1,2": true,
            "2,2": true,
            "3,2": true,
            "20,0": true,
            "21,0": true,
            "22,0": true,
            "23,0": true,
            "20,1": true,
            "21,1": true,
            "22,1": true,
            "23,1": true,
          },
        },
        ARCADE3: {
          id: "arcade3",
          name: "Arcade 3",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/arcade3-NiHI50I9tO7A1EtWHBom92Mgv5Z65a.png?bZyP",
          map: {},
          transitions: {
            arcade1: { scene: "arcade1", x: 1, y: 19, targetSpawnId: "from_arcade3" },
          },
          spawnPoints: {
            from_arcade1: { x: 18, y: 20, direction: "right" },
          },
          transitionTiles: {
            arcade1: [
              [20, 19],
              [20, 20],
            ],
          },
          collisionMap: {
            "0,0": true,
            "1,0": true,
            "2,0": true,
            "3,0": true,
            "0,1": true,
            "1,1": true,
            "2,1": true,
            "3,1": true,
            "0,2": true,
            "1,2": true,
            "2,2": true,
            "3,2": true,
            "28,0": true,
            "29,0": true,
            "30,0": true,
            "31,0": true,
            "28,1": true,
            "29,1": true,
            "30,1": true,
            "31,1": true,
            "28,2": true,
            "29,2": true,
            "30,2": true,
            "31,2": true,
          },
        },
      };

      // Game Constants
      const TILE_SIZE = 64;
      const GRID_SIZE = 48;
      const MOVEMENT_DELAY = 100; // Movement delay in milliseconds for smooth but controlled movement
      const PLAYER_SCALE = 1.5;
      const MAP_WIDTH = 50; // Default map width
      const MAP_HEIGHT = 40; // Default map height

      // Debug Mode and Collision System
      const DEBUG = {
        enabled: false,
        selectedTile: null,
        collisionMap: new Map(), // Format: 'x,y' -> boolean (true = collision)
        colors: {
          active: "rgba(255, 0, 0, 0.3)",
          inactive: "rgba(0, 255, 0, 0.3)",
          selected: "rgba(255, 255, 0, 0.5)",
        },
      };

      // Initialize collision map on page load
      window.addEventListener("load", () => {
        // Initialize the audio system
        AudioManager.init();

        // Only initialize the default map if we don't have a stored map already
        if (
          GameStateManager.state.currentScene === "arcade1" &&
          (!GameStateManager.storedCollisionMaps ||
            !GameStateManager.storedCollisionMaps["arcade1"] ||
            Object.keys(GameStateManager.storedCollisionMaps["arcade1"]).length === 0)
        ) {
          console.log("Loading default arcade1 collision map");
          const arcade1CollisionMap = {
            "0,0": true,
            "0,1": true,
            "0,2": true,
            "0,3": true,
            "0,4": true,
            "0,5": true,
            "0,6": true,
            "0,7": true,
            "0,8": true,
            "0,9": true,
            "1,0": true,
            "1,1": true,
            "1,2": true,
            "1,3": true,
            "1,4": true,
            "1,5": true,
            "1,6": true,
            "1,7": true,
            "1,8": true,
            "1,9": true,
            "2,0": true,
            "2,1": true,
            "2,2": true,
            "2,3": true,
            "2,4": true,
            "2,5": true,
            "2,6": true,
            "2,7": true,
            "2,8": true,
            "3,0": true,
            "3,1": true,
            "3,2": true,
            "3,3": true,
            "3,4": true,
            "3,5": true,
            "3,6": true,
            "3,7": true,
            "3,8": true,
            "4,0": true,
            "4,1": true,
            "5,0": true,
            "5,1": true,
            "6,0": true,
            "6,1": true,
            "6,2": true,
            "6,3": true,
            "6,4": true,
            "6,5": true,
            "7,0": true,
            "7,1": true,
            "7,2": true,
            "7,3": true,
            "7,4": true,
            "7,5": true,
            "8,0": true,
            "8,1": true,
            "8,2": true,
            "8,3": true,
            "8,4": true,
            "8,5": true,
            "8,10": true,
            "9,0": true,
            "9,1": true,
            "9,2": true,
            "9,3": true,
            "9,4": true,
            "9,5": true,
            "9,7": true,
            "9,8": true,
            "9,9": true,
            "9,10": true,
            "10,0": true,
            "10,1": true,
            "10,2": true,
            "10,3": true,
            "10,4": true,
            "10,7": true,
            "10,8": true,
            "10,9": true,
            "10,10": true,
            "11,0": true,
            "11,1": true,
            "11,2": true,
            "11,3": true,
            "11,4": true,
            "11,6": true,
            "11,7": true,
            "11,8": true,
            "11,9": true,
            "11,10": true,
            "12,0": true,
            "12,1": true,
            "12,2": true,
            "12,3": true,
            "12,4": true,
            "12,7": true,
            "12,8": true,
            "12,9": true,
            "12,10": true,
            "13,0": true,
            "13,1": true,
            "13,2": true,
            "13,3": true,
            "13,4": true,
            "13,7": true,
            "13,8": true,
            "13,9": true,
            "13,10": true,
            "14,0": true,
            "14,1": true,
            "14,2": true,
            "14,3": true,
            "14,4": true,
            "14,5": true,
            "14,8": true,
            "14,9": true,
            "14,10": true,
            "15,0": true,
            "15,1": true,
            "15,2": true,
            "15,3": true,
            "15,4": true,
            "15,5": true,
            "15,8": true,
            "16,0": true,
            "16,1": true,
            "16,2": true,
            "16,3": true,
            "16,4": true,
            "16,5": true,
            "17,0": true,
            "17,1": true,
            "17,2": true,
            "17,3": true,
            "17,4": true,
            "18,0": true,
            "18,1": true,
            "18,2": true,
            "18,3": true,
            "18,4": true,
            "19,0": true,
            "19,1": true,
            "19,2": true,
            "19,3": true,
            "19,4": true,
            "20,0": true,
            "20,1": true,
            "21,0": true,
            "21,1": true,
            "22,0": true,
            "22,1": true,
            "22,7": true,
            "22,8": true,
            "22,9": true,
            "22,10": true,
            "23,0": true,
            "23,1": true,
            "23,2": true,
            "23,3": true,
            "23,4": true,
            "23,5": true,
            "23,6": true,
            "23,7": true,
            "23,8": true,
            "23,9": true,
            "23,10": true,
            "24,0": true,
            "24,1": true,
            "24,2": true,
            "24,3": true,
            "24,4": true,
            "24,5": true,
            "24,6": true,
            "24,7": true,
            "24,8": true,
            "24,9": true,
            "24,10": true,
            "25,0": true,
            "25,1": true,
            "25,2": true,
            "25,3": true,
            "25,4": true,
            "25,5": true,
            "25,6": true,
            "25,7": true,
            "25,8": true,
            "25,9": true,
            "25,10": true,
            "26,0": true,
            "26,1": true,
            "26,2": true,
            "26,3": true,
            "26,4": true,
            "26,5": true,
            "26,6": true,
            "26,7": true,
            "26,8": true,
            "26,9": true,
            "26,10": true,
            "27,0": true,
            "27,1": true,
            "27,2": true,
            "27,3": true,
            "27,4": true,
            "27,5": true,
            "27,6": true,
            "27,7": true,
            "27,8": true,
            "27,9": true,
            "27,10": true,
            "28,0": true,
            "28,1": true,
            "28,2": true,
            "28,3": true,
            "28,4": true,
            "28,5": true,
            "28,6": true,
            "28,7": true,
            "28,8": true,
            "28,9": true,
            "28,10": true,
            "29,0": true,
            "29,1": true,
            "29,2": true,
            "29,3": true,
            "29,4": true,
            "29,5": true,
            "29,6": true,
            "29,7": true,
            "29,8": true,
            "29,9": true,
            "29,10": true,
            "30,0": true,
            "30,1": true,
            "30,2": true,
            "30,3": true,
            "30,4": true,
            "30,5": true,
            "30,6": true,
            "30,7": true,
            "30,8": true,
            "30,9": true,
            "30,10": true,
            "31,0": true,
            "31,1": true,
            "31,2": true,
            "31,3": true,
            "31,4": true,
            "31,5": true,
            "31,6": true,
            "31,7": true,
            "31,8": true,
            "31,9": true,
            "31,10": true,
            "28,11": true,
            "28,12": true,
            "28,13": true,
            "28,14": true,
            "28,15": true,
            "28,16": true,
            "28,17": true,
            "29,11": true,
            "29,12": true,
            "29,13": true,
            "29,14": true,
            "29,15": true,
            "29,16": true,
            "29,17": true,
            "30,11": true,
            "30,12": true,
            "30,13": true,
            "30,14": true,
            "30,15": true,
            "30,16": true,
            "30,17": true,
            "31,11": true,
            "31,12": true,
            "31,13": true,
            "31,14": true,
            "31,15": true,
            "31,16": true,
            "31,17": true,
            "24,11": true,
            "24,12": true,
            "24,13": true,
            "24,14": true,
            "24,15": true,
            "20,11": true,
            "20,12": true,
            "20,13": true,
            "20,14": true,
            "20,15": true,
            "21,11": true,
            "21,12": true,
            "21,13": true,
            "21,14": true,
            "21,15": true,
            "22,11": true,
            "22,12": true,
            "22,13": true,
            "22,14": true,
            "22,15": true,
            "8,11": true,
            "9,11": true,
            "10,11": true,
            "11,11": true,
            "3,12": true,
            "3,13": true,
            "3,14": true,
            "3,15": true,
            "4,12": true,
            "4,13": true,
            "4,14": true,
            "4,15": true,
            "5,12": true,
            "5,13": true,
            "5,14": true,
            "5,15": true,
            "0,13": true,
            "0,14": true,
            "0,15": true,
            "0,16": true,
            "0,17": true,
            "1,13": true,
            "1,14": true,
            "1,15": true,
            "1,16": true,
            "1,17": true,
            "2,13": true,
            "2,14": true,
            "2,15": true,
            "2,16": true,
            "2,17": true,
            "5,20": true,
            "5,21": true,
            "6,20": true,
            "6,21": true,
            "7,20": true,
            "7,21": true,
            "8,20": true,
            "8,21": true,
            "9,20": true,
            "9,21": true,
            "10,20": true,
            "10,21": true,
            "11,20": true,
            "11,21": true,
            "12,20": true,
            "12,21": true,
            "13,20": true,
            "13,21": true,
            "14,20": true,
            "14,21": true,
            "15,20": true,
            "15,21": true,
            "16,20": true,
            "16,21": true,
            "17,20": true,
            "17,21": true,
            "7,19": true,
            "8,19": true,
            "9,19": true,
            "10,19": true,
            "11,19": true,
            "12,19": true,
            "13,19": true,
            "14,19": true,
            "15,19": true,
            "9,18": true,
            "10,18": true,
            "11,18": true,
            "12,18": true,
            "13,18": true,
            "10,17": true,
            "11,17": true,
            "12,17": true,
            "11,16": true,
            "25,11": true,
            "25,12": true,
            "25,13": true,
            "25,14": true,
            "25,15": true,
            "26,11": true,
            "26,12": true,
            "26,13": true,
            "27,11": true,
            "27,12": true,
            "27,13": true,
          };
          CollisionMapManager.importMap(JSON.stringify(arcade1CollisionMap));
          console.log("Initial collision map loaded, size:", DEBUG.collisionMap.size);
        } else {
          console.log("Not loading default map - using stored map instead");
        }
      });

      const CollisionMapManager = {
        init() {
          // Initialize collision map for current scene
          this.resetMap();
        },

        toggleTile(x, y) {
          const key = `${x},${y}`;
          const currentState = DEBUG.collisionMap.get(key) || false;
          DEBUG.collisionMap.set(key, !currentState);
          console.log(`Toggled tile at (${x},${y}) to ${!currentState}`);
          this.updateDebugInfo();
        },

        resetMap() {
          // Don't reset if we just restored a map during scene transition
          if (GameStateManager.mapJustRestored) {
            console.log("WARNING: Preventing map reset because map was just restored during scene transition");
            this.updateDebugInfo();
            return;
          }

          console.log("Resetting collision map (clearing all tiles)");
          DEBUG.collisionMap.clear();
          this.updateDebugInfo();
        },

        exportMap() {
          // Return the collision data as a JavaScript object, not as a JSON string
          const collisionData = {};

          // Check if map is actually empty when it shouldn't be (for debugging)
          if (DEBUG.collisionMap.size === 0 && GameStateManager.mapJustRestored) {
            console.error("ERROR: Map should not be empty after a scene transition - collision map restore failed!");

            // Try to use the stored map directly if available
            const currentScene = GameStateManager.state.currentScene;
            if (GameStateManager.storedCollisionMaps && GameStateManager.storedCollisionMaps[currentScene]) {
              console.log("Attempting recovery from stored map...");
              const storedMap = GameStateManager.storedCollisionMaps[currentScene];
              this.importMap(storedMap);
            }
          }

          // Export the current map data
          for (const [key, value] of DEBUG.collisionMap) {
            if (value) {
              // Only include active collision tiles
              collisionData[key] = value;
            }
          }

          console.log(`DEBUG: Exported map with ${Object.keys(collisionData).length} tiles`);
          console.log("DEBUG: Current map size from Map object:", DEBUG.collisionMap.size);

          return collisionData;
        },

        importMap(mapData) {
          try {
            // Handle both JSON strings and objects
            const data = typeof mapData === "string" ? JSON.parse(mapData) : mapData;
            const tileCount = Object.keys(data).length;
            console.log(`DEBUG: Importing collision map with ${tileCount} tiles`);

            // Clear existing map before importing new one
            DEBUG.collisionMap.clear();

            // Import all tiles from the data
            for (const [key, value] of Object.entries(data)) {
              DEBUG.collisionMap.set(key, value);
            }

            // Double-check the map was loaded correctly
            console.log(`DEBUG: Map now has ${DEBUG.collisionMap.size} tiles`);
            this.updateDebugInfo();
          } catch (e) {
            console.error("Failed to import collision map:", e);
          }
        },

        updateDebugInfo() {
          const debugStatus = document.getElementById("debugStatus");
          const selectedTileInfo = document.getElementById("selectedTileInfo");
          const activeTileCount = document.getElementById("activeTileCount");

          if (debugStatus) debugStatus.textContent = DEBUG.enabled ? "ON" : "OFF";
          if (selectedTileInfo && DEBUG.selectedTile) {
            selectedTileInfo.textContent = `(${DEBUG.selectedTile.x}, ${DEBUG.selectedTile.y})`;
          }
          if (activeTileCount) {
            let count = 0;
            for (const value of DEBUG.collisionMap.values()) {
              if (value) count++;
            }
            activeTileCount.textContent = count;
          }
        },
      };

      // Audio System
      const AudioManager = {
        // Store references to all audio elements
        audioElements: {},
        muted: false,
        initialized: false,
        context: null,
        readyToPlay: false, // Flag to prevent playing before initialization

        // Sound sources for direct URL playback
        sounds: {
          // Game-appropriate sound effects using reliable sources
          click: "https://assets.mixkit.co/sfx/preview/mixkit-tech-click-1140.mp3", // Sci-fi computer click
          attack: "https://assets.mixkit.co/sfx/preview/mixkit-martial-arts-fast-punch-2047.mp3", // Grunt with strain
          damage: "https://assets.mixkit.co/sfx/preview/mixkit-man-in-pain-2197.mp3", // Pained grunt
          victory: "https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3", // Victory sound
          powerup: "https://assets.mixkit.co/sfx/preview/mixkit-quick-jump-arcade-game-239.mp3", // Power strike sound
          bgmusic: "https://assets.mixkit.co/sfx/preview/mixkit-tech-house-vibes-130.mp3", // Fast-paced EDM
          combatmusic: "https://assets.mixkit.co/sfx/preview/mixkit-electronic-retro-block-hit-2185.mp3", // Combat EDM
        },

        // Preloaded audio objects
        preloadedSounds: {},

        // Background music audio element
        bgMusic: null,

        // Flag to track if audio was explicitly initialized by user
        userInitiatedAudio: false,

        // Initialize the audio system with support for modern browsers
        init(userInitiated = false) {
          try {
            console.log("[Audio] Initializing audio system", userInitiated ? "(user initiated)" : "");

            if (this.initialized && !userInitiated) {
              console.log("[Audio] Audio system already initialized");
              return true;
            }

            // If this is user initiated, set the flag
            if (userInitiated) {
              this.userInitiatedAudio = true;
              console.log("[Audio] Audio initialization was explicitly requested by user");
            }

            // Create an audio context if we don't have one
            if (!this.context) {
              try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.context = new AudioContext();
                console.log("[Audio] Created new AudioContext");
              } catch (e) {
                console.error("[Audio] Could not create AudioContext:", e);
              }
            }

            // Resume context if suspended and user initiated
            if (this.context && this.context.state === "suspended" && userInitiated) {
              this.context
                .resume()
                .then(() => {
                  console.log("[Audio] Successfully resumed AudioContext");
                })
                .catch((e) => {
                  console.error("[Audio] Failed to resume AudioContext:", e);
                });
            }

            // Create a fresh background music element
            this.bgMusic = new Audio();
            this.bgMusic.src = this.sounds.bgmusic;
            this.bgMusic.id = "gameBgMusic";
            this.bgMusic.loop = true;
            this.bgMusic.volume = 0.3;
            this.bgMusic.preload = "auto";
            document.body.appendChild(this.bgMusic);

            // Preload sound effects
            this.preloadSounds();

            // Check if game should start muted
            if (localStorage.getItem("gcaMuted") === "true") {
              this.muted = true;
            }

            // If user initiated, safely set ready to play flag
            if (userInitiated) {
              this.readyToPlay = true;
              console.log("[Audio] Audio system is ready to play sounds");

              // Start background music (if not muted)
              if (!this.muted) {
                this.playBackgroundMusic();
              }
            }

            this.initialized = true;
            return true;
          } catch (e) {
            console.error("[Audio] Error initializing audio:", e);
            this.readyToPlay = false;
            return false;
          }
        },

        // Preload all sounds defined in the sounds object
        preloadSounds() {
          console.log("[Audio] Preloading sound effects");

          // Create Audio objects for each sound URL except bgmusic (handled separately)
          for (const [name, url] of Object.entries(this.sounds)) {
            if (name === "bgmusic") continue; // Skip bgmusic, handled separately

            try {
              // Create a new audio element for each sound
              const audio = document.createElement("audio");
              audio.src = url;
              audio.volume = 0.6;
              audio.preload = "auto";

              // Add to document to ensure proper loading
              audio.style.display = "none";
              document.body.appendChild(audio);

              // Store reference
              this.preloadedSounds[name] = audio;
              console.log(`[Audio] Preloaded sound: ${name} from ${url}`);

              // Force loading
              audio.load();

              // Test playback to ensure browser has loaded it
              const testPlay = audio.play();
              if (testPlay) {
                testPlay
                  .then(() => {
                    // Successfully loaded and started playing
                    setTimeout(() => {
                      audio.pause();
                      audio.currentTime = 0;
                      console.log(`[Audio] Successfully tested ${name}`);
                    }, 10); // Just play for a moment to confirm it works
                  })
                  .catch((e) => {
                    // This is actually expected since browsers may block autoplay
                    console.log(`[Audio] Expected playback restriction for ${name}:`, e);
                  });
              }
            } catch (e) {
              console.error(`[Audio] Error preloading sound: ${name}`, e);
            }
          }
        },

        // Play a sound by name - simplified and more reliable approach
        play(soundName) {
          console.log("[Audio] Attempting to play sound:", soundName);

          // Don't play if muted or not ready
          if (this.muted) {
            console.log("[Audio] Audio is muted, not playing sound");
            return;
          }

          if (!this.readyToPlay) {
            console.log(`[Audio] Audio not ready yet, can't play ${soundName}`);
            return;
          }

          // Don't try to play sounds if audio wasn't initiated by user
          if (!this.userInitiatedAudio) {
            console.log("[Audio] Cannot play sounds without user interaction");
            return;
          }

          // Get the URL for this sound
          const soundUrl = this.sounds[soundName];
          if (!soundUrl) {
            console.error(`[Audio] No URL found for sound: ${soundName}`);
            return;
          }

          // Check for previously created sound
          if (this.preloadedSounds[soundName]) {
            try {
              const sound = this.preloadedSounds[soundName];
              sound.currentTime = 0;
              sound.volume = 0.6;

              // Play the sound
              const playPromise = sound.play();
              if (playPromise) {
                playPromise.catch((e) => {
                  console.log(`[Audio] Error playing preloaded sound ${soundName}, creating new:`, e);
                  this.createAndPlaySound(soundName, soundUrl);
                });
              }
              return;
            } catch (e) {
              console.error(`[Audio] Error with preloaded sound ${soundName}:`, e);
            }
          }

          // If we get here, we need to create a new sound
          this.createAndPlaySound(soundName, soundUrl);
        },

        // Helper method to create and play a sound on demand
        createAndPlaySound(soundName, url) {
          try {
            // Create a new Audio element for this sound
            const sound = new Audio(url);
            sound.volume = 0.6;

            // Play the sound
            const playPromise = sound.play();
            if (playPromise) {
              playPromise
                .then(() => {
                  // Store in preloaded sounds for future use
                  this.preloadedSounds[soundName] = sound;
                })
                .catch((e) => {
                  console.error(`[Audio] Failed to play new sound ${soundName}:`, e);
                });
            }
          } catch (e) {
            console.error(`[Audio] Error creating sound ${soundName}:`, e);
          }
        },

        // Play a sound directly from URL
        playFromURL(soundName) {
          const soundUrl = this.sounds[soundName];
          if (!soundUrl) {
            console.error(`[Audio] No URL found for sound: ${soundName}`);
            return;
          }

          // Try playing with Web Audio API if available
          if (this.context && this.context.state === "running") {
            fetch(soundUrl)
              .then((response) => response.arrayBuffer())
              .then((arrayBuffer) => this.context.decodeAudioData(arrayBuffer))
              .then((audioBuffer) => {
                const source = this.context.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.context.destination);
                source.start(0);
                console.log(`[Audio] Playing ${soundName} with Web Audio API`);
              })
              .catch((error) => {
                console.error(`[Audio] Error playing ${soundName} with Web Audio API:`, error);
                this.playWithAudioElement(soundUrl);
              });
          } else {
            // Fallback to standard Audio element
            this.playWithAudioElement(soundUrl);
          }
        },

        // Fallback method using standard Audio element
        playWithAudioElement(soundUrl) {
          try {
            const audio = new Audio(soundUrl);
            audio.volume = this.muted ? 0 : 0.7;
            const playPromise = audio.play();

            if (playPromise !== undefined) {
              playPromise.catch((e) => {
                console.error("[Audio] Error playing audio with Audio element:", e);
              });
            }
            console.log("[Audio] Playing with standard Audio element");
          } catch (e) {
            console.error("[Audio] Critical error playing audio:", e);
          }
        },

        // Start or resume background music
        playBackgroundMusic() {
          // Don't play if muted or not ready
          if (this.muted) {
            console.log("[Audio] Not playing background music because audio is muted");
            return;
          }

          if (!this.readyToPlay) {
            console.log("[Audio] Cannot play background music until audio is ready");
            return;
          }

          if (!this.bgMusic) {
            console.log("[Audio] Creating a new background music element");
            // Create a new audio element for background music
            this.bgMusic = new Audio();
            this.bgMusic.src = this.sounds.bgmusic;
            this.bgMusic.id = "gameBgMusic";
            this.bgMusic.loop = true;
            this.bgMusic.volume = 0.3;
            this.bgMusic.preload = "auto";
            document.body.appendChild(this.bgMusic);
          }

          // Try playing with a direct audio element approach
          try {
            console.log("[Audio] Starting background music");

            // Make sure it's set up properly
            this.bgMusic.loop = true;
            this.bgMusic.volume = this.muted ? 0 : 0.3;

            // Force load the audio
            this.bgMusic.load();

            // Play the music with a user gesture
            if (this.userInitiatedAudio) {
              const playPromise = this.bgMusic.play();

              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    console.log("[Audio] Background music started successfully");
                  })
                  .catch((e) => {
                    console.log("[Audio] Error playing background music:", e);

                    // As a fallback, create a completely new audio element and try again
                    this.createAndPlayFallbackMusic();
                  });
              }
            } else {
              console.log("[Audio] Cannot play background music without user interaction");
            }
          } catch (e) {
            console.error("[Audio] Error playing background music:", e);
            this.createAndPlayFallbackMusic();
          }
        },

        // Fallback method for background music
        createAndPlayFallbackMusic() {
          try {
            console.log("[Audio] Trying fallback background music method");

            // Create a completely new audio element
            const fallbackMusic = new Audio(this.sounds.bgmusic);
            fallbackMusic.loop = true;
            fallbackMusic.volume = 0.3;
            fallbackMusic.id = "fallbackBgMusic";

            // Try to play it
            const playPromise = fallbackMusic.play();
            if (playPromise) {
              playPromise
                .then(() => {
                  console.log("[Audio] Fallback background music started");
                  // Store reference to the working element
                  this.bgMusic = fallbackMusic;
                })
                .catch((e) => {
                  console.error("[Audio] Even fallback music failed:", e);
                });
            }
          } catch (e) {
            console.error("[Audio] Critical error with fallback music:", e);
          }
        },

        // Play combat music during battles
        playCombatMusic() {
          // Don't play if muted or not ready
          if (this.muted) {
            console.log("[Audio] Not playing combat music because audio is muted");
            return;
          }

          if (!this.readyToPlay || !this.userInitiatedAudio) {
            console.log("[Audio] Cannot play combat music - audio not ready");
            return;
          }

          // Save the current background music if we need to restore it later
          if (this.bgMusic && !this.savedBgMusic) {
            this.savedBgMusic = {
              src: this.bgMusic.src,
              currentTime: this.bgMusic.currentTime,
              isPlaying: !this.bgMusic.paused,
            };
          }

          // Pause the current background music
          if (this.bgMusic) {
            this.bgMusic.pause();
          }

          // Create a new audio element for combat music
          console.log("[Audio] Starting combat music");
          const combatMusic = new Audio(this.sounds.combatmusic);
          combatMusic.loop = true;
          combatMusic.volume = 0.4; // Slightly louder for combat intensity
          combatMusic.id = "combatMusic";

          // Try to play the combat music
          const playPromise = combatMusic.play();
          if (playPromise) {
            playPromise
              .then(() => {
                console.log("[Audio] Combat music started successfully");
                // Update the bgMusic reference to point to combat music
                this.bgMusic = combatMusic;
              })
              .catch((e) => {
                console.error("[Audio] Failed to play combat music:", e);
              });
          }
        },

        // Restore the original background music after combat
        restoreBackgroundMusic() {
          // If we don't have saved music or audio is muted, just return
          if (!this.savedBgMusic || this.muted) {
            return;
          }

          console.log("[Audio] Restoring normal background music");

          // Stop any current music
          if (this.bgMusic) {
            this.bgMusic.pause();
          }

          // Create a new audio element with the saved music
          const restoredMusic = new Audio(this.savedBgMusic.src);
          restoredMusic.loop = true;
          restoredMusic.volume = 0.3;
          restoredMusic.currentTime = this.savedBgMusic.currentTime;

          // Play it if it was playing before
          if (this.savedBgMusic.isPlaying) {
            const playPromise = restoredMusic.play();
            if (playPromise) {
              playPromise
                .then(() => {
                  console.log("[Audio] Background music restored");
                })
                .catch((e) => {
                  console.error("[Audio] Failed to restore background music:", e);
                });
            }
          }

          // Update reference and clear saved state
          this.bgMusic = restoredMusic;
          this.savedBgMusic = null;
        },

        // Pause background music
        pauseBackgroundMusic() {
          const music = this.audioElements.bgMusic;
          if (music) {
            try {
              music.pause();
            } catch (e) {
              console.error("Error pausing background music:", e);
            }
          }
        },

        // Set muted state
        setMuted(isMuted) {
          this.muted = isMuted;
          localStorage.setItem("gcaMuted", isMuted);

          if (isMuted) {
            this.pauseBackgroundMusic();
            Object.values(this.audioElements).forEach((audio) => {
              if (audio) audio.pause();
            });
          } else {
            this.playBackgroundMusic();
          }

          console.log("Sound " + (isMuted ? "muted" : "unmuted"));
        },

        // Toggle mute state
        toggleMute() {
          this.setMuted(!this.muted);
          return this.muted;
        },
      };

      // Initialize Debug Mode
      document.addEventListener("keydown", (event) => {
        if (event.key === "F3" || (event.ctrlKey && event.key.toLowerCase() === "d")) {
          event.preventDefault();
          DEBUG.enabled = !DEBUG.enabled;

          // Update overlay
          const debugOverlay = document.getElementById("debugOverlay");
          if (debugOverlay) {
            debugOverlay.style.display = DEBUG.enabled ? "block" : "none";
          }

          CollisionMapManager.updateDebugInfo();
        }

        if (DEBUG.enabled && event.key === "Enter") {
          const input = prompt(
            "Enter coordinates:\n- Single: x,y (e.g. 0,0)\n- Multiple: x1,y1;x2,y2 (e.g. 0,0;1,1)\n- Range: x1,y1-x2,y2 (e.g. 0,0-2,2)",
            "",
          );
          if (input) {
            const coordinates = [];

            // Split by semicolons first
            const parts = input.split(";");

            parts.forEach((part) => {
              part = part.trim();
              if (part.includes("-")) {
                // Handle range notation (e.g. 0,0-2,2)
                const [start, end] = part.split("-").map((coord) => coord.trim());
                const [startX, startY] = start.split(",").map(Number);
                const [endX, endY] = end.split(",").map(Number);

                if (!isNaN(startX) && !isNaN(startY) && !isNaN(endX) && !isNaN(endY)) {
                  // Generate all coordinates in the range
                  const minX = Math.min(startX, endX);
                  const maxX = Math.max(startX, endX);
                  const minY = Math.min(startY, endY);
                  const maxY = Math.max(startY, endY);

                  for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                      coordinates.push({ x, y });
                    }
                  }
                }
              } else {
                // Handle single coordinate
                const [x, y] = part.split(",").map(Number);
                if (!isNaN(x) && !isNaN(y)) {
                  coordinates.push({ x, y });
                }
              }
            });

            // Toggle all collected coordinates
            coordinates.forEach(({ x, y }) => {
              CollisionMapManager.toggleTile(x, y);
            });

            // Set the last valid coordinate as selected
            if (coordinates.length > 0) {
              DEBUG.selectedTile = coordinates[coordinates.length - 1];
            }

            CollisionMapManager.updateDebugInfo();

            // Force redraw
            requestAnimationFrame(() => {
              // TODO: Add scene redraw function call here
            });
          }
        }
      });

      // Debug Mode Toggle Function
      function toggleDebugMode(event) {
        if (event.key === "F3" || (event.ctrlKey && event.key.toLowerCase() === "d")) {
          event.preventDefault();
          DEBUG.enabled = !DEBUG.enabled;

          // Update overlay
          const debugOverlay = document.getElementById("debugOverlay");
          const debugStatus = document.getElementById("debugStatus");

          if (DEBUG.enabled) {
            debugOverlay.style.display = "block";
            debugStatus.textContent = "ON";
            debugStatus.style.color = "#00ff00";
            updateDebugInfo();
          } else {
            debugOverlay.style.display = "none";
            debugStatus.textContent = "OFF";
            debugStatus.style.color = "#ff0000";
            DEBUG.selectedTile = null;
          }

          // Force a redraw
          requestAnimationFrame(() => {
            // Redraw the current scene
            const currentScene = GameStateManager.state.currentScene;
            if (currentScene) {
              // TODO: Add scene redraw function call here
            }
          });
        }
      }

      // Update debug overlay information
      function updateDebugInfo() {
        if (!DEBUG.enabled) return;

        const selectedTileInfo = document.getElementById("selectedTileInfo");
        const activeTileCount = document.getElementById("activeTileCount");

        // Update selected tile info
        if (DEBUG.selectedTile) {
          const tile = DEBUG.collisionMap.get(`${DEBUG.selectedTile.x},${DEBUG.selectedTile.y}`);
          selectedTileInfo.textContent = `(${DEBUG.selectedTile.x}, ${DEBUG.selectedTile.y}) - ${tile?.active ? "Active" : "Inactive"}`;
        } else {
          selectedTileInfo.textContent = "None";
        }

        // Update active tile count
        let activeCount = 0;
        DEBUG.collisionMap.forEach((tile) => {
          if (tile.active) activeCount++;
        });
        activeTileCount.textContent = activeCount;
      }

      // Game States
      const GAME_STATES = {
        START: "start",
        CHARACTER_SELECT: "character_select",
        EXPLORE: "explore",
        BATTLE: "battle",
        DIALOGUE: "dialogue", // Add this line
        MENU: "menu",
      };

      // Add this function before the CHARACTER_CLASSES definition
      function generateRandomStat(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      // Character Classes with expanded stats
      const CHARACTER_CLASSES = {
        FLEXECUTIONER: {
          name: "Flexecutioner",
          getBaseStats: function () {
            return {
              strength: generateRandomStat(4, 10),
              intelligence: generateRandomStat(1, 10),
              vitality: generateRandomStat(3, 10),
              dexterity: generateRandomStat(2, 10),
              fortune: generateRandomStat(1, 10),
              charisma: generateRandomStat(1, 10),
            };
          },
          sprite:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flexecutioner-YTnx5DSfVR0ALUTlZc9Kt5xLlJFP4m.png?DUxz",
          skills: {
            // Levels 1-20 ("Bro-vember Boot Camp")
            powerStrike: {
              name: "Power Strike",
              level: 1,
              type: "active",
              target: "single",
              mpCost: 5,
              cooldown: 3,
              description: "220% STR damage. 20% chance to Bleed (10% HP over 3 turns).",
              effect: "damage",
              damageMultiplier: 2.2,
              tags: ["attack", "bleed"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Power_Strike-TdI9P4tDRxKJDi4nrkYzOo6ZOQGVd8.png?8zRh",
            },
            proteinShake: {
              name: "Protein Shake",
              level: 3,
              type: "passive",
              target: "self",
              mpCost: null,
              cooldown: null,
              description: "+4% max HP & +5% HP regen in overworld",
              effect: "passive",
              tags: ["passive", "hpBoost"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Protein_Shake-54Wxu2EMJPUyum8tQvNB6omzEr06ka.png?lLDP",
            },
            battleCry: {
              name: "Battle Cry",
              level: 6,
              type: "active",
              target: "party",
              mpCost: 10,
              cooldown: 4,
              description: "+20% STR & +10% VIT for 3 turns",
              effect: "buff",
              tags: ["buff", "party"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Battlecry-k9raCuUNvagZNaWQpOhrgdGQVkYvEw.png?0TXy",
            },
            formCheck: {
              name: "Form Check",
              level: 9,
              type: "passive",
              target: "self",
              mpCost: null,
              cooldown: null,
              description: "Blocks 10% of melee damage if not moved last turn",
              effect: "passive",
              tags: ["passive", "defense"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Form_Check-uuG94ENZ6UgXkkmKYQ2qUu8fDVvhV4.png?Fm9f",
            },
            superset: {
              name: "Superset",
              level: 12,
              type: "active",
              target: "aoe",
              mpCost: 12,
              cooldown: 4,
              description: "150% STR damage to all enemies in front row",
              effect: "damage",
              damageMultiplier: 1.5,
              tags: ["attack", "aoe"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/SuperSet-cGre4HfAHl4GiI2SzPGCJQftx8wVX0.png?3HXJ",
            },
            flexAndReflect: {
              name: "Flex and Reflect",
              level: 15,
              type: "active",
              target: "self",
              mpCost: 8,
              cooldown: 5,
              description: "Heals 18% max HP and grants 15% damage-reflection for 2 turns",
              effect: "heal",
              tags: ["heal", "reflect"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexandReflect-DmQe8wXiLB5B8ScgEIBoUEEjSa0HAI.png?BRvj",
            },
            nitricAura: {
              name: "Nitric Aura",
              level: 18,
              type: "passive",
              target: "self",
              mpCost: null,
              cooldown: null,
              description: "+8% crit rate when HP > 75%",
              effect: "passive",
              tags: ["passive", "crit"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Nitric_Aura-XoPStoTRqLtvxxQieq1uZAXDMZmpho.png?Y5RC",
            },

            // Levels 21-40 ("Iron Influencer")
            dumbbellCurve: {
              name: "Dumb-bell Curve",
              level: 22,
              type: "active",
              target: "single",
              mpCost: 14,
              cooldown: 4,
              description: "-25% STR & DEX on target for 3 turns",
              effect: "debuff",
              tags: ["debuff"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Dumbell_Curve-ntoYgu8trCgAhdssWIwe6PXzHUVZOq.png?jDoz",
            },
            massPull: {
              name: "Mass Pull",
              level: 25,
              type: "active",
              target: "aoe",
              mpCost: 15,
              cooldown: 4,
              description: "Taunts all foes; +20% block for 2 turns",
              effect: "taunt",
              tags: ["taunt", "defense"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/MassPull-YV5zTAgQnX1KaHE3PCkoyFIdlQph0r.png?uXkJ",
            },
            hypertrophy: {
              name: "Hypertrophy",
              level: 28,
              type: "passive",
              target: "self",
              mpCost: null,
              cooldown: null,
              description: "Every 100 XP gained: +1 permanent max HP (cap +300)",
              effect: "passive",
              tags: ["passive", "growth"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Hypertrophy-A8LVzMPzDAafic5fLq1q3fLAtow2lx.png?wous",
            },
            swoleStomp: {
              name: "Swole Stomp",
              level: 31,
              type: "active",
              target: "aoe",
              mpCost: 18,
              cooldown: 5,
              description: "180% STR damage to all; 30% chance to Stun 1 turn",
              effect: "damage",
              damageMultiplier: 1.8,
              tags: ["attack", "aoe", "stun"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Swole_stomp-upI76Vcxcr7nbvv5PtR1ikm7qvN8li.png?jbwu",
            },
            adrenalFlood: {
              name: "Adrenal Flood",
              level: 34,
              type: "active",
              target: "self",
              mpCost: 0,
              cooldown: 6,
              description: "HP cost 8%; +40% STR & +25% Speed for 2 turns",
              effect: "buff",
              tags: ["buff", "hpCost"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Adrenal_flood-fq9DrYPWViZajIKirvtq4pi95kKupI.png?Iu7E",
            },
            plyometricGuard: {
              name: "Plyometric Guard",
              level: 37,
              type: "passive",
              target: "self",
              mpCost: null,
              cooldown: null,
              description: "When dodging, next attack +30% damage",
              effect: "passive",
              tags: ["passive", "attackBoost"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Plyometric_guard-3s34NBBzpneu7Cv5puJBur5EtAQ3Cs.png?DHdC",
            },
            broteinBarrier: {
              name: "Bro-tein Barrier",
              level: 40,
              type: "active",
              target: "party",
              mpCost: 20,
              cooldown: 7,
              description: "Absorbs (20% VIT + 5% max HP) damage for all allies, 2 turns",
              effect: "shield",
              tags: ["shield", "party"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Bro-Tein_Barrier-1a6RjE0H1eYlD7vJvKdwbpuuwsoLuj.png?3hFc",
            },

            // Levels 41-60 ("Competition Cut")
            dropSet: {
              name: "Drop-Set",
              level: 43,
              type: "active",
              target: "single",
              mpCost: 16,
              cooldown: 3,
              description: "Hits 3× (90% STR) on one target; each hit has +10% crit",
              effect: "damage",
              damageMultiplier: 0.9,
              hits: 3,
              tags: ["attack", "multiHit"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Drop%20Set-fxPgopqisrpscPrhvt3Eg9nTpefVqy.png?TLfc",
            },
            creatineSurge: {
              name: "Creatine Surge",
              level: 46,
              type: "passive",
              target: "self",
              mpCost: null,
              cooldown: null,
              description: "+12% MP and +10% skill damage if MP ≥ 50%",
              effect: "passive",
              tags: ["passive", "mpBoost"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Creatin_Surge-5NnYEEij4KqnPUln4RO3kIhWBefN55.png?XLf1",
            },
            spotMe: {
              name: "Spot Me!",
              level: 49,
              type: "active",
              target: "ally",
              mpCost: 14,
              cooldown: 4,
              description: "Target ally gains +25% damage and 1 free revive at 20% HP (once)",
              effect: "buff",
              tags: ["buff", "support"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Spot_me-ZrfUIautQQRQS3Om0E34pQmBhciSVS.png?c4oF",
            },
            titanicTwist: {
              name: "Titanic Twist",
              level: 52,
              type: "active",
              target: "line",
              mpCost: 22,
              cooldown: 5,
              description: "200% STR damage in a straight line; -15% DEF 2 turns",
              effect: "damage",
              damageMultiplier: 2.0,
              tags: ["attack", "armorBreak"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Titanic_twist-JvpE8HXMC5lhxgnHQBZt5tQDFSixn3.png?uxRt",
            },
            mindMuscleLink: {
              name: "Mind-Muscle Link",
              level: 55,
              type: "passive",
              target: "self",
              mpCost: null,
              cooldown: null,
              description: "Casting any buff spell heals self 4% HP",
              effect: "passive",
              tags: ["passive", "heal"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Mind_Muscle-72Zli0g1C0noyBHJcq57fg0NNrEVmL.png?4l2l",
            },
            anabolicRush: {
              name: "Anabolic Rush",
              level: 58,
              type: "active",
              target: "self",
              mpCost: 18,
              cooldown: 6,
              description: "Heal 30% max HP + 10% STR; cleanse 1 debuff",
              effect: "heal",
              tags: ["heal", "cleanse"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Anabolic_Rush-nk5DoyBFe19kqcKECpWZzDgMFK1iXx.png?zpoT",
            },
            failureIsNotFinal: {
              name: "Failure Is Not Final",
              level: 60,
              type: "passive",
              target: "self",
              mpCost: null,
              cooldown: null,
              description: "First lethal blow per battle: revive at 35% HP + Adrenal Flood",
              effect: "passive",
              tags: ["passive", "revive"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Failure_not_final-et4UFLy0YWr73ZjkFix7hnOGrFqEn9.png?jBxs",
            },

            // Levels 61-80 ("Legendary Lifter")
            olympianClean: {
              name: "Olympian Clean",
              level: 63,
              type: "active",
              target: "single",
              mpCost: 24,
              cooldown: 4,
              description: "350% STR damage; ignores 30% DEF; 50% chance Armor-break 3 turns",
              effect: "damage",
              damageMultiplier: 3.5,
              tags: ["attack", "armorBreak"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Olympian_Clean-YdHVy28LKqC8NifIrRVbK4WucMJNNM.png?Qwkd",
            },
            muscleMemory: {
              name: "Muscle Memory",
              level: 66,
              type: "passive",
              target: "self",
              mpCost: null,
              cooldown: null,
              description: "After any skill, reduce its cooldown by 1 turn (cannot self-trigger)",
              effect: "passive",
              tags: ["passive", "cooldown"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Muscle_memory-COP5FDVR4LIN18FpUq6vtka0JueBU0.png?RG0T",
            },
            rageDeload: {
              name: "Rage Deload",
              level: 69,
              type: "active",
              target: "self",
              mpCost: 0,
              cooldown: 7,
              description: "Convert 10% missing HP to +10% STR & DEF per 5% (max +60%) for 3 turns",
              effect: "buff",
              tags: ["buff", "hpCost"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Rage_Deload-TjU0jQpJX1yQbQOD93BkFT3zFnLfc7.png?Frsk",
            },
            pandemoniumPress: {
              name: "Pandemonium Press",
              level: 72,
              type: "active",
              target: "global",
              mpCost: 30,
              cooldown: 6,
              description: "240% STR damage to all foes; heals party 8% HP if any foe dies",
              effect: "damage",
              damageMultiplier: 2.4,
              tags: ["attack", "aoe", "heal"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Pandemonium_Press-BqVqT0FgILfozf3mRALUAULRY5ZCg5.png?JU9S",
            },
            wheyLayer: {
              name: "Whey Layer",
              level: 75,
              type: "passive",
              target: "self",
              mpCost: null,
              cooldown: null,
              description: "+20% ailment resistance; heal 2% HP each turn while buffed",
              effect: "passive",
              tags: ["passive", "defense"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Whey_Layer-sm0nsWwiTJgpyObzm34kVdYdVRbSPl.png?8IIK",
            },
            atlasCarry: {
              name: "Atlas Carry",
              level: 78,
              type: "active",
              target: "party",
              mpCost: 26,
              cooldown: 8,
              description: "3 turns: transfers 50% damage from allies to self and halves it; self gains +25% block",
              effect: "guard",
              tags: ["guard", "party"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Atlas_Carry-kS0qatjj2i0jtKiBXDTVdaDJ626qE7.png?kgIV",
            },
            flexecution: {
              name: "Flexecution",
              level: 80,
              type: "active",
              target: "single",
              mpCost: 40,
              cooldown: 10,
              description: "500% STR damage +20% per debuff; if target defeated, resets half of all cooldowns",
              effect: "damage",
              damageMultiplier: 5.0,
              tags: ["attack", "execute", "ultimate"],
              icon: "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flexecution-nhUfwDdCSnbaOWOVZTE01uLycFZJfr.png?M7Bq",
            },
          },
        },
        INFLUMANCER: {
          name: "Influmancer",
          getBaseStats: function () {
            return {
              strength: generateRandomStat(1, 10),
              intelligence: generateRandomStat(4, 10),
              vitality: generateRandomStat(1, 10),
              dexterity: generateRandomStat(3, 10),
              fortune: generateRandomStat(2, 10),
              charisma: generateRandomStat(2, 10),
            };
          },
          sprite:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/MagePlain-QmnDB17afkcu1MxW5qI01eJ6wWOHzW.png?jN4S",
          spell: {
            name: "Fireball",
            mpCost: 15,
            description: "Deals fire damage to all enemies",
            effect: "damage",
          },
          skill: {
            name: "Magic Shield",
            description: "Reduces incoming damage by 50% for 2 turns",
            cooldown: 4,
          },
        },
        SUS_ASSIN: {
          name: "Sus-assin",
          getBaseStats: function () {
            return {
              strength: generateRandomStat(2, 10),
              intelligence: generateRandomStat(1, 10),
              vitality: generateRandomStat(1, 10),
              dexterity: generateRandomStat(4, 10),
              fortune: generateRandomStat(3, 10),
              charisma: generateRandomStat(2, 10),
            };
          },
          sprite:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Rogue-6gW48YRLz1cC0Jp7zuye2ZYM658NmV.png?tzYD",
          spell: {
            name: "Shadow Step",
            mpCost: 12,
            description: "Increases evasion for 3 turns",
            effect: "buff",
          },
          skill: {
            name: "Backstab",
            description: "Deals 3x damage if attacking from behind",
            cooldown: 3,
          },
        },
        MOM_FRIEND: {
          name: "Mom Friend",
          getBaseStats: function () {
            return {
              strength: generateRandomStat(2, 10),
              intelligence: generateRandomStat(3, 10),
              vitality: generateRandomStat(3, 10),
              dexterity: generateRandomStat(1, 10),
              fortune: generateRandomStat(1, 10),
              charisma: generateRandomStat(2, 10),
            };
          },
          sprite:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Cleric_Idle_128x128-LGShcztECCrmR9waVDEvCZTYaALg6P.png?kglI",
          spell: {
            name: "Heal",
            mpCost: 20,
            description: "Restores HP to target ally",
            effect: "heal",
          },
          skill: {
            name: "Divine Protection",
            description: "Reduces all incoming damage by 75% for 1 turn",
            cooldown: 5,
          },
        },
      };

      // Equipment System
      const EQUIPMENT_SLOTS = {
        MAIN_HAND: "MAIN_HAND",
        OFF_HAND: "OFF_HAND",
        HEAD: "HEAD",
        BODY: "BODY",
        LEGS: "LEGS",
        FEET: "FEET",
        RELIC_1: "RELIC_1",
        RELIC_2: "RELIC_2",
      };

      const EQUIPMENT_TYPES = {
        WEAPON: "weapon",
        SHIELD: "shield",
        ARMOR: "armor",
        RELIC: "relic",
      };

      const WEAPON_TYPES = {
        SWORD: "sword",
        STAFF: "staff",
        DAGGER: "dagger",
        MACE: "mace",
        TWO_HANDED: "2h", // Add proper type for two-handed weapons
      };

      const ARMOR_TYPES = {
        LIGHT: "light",
        MEDIUM: "medium",
        HEAVY: "heavy",
        CLOTH: "cloth",
      };

      // Base Equipment
      const BASE_EQUIPMENT = {
        // Weapons
        RUBBER_DUMBELLS: {
          id: "rubber_dumbells",
          name: "Rubber Dumbells",
          type: EQUIPMENT_TYPES.WEAPON,
          weaponType: WEAPON_TYPES.TWO_HANDED, // Properly typed as a two-handed weapon
          slot: EQUIPMENT_SLOTS.MAIN_HAND,
          isTwoHanded: true, // Explicit flag as backup
          stats: {
            damage: 3,
            hitChance: 0.8,
          },
          requirements: {
            strength: 3,
          },
          sprite: "sword_icon.png",
        },
        WOODEN_STAFF: {
          id: "wooden_staff",
          name: "Wooden Staff",
          type: EQUIPMENT_TYPES.WEAPON,
          weaponType: WEAPON_TYPES.STAFF,
          slot: EQUIPMENT_SLOTS.MAIN_HAND,
          stats: {
            damage: 2,
            magicDamage: 3,
            hitChance: 0.85,
          },
          requirements: {
            intelligence: 3,
          },
          sprite: "staff_icon.png",
        },
        WOODEN_SHIELD: {
          id: "wooden_shield",
          name: "Wooden Shield",
          type: EQUIPMENT_TYPES.SHIELD,
          slot: EQUIPMENT_SLOTS.OFF_HAND,
          stats: {
            defense: 2,
            blockChance: 0.1,
          },
          requirements: {
            strength: 2,
          },
          sprite: "shield_icon.png",
        },

        // Armor
        LEATHER_CAP: {
          id: "leather_cap",
          name: "Leather Cap",
          type: EQUIPMENT_TYPES.ARMOR,
          armorType: ARMOR_TYPES.LIGHT,
          slot: EQUIPMENT_SLOTS.HEAD,
          stats: {
            defense: 1,
            evasion: 0.05,
          },
          sprite: "cap_icon.png",
        },
        CLOTH_ROBE: {
          id: "cloth_robe",
          name: "Cloth Robe",
          type: EQUIPMENT_TYPES.ARMOR,
          armorType: ARMOR_TYPES.CLOTH,
          slot: EQUIPMENT_SLOTS.BODY,
          stats: {
            defense: 1,
            magicDefense: 2,
          },
          sprite: "robe_icon.png",
        },
      };

      // Cloudian Relics System
      const RELIC_EFFECTS = {
        STAT_BOOST: "statBoost",
        SKILL_UNLOCK: "skillUnlock",
        PASSIVE_EFFECT: "passiveEffect",
      };

      const CLOUDIAN_RELICS = {
        ANCIENT_CRYSTAL: {
          id: "ancient_crystal",
          name: "Ancient Crystal",
          type: EQUIPMENT_TYPES.RELIC,
          slot: EQUIPMENT_SLOTS.RELIC_1,
          effect: {
            type: RELIC_EFFECTS.STAT_BOOST,
            stats: {
              intelligence: 2,
              mp: 20,
            },
          },
          description: "A crystal humming with ancient power.",
          sprite: "crystal_icon.png",
        },
        WARRIOR_SIGIL: {
          id: "warrior_sigil",
          name: "Warrior's Sigil",
          type: EQUIPMENT_TYPES.RELIC,
          slot: EQUIPMENT_SLOTS.RELIC_1,
          effect: {
            type: RELIC_EFFECTS.SKILL_UNLOCK,
            skill: {
              name: "Whirlwind",
              description: "Spin attack hitting all enemies",
              mpCost: 15,
              cooldown: 3,
            },
          },
          description: "A sigil bearing the mark of ancient warriors.",
          sprite: "sigil_icon.png",
        },
      };

      // Update stat descriptions
      const STAT_DESCRIPTIONS = {
        strength:
          "Physical power that determines melee damage and carrying capacity. Each point increases physical damage by 5%.",
        intelligence:
          "Magical aptitude affecting spell damage and MP pool. Each point increases magic damage by 5% and MP by 15.",
        vitality:
          "Physical toughness determining HP and defense. Each point increases max HP by 20 and physical defense by 3%.",
        dexterity:
          "Agility and precision affecting accuracy and evasion. Each point increases hit chance by 2% and dodge chance by 2%.",
        fortune:
          "Luck affecting critical hits and item finds. Each point increases critical chance by 1% and rare item find rate by 5%.",
        charisma:
          "Social influence affecting NPC interactions and shop prices. Each point improves quest rewards by 3% and reduces shop prices by 2%.",
        hp: "Health Points represent your life force. When this reaches zero, you'll need to restart from your last save point. Increased by Vitality.",
        mp: "Magic Points fuel your special abilities and spells. Regenerates slowly over time or with potions. Increased by Intelligence.",
      };

      // Glitch Animation System
      const GlitchAnimationSystem = {
        // Store animation frames
        frames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch1-p2MLYFtyBu70EfEzX38RisTZlDPz34.png?Uexu",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch2-wuGkXV6PbAhek8PI8QmClEcb2RWQNs.png?vrAB",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch3-VJR80WmbDycduGMWQoDAcXwVzUGb0k.png?npHD",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch2-wuGkXV6PbAhek8PI8QmClEcb2RWQNs.png?vrAB",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch3-VJR80WmbDycduGMWQoDAcXwVzUGb0k.png?npHD",
        ],
        isAnimating: false,
        sprite: null,
        frameIndex: 0,
        repeatCount: 0,
        maxRepeats: 2,
        animationInterval: null,
        bobInterval: null,

        // Create and start the animation
        playSpawnAnimation(tileX, tileY) {
          console.log("GLITCH ANIMATION: Playing glitch spawn animation at:", tileX, tileY);
          
          // Remove any debug messages from the top navigation
          const topNavDebugMessages = document.querySelectorAll('#topNav .debug-message');
          topNavDebugMessages.forEach(msg => msg.remove());
          
          // Remove any existing glitch indicator
          const glitchIndicator = document.getElementById('glitch-indicator');
          if (glitchIndicator) {
            glitchIndicator.remove();
          }

          // Create sprite element if it doesn't exist
          if (!this.sprite) {
            this.sprite = document.createElement("div");
            this.sprite.id = "glitch-sprite";
            this.sprite.style.cssText = `
              position: absolute;
              width: ${GRID_SIZE}px;
              height: ${GRID_SIZE}px;
              background-size: contain;
              background-repeat: no-repeat;
              background-position: center;
              z-index: 999;
              transition: transform 0.5s ease-in-out;
              pointer-events: none;
            `;
            document.getElementById("game-container").appendChild(this.sprite);
          }

          // Position the sprite in the game world
          const canvas = document.getElementById("gameCanvas");
          const posX = tileX * GRID_SIZE;
          const posY = tileY * GRID_SIZE;

          // Calculate position on screen (accounting for camera view)
          const player = GameStateManager.state.player;
          const cameraX = Math.max(
            0,
            Math.min(
              player.x * GRID_SIZE - canvas.width / 2,
              RenderManager.backgroundImage ? RenderManager.backgroundImage.width - canvas.width : 0,
            ),
          );
          const cameraY = Math.max(
            0,
            Math.min(
              player.y * GRID_SIZE - canvas.height / 2,
              RenderManager.backgroundImage ? RenderManager.backgroundImage.height - canvas.height : 0,
            ),
          );

          // Set sprite position
          this.sprite.style.left = `${posX - cameraX}px`;
          this.sprite.style.top = `${posY - cameraY}px`;

          // Reset animation state
          this.isAnimating = true;
          this.frameIndex = 0;
          this.repeatCount = 0;
          this.sprite.style.display = "block";
          this.sprite.style.backgroundImage = `url(${this.frames[0]})`;

          // Clear any existing intervals
          clearInterval(this.animationInterval);
          clearInterval(this.bobInterval);

          // Start frame animation
          this.animationInterval = setInterval(() => this.nextFrame(), 150);
        },

        // Advance to next animation frame
        nextFrame() {
          this.frameIndex = (this.frameIndex + 1) % this.frames.length;
          this.sprite.style.backgroundImage = `url(${this.frames[this.frameIndex]})`;

          // Check if we've completed a cycle through all frames
          if (this.frameIndex === this.frames.length - 1) {
            this.repeatCount++;

            // If we've completed the desired number of cycles
            if (this.repeatCount >= this.maxRepeats) {
              // Stop the frame animation
              clearInterval(this.animationInterval);
              this.isAnimating = false;

              // Start the bobbing animation
              this.startBobbing();
            }
          }
        },

        // Start the bobbing effect after frame animation completes
        startBobbing() {
          let bobUp = true;
          this.bobInterval = setInterval(() => {
            if (bobUp) {
              this.sprite.style.transform = "translateY(-5px)";
            } else {
              this.sprite.style.transform = "translateY(0px)";
            }
            bobUp = !bobUp;
          }, 800);
        },

        // Stop and clean up animations
        stopAnimations() {
          clearInterval(this.animationInterval);
          clearInterval(this.bobInterval);
          if (this.sprite) {
            this.sprite.style.display = "none";
          }
        }
      };

      // Game State Management
      const GameStateManager = {
        state: {
          currentState: GAME_STATES.START,
          player: null,
          currentScene: "arcade1",
          map: [],
          enemies: [],
          gold: 0,
          xp: 0,
          level: 1,
          keys: {},
          isPaused: false,
          inventory: [],
          fury: 0, // Track relic fury points
          relics: {}, // Track active relics
          lastMoveTime: 0,
          mapWidth: MAP_WIDTH,
          mapHeight: MAP_HEIGHT,
          // Custom spawn points for each scene
          spawnPoints: {
            arcade1: { x: 13, y: 14 },
          },
        },
        lastUpdate: 0,
        lastPassiveHealTime: 0,
        storedCollisionMaps: {},

        // Initialize the GameStateManager
        init() {
          // storedCollisionMaps is already initialized as an empty object
          console.log("GameStateManager initialized");
          
          // Initialize relics if player exists
          if (this.state.player) {
            RELIC_SYSTEM.initializeRelics(this.state.player);
          }

          // Set player position based on scene's spawn points if defined
          if (this.state.player && this.state.currentScene) {
            this.setPlayerPosition();
            // We'll trigger the glitch animation from setPlayerPosition only
          }
        },

        // Set player position based on scene's spawn point
        setPlayerPosition() {
          console.log(
            "[DEBUG setPlayerPosition] Called. Current Scene:",
            this.state.currentScene,
            "Player exists:",
            !!this.state.player,
          );

          // Check if a custom spawn point is defined for the current scene
          const sceneSpawnPoint = this.state.spawnPoints[this.state.currentScene];

          if (sceneSpawnPoint) {
            console.log(
              `[DEBUG setPlayerPosition] Using custom spawn point for ${this.state.currentScene}: (${sceneSpawnPoint.x}, ${sceneSpawnPoint.y})`,
            );
            this.state.player.x = sceneSpawnPoint.x;
            this.state.player.y = sceneSpawnPoint.y;

            // If we're in arcade1, trigger the glitch animation
            if (this.state.currentScene === "arcade1") {
              console.log("[DEBUG setPlayerPosition] Conditions met for glitch animation. Scheduling setTimeout.");
              // Slight delay to ensure player is visually positioned first
              setTimeout(() => {
                console.log("[DEBUG setPlayerPosition] setTimeout for glitch animation EXECUTING.");
                // Create a sprite at fixed coordinates (11, 19)
                const animationX = 11;
                const animationY = 19;
                console.log("CRITICAL DEBUG: About to call glitch animation at", animationX, animationY);
                // Make sure GlitchAnimationSystem exists
                if (typeof GlitchAnimationSystem !== "undefined") {
                  console.log("CRITICAL DEBUG: GlitchAnimationSystem exists in setPlayerPosition");
                  GlitchAnimationSystem.playSpawnAnimation(animationX, animationY);
                } else {
                  console.error("CRITICAL ERROR: GlitchAnimationSystem is undefined in setPlayerPosition!");
                }
              }, 500);
            }
          } else {
            console.warn(
              `[DEBUG setPlayerPosition] No custom spawn point found for scene: ${this.state.currentScene}. Player position not set via spawn point.`,
            );
          }
        },

        save() {
          try {
            const saveData = {
              gameState: this.state,
              mapData: this.state.map,
            };
            localStorage.setItem("glitterCloudSave", JSON.stringify(saveData));
            UIManager.log("Game saved successfully!");
            UIManager.toggleCharacterScreen();
          } catch (error) {
            console.warn("Failed to save game:", error);
            UIManager.log("Failed to save game: Storage not available");
          }
        },

        load() {
          try {
            const saveData = JSON.parse(localStorage.getItem("glitterCloudSave"));
            if (!saveData) {
              UIManager.log("No saved game found!");
              return false;
            }

            this.state = saveData.gameState;
            this.state.map = saveData.mapData;

            // Reinitialize player sprite and animation frames
            if (this.state.player) {
              // Reload sprite image
              const spriteImage = new Image();
              spriteImage.crossOrigin = "anonymous";
              spriteImage.onload = () => {
                this.state.player.spriteImage = spriteImage;
              };
              spriteImage.src = CHARACTER_CLASSES[this.state.player.class].sprite;

              // Reload animation frames
              preloadAnimationFrames(this.state.player);
            }

            UIManager.showGameScreen();
            UIManager.update();
            UIManager.toggleCharacterScreen();
            UIManager.log("Game loaded successfully!");
            return true;
          } catch (error) {
            console.warn("Failed to load game:", error);
            UIManager.log("Failed to load game: Storage not available");
            return false;
          }
        },

        update() {
          const now = Date.now();
          const dt = now - this.lastUpdate;
          this.lastUpdate = now;

          // Handle passive effects like healing
          this.handlePassiveEffects(now);

          // Update the Glitch NPC if it exists
          if (this.state.currentScene === "arcade1" && 
              typeof GlitchNPCManager !== 'undefined' && 
              typeof GlitchNPCManager.update === 'function') {
            
            // Call update on the manager to process animations
            GlitchNPCManager.update();
            
            // Verify NPCs are created or synced correctly
            if (this.state.glitchNPC && this.state.npcs && this.state.npcs.some(npc => npc.type === "GlitchNPC")) {
              // Check if NPC is in the correct state but not animating
              if (this.state.glitchNPC.animationState === GlitchNPCManager.STATES.SPECIAL_ANIMATION && 
                  now - this.state.glitchNPC.lastFrameUpdate > 1000) {
                // Force an update if the animation seems stuck
                console.log("🔍 DEBUG: Forcing GlitchNPC animation update - animation appears stuck");
                GlitchNPCManager.updateSpecialAnimation(now);
              }
            }
          }

          // Update cooldowns
          if (this.state?.player?.skills) {
            this.state.player.skills.forEach((skill) => {
              if (skill.currentCooldown > 0) {
                skill.currentCooldown = Math.max(0, skill.currentCooldown - dt / 1000);
              }
            });
          }

          // Update UI
          UIManager.update();

          if (!this.state.player) return;

          // Don't allow movement during battle
          if (this.state.currentState === GAME_STATES.BATTLE) return;

          const keys = this.state.keys;
          let moved = false;

          // Check if enough time has passed since last move
          const currentTime = Date.now();
          if (currentTime - this.state.lastMoveTime < MOVEMENT_DELAY) {
            return; // Not enough time has passed, skip movement
          }

          // Reset moving state
          this.state.player.animationState.isMoving = false;

          // Movement
          if (keys["ArrowUp"] || keys["w"]) {
            if (canMove(this.state.player.x, this.state.player.y - 1)) {
              this.state.player.y--;
              this.state.player.direction = "up";
              moved = true;
              this.state.player.animationState.isMoving = true;
              this.state.player.animationState.isIdle = false; // Exit idle state when moving
              this.state.player.animationState.lastMovementTime = currentTime; // Update for idle animation tracking
              this.state.lastMoveTime = currentTime;
              this.state.player.lastMoveTime = currentTime; // For Form Check passive
            } else {
              // Check if we're on a transition tile
              this.trySceneTransition(this.state.player.x, this.state.player.y);
            }
          }
          if (keys["ArrowDown"] || keys["s"]) {
            if (canMove(this.state.player.x, this.state.player.y + 1)) {
              this.state.player.y++;
              this.state.player.direction = "down";
              moved = true;
              this.state.player.animationState.isMoving = true;
              this.state.player.animationState.isIdle = false; // Exit idle state when moving
              this.state.player.animationState.lastMovementTime = currentTime; // Update for idle animation tracking
              this.state.lastMoveTime = currentTime;
              this.state.player.lastMoveTime = currentTime; // For Form Check passive
            } else {
              // Check if we're on a transition tile (handled by the code above)
            }
          }
          if (keys["ArrowLeft"] || keys["a"]) {
            if (canMove(this.state.player.x - 1, this.state.player.y)) {
              this.state.player.x--;
              this.state.player.direction = "left";
              moved = true;
              this.state.player.animationState.isMoving = true;
              this.state.player.animationState.isIdle = false; // Exit idle state when moving
              this.state.player.animationState.lastMovementTime = currentTime; // Update for idle animation tracking
              this.state.lastMoveTime = currentTime;
              this.state.player.lastMoveTime = currentTime; // For Form Check passive
            } else {
              // Check if we're on a transition tile (handled by the code above)
            }
          }
          if (keys["ArrowRight"] || keys["d"]) {
            if (canMove(this.state.player.x + 1, this.state.player.y)) {
              this.state.player.x++;
              this.state.player.direction = "right";
              moved = true;
              this.state.player.animationState.isMoving = true;
              this.state.player.animationState.isIdle = false; // Exit idle state when moving
              this.state.player.animationState.lastMovementTime = currentTime; // Update for idle animation tracking
              this.state.lastMoveTime = currentTime;
              this.state.player.lastMoveTime = currentTime; // For Form Check passive
            } else {
              // Check if we're on a transition tile (handled by the code above)
            }
          }

          // Check for transition tiles
          if (moved) {
            this.trySceneTransition(this.state.player.x, this.state.player.y);

            // Check if player is on special tiles (e.g., dialogue triggers)
            InputManager.checkSpecialTiles();

            // Animation update
            if (
              currentTime - this.state.player.animationState.lastFrameUpdate >=
              this.state.player.animationState.frameInterval
            ) {
              this.state.player.animationState.currentFrame =
                (this.state.player.animationState.currentFrame + 1) % this.state.player.animationState.totalFrames;
              this.state.player.animationState.lastFrameUpdate = currentTime;
            }
          }
        },

        handlePassiveEffects(now) {
          if (!this.state?.player) return;

          // Get all passive skills
          const passiveSkills = this.state.player.skills.filter((s) => s.type === "passive");
          if (passiveSkills.length === 0) return;

          // Process each passive skill
          // Initialize lastPassiveHealTime if it's undefined (important for mobile)
          if (this.lastPassiveHealTime === undefined) {
            this.lastPassiveHealTime = now - 5100; // Set to trigger first heal immediately
          }

          passiveSkills.forEach((skill) => {
            switch (skill.name) {
              case "Protein Shake":
                // First, apply the 4% max HP boost if not already applied
                if (!this.state.player.proteinShakeApplied) {
                  const maxHpBoost = Math.floor(this.state.player.derivedStats.maxHp * 0.04); // 4% max HP boost
                  this.state.player.derivedStats.maxHp += maxHpBoost;
                  this.state.player.proteinShakeApplied = true;
                  console.log(
                    "[Protein Shake] Applied max HP boost:",
                    maxHpBoost,
                    "| New max HP:",
                    this.state.player.derivedStats.maxHp,
                  );
                }

                // Apply passive healing every 5 seconds
                if (now - this.lastPassiveHealTime >= 5000) {
                  // 5000ms = 5 seconds
                  const healAmount = Math.floor(this.state.player.derivedStats.maxHp * 0.05); // 5% heal (increased from 1%)
                  this.state.player.hp = Math.min(
                    this.state.player.hp + healAmount,
                    this.state.player.derivedStats.maxHp,
                  );
                  this.lastPassiveHealTime = now;

                  // Add visual feedback for mobile users
                  if (this.state.player.hp < this.state.player.derivedStats.maxHp) {
                    UIManager.log(`Protein Shake restored ${healAmount} HP!`);
                  }

                  console.log("[Protein Shake] Applied healing:", healAmount, "| New HP:", this.state.player.hp);
                }
                break;

              case "Form Check":
                // Track if player hasn't moved in the last turn for damage reduction
                if (!this.state.player.lastMoveTime || now - this.state.player.lastMoveTime >= 1000) {
                  this.state.player.formCheckActive = true;
                } else {
                  this.state.player.formCheckActive = false;
                }
                break;

              case "Nitric Aura":
                // Update crit rate based on HP percentage
                const hpPercentage = (this.state.player.hp / this.state.player.derivedStats.maxHp) * 100;
                if (hpPercentage > 75) {
                  this.state.player.stats.critRate = (this.state.player.stats.critRate || 0) + 8;
                }
                break;

              case "Hypertrophy":
                // Check for XP milestones
                const currentXPMilestone = Math.floor(this.state.player.xp / 100);
                const previousXPMilestone = this.state.player.lastHypertrophyMilestone || 0;

                if (currentXPMilestone > previousXPMilestone) {
                  const newMilestonesCount = currentXPMilestone - previousXPMilestone;
                  const maxHPGain = Math.min(newMilestonesCount, 300 - (this.state.player.hypertrophyBonus || 0));

                  if (maxHPGain > 0) {
                    this.state.player.derivedStats.maxHp += maxHPGain;
                    this.state.player.hypertrophyBonus = (this.state.player.hypertrophyBonus || 0) + maxHPGain;
                    this.state.player.lastHypertrophyMilestone = currentXPMilestone;
                  }
                }
                break;

              case "Plyometric Guard":
                // This is handled in the dodge event, but we'll set up the state
                if (
                  !this.state.player.plyometricGuardActive &&
                  this.state.player.lastDodgeTime &&
                  now - this.state.player.lastDodgeTime < 5000
                ) {
                  this.state.player.plyometricGuardActive = true;
                }
                break;
            }
          });
        },

        trySceneTransition(playerX, playerY) {
          console.log("DEBUG - trySceneTransition start:", { playerX, playerY });
          const currentScene = this.state.currentScene;
          console.log("DEBUG - Current scene:", currentScene);

          const scene = SCENES[currentScene.toUpperCase()];
          console.log("DEBUG - Current scene data:", {
            id: scene?.id,
            transitions: scene?.transitions,
            transitionTiles: scene?.transitionTiles,
          });

          if (!scene) {
            console.log("[DEBUG] Scene not found:", currentScene);
            return false;
          }

          const tileX = Math.floor(playerX);
          const tileY = Math.floor(playerY);

          // Check if player is on a transition tile
          if (scene.transitionTiles) {
            console.log("[DEBUG] Checking transition tiles:", scene.transitionTiles);
            for (const [targetScene, tiles] of Object.entries(scene.transitionTiles)) {
              console.log(`[DEBUG] Checking tiles for ${targetScene}:`, tiles);
              // Check each transition tile for this target scene
              for (const [x, y] of tiles) {
                console.log(`[DEBUG] Comparing player (${tileX}, ${tileY}) with tile (${x}, ${y})`);
                if (tileX === x && tileY === y) {
                  // Found a matching transition tile, get the transition data
                  const transition = scene.transitions[targetScene];
                  console.log(`[DEBUG] Found matching tile, transition data:`, transition);
                  if (transition) {
                    console.log(`[DEBUG] Found transition to ${transition.scene} at (${tileX}, ${tileY})`);
                    this.changeScene(transition.scene, transition.targetSpawnId);
                    return true;
                  }
                }
              }
            }
          }

          console.log(`[DEBUG] No valid transition found at (${tileX}, ${tileY})`);
          return false;
        },

        changeScene(targetSceneId, targetSpawnId) {
          console.log("DEBUG - changeScene start:", { targetSceneId, targetSpawnId });

          const targetScene = SCENES[targetSceneId.toUpperCase()];
          console.log("DEBUG - Target scene full data:", {
            id: targetScene?.id,
            transitions: targetScene?.transitions,
            spawnPoints: targetScene?.spawnPoints,
          });

          if (!targetScene) {
            console.error("DEBUG - Target scene not found!");
            return;
          }
          
          // Clear all Glitch NPCs when changing scenes
          if (this.state.npcs) {
            console.log(`🔍 DEBUG: Removing all Glitch NPCs during scene transition`);
            this.state.npcs = this.state.npcs.filter(npc => npc.type !== "GlitchNPC");
          }
          
          // Clear the specific glitchNPC reference
          if (this.state.glitchNPC) {
            console.log(`🔍 DEBUG: Clearing glitchNPC reference during scene transition`);
            this.state.glitchNPC = null;
          }
          
          // If we're moving away from arcade1, ensure GlitchNPCManager is cleaned up
          if (this.state.currentScene === "arcade1" && targetSceneId !== "arcade1") {
            if (GlitchNPCManager && typeof GlitchNPCManager.remove === 'function') {
              console.log(`🔍 DEBUG: Calling GlitchNPCManager.remove() during scene transition`);
              GlitchNPCManager.remove();
            }
          }

          // Store current collision map before leaving the scene
          const oldScene = this.state.currentScene;
          if (oldScene) {
            // Make sure we're storing a non-empty collision map
            if (DEBUG.collisionMap.size > 0) {
              // Store the current collision map before changing scenes
              const currentMap = CollisionMapManager.exportMap();
              this.storedCollisionMaps[oldScene] = currentMap;
              console.log(`Stored collision map for scene: ${oldScene}`, { mapSize: Object.keys(currentMap).length });
            } else {
              console.log(`WARNING: Not storing empty collision map for ${oldScene}`);
            }
          }

          // Set a flag to prevent any other code from resetting the map after we restore it
          this.mapJustRestored = false;

          // Update game state
          this.state.currentScene = targetSceneId;
          console.log("DEBUG - Updated scene in game state:", { from: oldScene, to: targetSceneId });

          // Clear existing collision map
          CollisionMapManager.resetMap();

          // Check if we have a stored map for the target scene
          if (
            this.storedCollisionMaps[targetSceneId] &&
            Object.keys(this.storedCollisionMaps[targetSceneId]).length > 0
          ) {
            // Log stored map size to debug
            const storedMapSize = Object.keys(this.storedCollisionMaps[targetSceneId]).length;
            console.log(`Found stored map for ${targetSceneId} with ${storedMapSize} tiles`);

            // Restore the saved collision map
            CollisionMapManager.importMap(this.storedCollisionMaps[targetSceneId]);
            console.log(`Restored collision map for scene: ${targetSceneId}`);

            // Validate that the map was properly restored
            const restoredMapSize = DEBUG.collisionMap.size;
            console.log(`Validated restored map size: ${restoredMapSize}`);

            // Set flag to indicate the map was just restored - this prevents other handlers from resetting it
            this.mapJustRestored = true;
          } else if (targetSceneId === "arcade1" || targetSceneId === "arcade2" || targetSceneId === "arcade3") {
            // For arcade scenes, we need to initialize with the hardcoded maps
            console.log(`No stored map found for ${targetSceneId}, loading default map...`);

            // We'll let the initialization below take care of it
            this.mapJustRestored = false;
          } else if (targetScene.collisionMap) {
            // Import collision map for other scenes if it exists
            CollisionMapManager.importMap(JSON.stringify(targetScene.collisionMap));
            console.log("Imported collision map for scene:", targetSceneId);
            this.mapJustRestored = true;
          }

          // Initialize the map if it's not already initialized
          if (!targetScene.map) {
            targetScene.map = {};
          }

          // Update player position based on spawn point ID
          console.log("DEBUG - Looking for spawn point:", {
            targetSpawnId,
            availableSpawnPoints: targetScene.spawnPoints,
          });

          const spawnPoint = targetScene.spawnPoints?.[targetSpawnId];
          if (spawnPoint && typeof spawnPoint.x === "number" && typeof spawnPoint.y === "number") {
            console.log("DEBUG - Found valid spawn point:", { spawnPoint });
            const oldPos = { x: this.state.player.x, y: this.state.player.y };
            this.state.player.x = spawnPoint.x;
            this.state.player.y = spawnPoint.y;
            this.state.player.direction = spawnPoint.direction || "down";
            console.log("DEBUG - Updated player position:", {
              from: oldPos,
              to: { x: this.state.player.x, y: this.state.player.y },
              spawnPoint,
            });
          } else {
            // Fallback to default spawn point if the target spawn point is not found
            console.log("No valid spawn point found, using default position");
            const defaultSpawn = {
              x: Math.floor(this.state.mapWidth / 2),
              y: Math.floor(this.state.mapHeight / 2),
              direction: "down",
            };
            this.state.player.x = defaultSpawn.x;
            this.state.player.y = defaultSpawn.y;
            this.state.player.direction = defaultSpawn.direction;
            console.log("Player positioned at default location:", defaultSpawn);
          }

          // Log scene change
          UIManager.log(`Entered ${targetScene.name}`);

          // Load the new background
          RenderManager.loadBackground(targetScene.background);

          // Initialize scene collision maps if they don't exist in storage
          if (targetSceneId === "arcade1") {
            // Only load the hardcoded map if we don't have one stored already
            if (!this.storedCollisionMaps[targetSceneId]) {
              console.log("Loading initial arcade1 collision map...");
              const arcade1CollisionMap = {
                "0,0": true,
                "0,1": true,
                "0,2": true,
                "0,3": true,
                "0,4": true,
                "0,5": true,
                "0,6": true,
                "0,7": true,
                "0,8": true,
                "0,9": true,
                "1,0": true,
                "1,1": true,
                "1,2": true,
                "1,3": true,
                "1,4": true,
                "1,5": true,
                "1,6": true,
                "1,7": true,
                "1,8": true,
                "1,9": true,
                "2,0": true,
                "2,1": true,
                "2,2": true,
                "2,3": true,
                "2,4": true,
                "2,5": true,
                "2,6": true,
                "2,7": true,
                "2,8": true,
                "3,0": true,
                "3,1": true,
                "3,2": true,
                "3,3": true,
                "3,4": true,
                "3,5": true,
                "3,6": true,
                "3,7": true,
                "3,8": true,
                "4,0": true,
                "4,1": true,
                "5,0": true,
                "5,1": true,
                "6,0": true,
                "6,1": true,
                "6,2": true,
                "6,3": true,
                "6,4": true,
                "6,5": true,
                "7,0": true,
                "7,1": true,
                "7,2": true,
                "7,3": true,
                "7,4": true,
                "7,5": true,
                "8,0": true,
                "8,1": true,
                "8,2": true,
                "8,3": true,
                "8,4": true,
                "8,5": true,
                "8,10": true,
                "9,0": true,
                "9,1": true,
                "9,2": true,
                "9,3": true,
                "9,4": true,
                "9,5": true,
                "9,6": true,
                "9,7": true,
                "9,8": true,
                "9,9": true,
                "9,10": true,
                "10,0": true,
                "10,1": true,
                "10,2": true,
                "10,3": true,
                "10,4": true,
                "10,5": true,
                "10,6": true,
                "10,7": true,
                "10,8": true,
                "10,9": true,
                "10,10": true,
                "11,0": true,
                "11,1": true,
                "11,2": true,
                "11,3": true,
                "11,4": true,
                "11,5": true,
                "11,6": true,
                "11,7": true,
                "11,8": true,
                "11,9": true,
                "11,10": true,
                "12,0": true,
                "12,1": true,
                "12,2": true,
                "12,3": true,
                "12,4": true,
                "12,5": true,
                "12,6": true,
                "12,7": true,
                "12,8": true,
                "12,9": true,
                "12,10": true,
                "13,0": true,
                "13,1": true,
                "13,2": true,
                "13,3": true,
                "13,4": true,
                "13,5": true,
                "13,6": true,
                "13,7": true,
                "13,8": true,
                "13,9": true,
                "13,10": true,
                "14,0": true,
                "14,1": true,
                "14,2": true,
                "14,3": true,
                "14,4": true,
                "14,5": true,
                "14,6": true,
                "14,7": true,
                "14,8": true,
                "14,9": true,
                "14,10": true,
                "15,0": true,
                "15,1": true,
                "15,2": true,
                "15,3": true,
                "15,4": true,
                "15,5": true,
                "15,6": true,
                "15,7": true,
                "15,8": true,
                "15,9": true,
                "15,10": true,
                "16,0": true,
                "16,1": true,
                "16,2": true,
                "16,3": true,
                "16,4": true,
                "16,5": true,
                "17,0": true,
                "17,1": true,
                "17,2": true,
                "17,3": true,
                "17,4": true,
                "18,0": true,
                "18,1": true,
                "18,2": true,
                "18,3": true,
                "18,4": true,
                "19,0": true,
                "19,1": true,
                "19,2": true,
                "19,3": true,
                "19,4": true,
                "20,0": true,
                "20,1": true,
                "21,0": true,
                "21,1": true,
                "22,0": true,
                "22,1": true,
                "22,7": true,
                "22,8": true,
                "22,9": true,
                "22,10": true,
                "23,0": true,
                "23,1": true,
                "23,2": true,
                "23,3": true,
                "23,4": true,
                "23,5": true,
                "23,6": true,
                "23,7": true,
                "23,8": true,
                "23,9": true,
                "23,10": true,
                "24,0": true,
                "24,1": true,
                "24,2": true,
                "24,3": true,
                "24,4": true,
                "24,5": true,
                "24,6": true,
                "24,7": true,
                "24,8": true,
                "24,9": true,
                "24,10": true,
                "25,0": true,
                "25,1": true,
                "25,2": true,
                "25,3": true,
                "25,4": true,
                "25,5": true,
                "25,6": true,
                "25,7": true,
                "25,8": true,
                "25,9": true,
                "25,10": true,
                "26,0": true,
                "26,1": true,
                "26,2": true,
                "26,3": true,
                "26,4": true,
                "26,5": true,
                "26,6": true,
                "26,7": true,
                "26,8": true,
                "26,9": true,
                "26,10": true,
                "27,0": true,
                "27,1": true,
                "27,2": true,
                "27,3": true,
                "27,4": true,
                "27,5": true,
                "27,6": true,
                "27,7": true,
                "27,8": true,
                "27,9": true,
                "27,10": true,
                "28,0": true,
                "28,1": true,
                "28,2": true,
                "28,3": true,
                "28,4": true,
                "28,5": true,
                "28,6": true,
                "28,7": true,
                "28,8": true,
                "28,9": true,
                "28,10": true,
                "29,0": true,
                "29,1": true,
                "29,2": true,
                "29,3": true,
                "29,4": true,
                "29,5": true,
                "29,6": true,
                "29,7": true,
                "29,8": true,
                "29,9": true,
                "29,10": true,
                "30,0": true,
                "30,1": true,
                "30,2": true,
                "30,3": true,
                "30,4": true,
                "30,5": true,
                "30,6": true,
                "30,7": true,
                "30,8": true,
                "30,9": true,
                "30,10": true,
                "31,0": true,
                "31,1": true,
                "31,2": true,
                "31,3": true,
                "31,4": true,
                "31,5": true,
                "31,6": true,
                "31,7": true,
                "31,8": true,
                "31,9": true,
                "31,10": true,
                "28,11": true,
                "28,12": true,
                "28,13": true,
                "28,14": true,
                "28,15": true,
                "28,16": true,
                "28,17": true,
                "29,11": true,
                "29,12": true,
                "29,13": true,
                "29,14": true,
                "29,15": true,
                "29,16": true,
                "29,17": true,
                "30,11": true,
                "30,12": true,
                "30,13": true,
                "30,14": true,
                "30,15": true,
                "30,16": true,
                "30,17": true,
                "31,11": true,
                "31,12": true,
                "31,13": true,
                "31,14": true,
                "31,15": true,
                "31,16": true,
                "31,17": true,
                "24,11": true,
                "24,12": true,
                "24,13": true,
                "24,14": true,
                "24,15": true,
                "20,11": true,
                "20,12": true,
                "20,13": true,
                "20,14": true,
                "20,15": true,
                "21,11": true,
                "21,12": true,
                "21,13": true,
                "21,14": true,
                "21,15": true,
                "22,11": true,
                "22,12": true,
                "22,13": true,
                "22,14": true,
                "22,15": true,
                "8,11": true,
                "9,11": true,
                "10,11": true,
                "11,11": true,
                "3,12": true,
                "3,13": true,
                "3,14": true,
                "3,15": true,
                "4,12": true,
                "4,13": true,
                "4,14": true,
                "4,15": true,
                "5,12": true,
                "5,13": true,
                "5,14": true,
                "5,15": true,
                "0,13": true,
                "0,14": true,
                "0,15": true,
                "0,16": true,
                "0,17": true,
                "1,13": true,
                "1,14": true,
                "1,15": true,
                "1,16": true,
                "1,17": true,
                "2,13": true,
                "2,14": true,
                "2,15": true,
                "2,16": true,
                "2,17": true,
                "5,20": true,
                "5,21": true,
                "6,20": true,
                "6,21": true,
                "7,20": true,
                "7,21": true,
                "8,20": true,
                "8,21": true,
                "9,20": true,
                "9,21": true,
                "10,20": true,
                "10,21": true,
                "11,20": true,
                "11,21": true,
                "12,20": true,
                "12,21": true,
                "13,20": true,
                "13,21": true,
                "14,20": true,
                "14,21": true,
                "15,20": true,
                "15,21": true,
                "16,20": true,
                "16,21": true,
                "17,20": true,
                "17,21": true,
                "7,19": true,
                "8,19": true,
                "9,19": true,
                "10,19": true,
                "11,19": true,
                "12,19": true,
                "13,19": true,
                "14,19": true,
                "15,19": true,
                "9,18": true,
                "10,18": true,
                "11,18": true,
                "12,18": true,
                "13,18": true,
                "10,17": true,
                "11,17": true,
                "12,17": true,
                "11,16": true,
              };
              CollisionMapManager.importMap(JSON.stringify(arcade1CollisionMap));
              console.log("Collision map size:", DEBUG.collisionMap.size);
              console.log("Sample collision check (0,0):", DEBUG.collisionMap.get("0,0"));
              // Store this map for future use
              this.storedCollisionMaps[targetSceneId] = CollisionMapManager.exportMap();
            } else {
              // Clear collision map for other scenes
              CollisionMapManager.resetMap();
            }
          } else if (targetSceneId === "arcade2") {
            // Only load the hardcoded map if we don't have one stored already
            if (!this.storedCollisionMaps[targetSceneId]) {
              console.log("Loading initial arcade2 collision map...");
              const arcade2CollisionMap = {
                "0,0": true,
                "0,1": true,
                "0,2": true,
                "0,3": true,
                "0,4": true,
                "1,0": true,
                "1,1": true,
                "1,2": true,
                "1,3": true,
                "1,4": true,
                "2,0": true,
                "2,1": true,
                "2,2": true,
                "2,3": true,
                "2,4": true,
                "3,0": true,
                "3,1": true,
                "3,2": true,
                "3,3": true,
                "3,4": true,
                "4,0": true,
                "4,1": true,
                "4,2": true,
                "4,3": true,
                "4,4": true,
                "5,0": true,
                "5,1": true,
                "5,2": true,
                "5,3": true,
                "5,4": true,
                "6,0": true,
                "6,1": true,
                "6,2": true,
                "6,3": true,
                "6,4": true,
                "7,0": true,
                "7,1": true,
                "7,2": true,
                "7,3": true,
                "7,4": true,
                "8,0": true,
                "8,1": true,
                "8,2": true,
                "8,3": true,
                "8,4": true,
                "9,0": true,
                "9,1": true,
                "9,2": true,
                "9,3": true,
                "9,4": true,
                "10,0": true,
                "10,1": true,
                "10,2": true,
                "10,3": true,
                "10,4": true,
                "11,0": true,
                "11,1": true,
                "11,2": true,
                "11,3": true,
                "11,4": true,
                "12,0": true,
                "12,1": true,
                "12,2": true,
                "12,3": true,
                "12,4": true,
                "13,0": true,
                "13,1": true,
                "13,2": true,
                "13,3": true,
                "13,4": true,
                "14,0": true,
                "14,1": true,
                "14,2": true,
                "14,3": true,
                "14,4": true,
                "15,0": true,
                "15,1": true,
                "15,2": true,
                "15,3": true,
                "15,4": true,
                "16,0": true,
                "16,1": true,
                "16,2": true,
                "16,3": true,
                "16,4": true,
                "17,0": true,
                "17,1": true,
                "17,2": true,
                "17,3": true,
                "17,4": true,
                "18,0": true,
                "18,1": true,
                "18,2": true,
                "18,3": true,
                "18,4": true,
                "19,0": true,
                "19,1": true,
                "19,2": true,
                "19,3": true,
                "19,4": true,
                "20,0": true,
                "20,1": true,
                "20,2": true,
                "20,3": true,
                "20,4": true,
                "0,5": true,
                "0,6": true,
                "0,7": true,
                "1,5": true,
                "1,6": true,
                "1,7": true,
                "2,5": true,
                "2,6": true,
                "2,7": true,
                "3,5": true,
                "3,6": true,
                "3,7": true,
                "4,5": true,
                "4,6": true,
                "4,7": true,
                "5,5": true,
                "5,6": true,
                "5,7": true,
                "6,5": true,
                "6,6": true,
                "7,5": true,
                "8,5": true,
                "9,5": true,
                "10,5": true,
                "11,5": true,
                "12,5": true,
                "13,5": true,
                "14,5": true,
                "15,5": true,
                "16,5": true,
                "17,5": true,
                "18,5": true,
                "19,5": true,
                "20,5": true,
                "0,8": true,
                "0,9": true,
                "1,8": true,
                "1,9": true,
                "2,8": true,
                "2,9": true,
                "3,8": true,
                "3,9": true,
                "4,8": true,
                "4,9": true,
                "5,8": true,
                "5,9": true,
                "2,10": true,
                "2,11": true,
                "3,10": true,
                "3,11": true,
                "4,10": true,
                "4,11": true,
                "5,11": true,
                "5,12": true,
                "5,13": true,
                "5,14": true,
                "6,11": true,
                "6,12": true,
                "6,13": true,
                "6,14": true,
                "0,10": true,
                "0,11": true,
                "0,12": true,
                "0,13": true,
                "0,14": true,
                "0,15": true,
                "0,16": true,
                "0,17": true,
                "0,18": true,
                "0,19": true,
                "0,20": true,
                "0,21": true,
                "1,10": true,
                "1,11": true,
                "1,12": true,
                "1,13": true,
                "1,14": true,
                "1,15": true,
                "1,16": true,
                "1,17": true,
                "1,18": true,
                "1,19": true,
                "1,20": true,
                "1,21": true,
                "2,12": true,
                "2,13": true,
                "2,14": true,
                "3,12": true,
                "3,13": true,
                "3,14": true,
                "4,12": true,
                "4,13": true,
                "4,14": true,
                "2,15": true,
                "2,16": true,
                "2,17": true,
                "2,18": true,
                "2,19": true,
                "2,20": true,
                "2,21": true,
                "3,15": true,
                "3,16": true,
                "3,17": true,
                "3,18": true,
                "3,19": true,
                "3,20": true,
                "3,21": true,
                "4,15": true,
                "4,16": true,
                "4,17": true,
                "4,18": true,
                "4,19": true,
                "4,20": true,
                "4,21": true,
                "17,6": true,
                "17,7": true,
                "17,8": true,
                "17,9": true,
                "17,10": true,
                "17,11": true,
                "17,12": true,
                "17,13": true,
                "17,20": true,
                "17,21": true,
                "18,6": true,
                "18,7": true,
                "18,8": true,
                "18,9": true,
                "18,10": true,
                "18,11": true,
                "18,12": true,
                "18,13": true,
                "18,20": true,
                "18,21": true,
                "19,6": true,
                "19,7": true,
                "19,8": true,
                "19,9": true,
                "19,10": true,
                "19,11": true,
                "19,12": true,
                "19,13": true,
                "19,20": true,
                "19,21": true,
                "20,6": true,
                "20,7": true,
                "20,8": true,
                "20,9": true,
                "20,10": true,
                "20,11": true,
                "20,12": true,
                "20,13": true,
                "20,14": true,
                "20,15": true,
                "20,16": true,
                "20,17": true,
                "20,18": true,
                "20,19": true,
                "20,20": true,
                "20,21": true,
                "21,6": true,
                "21,7": true,
                "21,8": true,
                "21,9": true,
                "21,10": true,
                "21,11": true,
                "21,12": true,
                "21,13": true,
                "21,14": true,
                "21,15": true,
                "21,16": true,
                "21,17": true,
                "21,18": true,
                "21,19": true,
                "21,20": true,
                "21,21": true,
              };
              CollisionMapManager.importMap(JSON.stringify(arcade2CollisionMap));
              console.log("Collision map size:", DEBUG.collisionMap.size);
              console.log("Sample collision check (0,0):", DEBUG.collisionMap.get("0,0"));
              // Store this map for future use
              this.storedCollisionMaps[targetSceneId] = CollisionMapManager.exportMap();
            } else {
              // Clear collision map for other scenes
              CollisionMapManager.resetMap();
            }
          } else if (targetSceneId === "arcade3") {
            // Only load the hardcoded map if we don't have one stored already
            if (!this.storedCollisionMaps[targetSceneId]) {
              console.log("Loading initial arcade3 collision map...");
              const arcade3CollisionMap = {
                "0,0": true,
                "0,1": true,
                "0,2": true,
                "1,0": true,
                "1,1": true,
                "1,2": true,
                "2,0": true,
                "2,1": true,
                "2,2": true,
                "3,0": true,
                "3,1": true,
                "3,2": true,
                "4,0": true,
                "4,1": true,
                "4,2": true,
                "5,0": true,
                "5,1": true,
                "5,2": true,
                "6,0": true,
                "6,1": true,
                "6,2": true,
                "7,0": true,
                "7,1": true,
                "7,2": true,
                "8,0": true,
                "8,1": true,
                "8,2": true,
                "9,0": true,
                "9,1": true,
                "9,2": true,
                "10,0": true,
                "10,1": true,
                "10,2": true,
                "11,0": true,
                "11,1": true,
                "11,2": true,
                "12,0": true,
                "12,1": true,
                "12,2": true,
                "13,0": true,
                "13,1": true,
                "13,2": true,
                "14,0": true,
                "14,1": true,
                "14,2": true,
                "15,0": true,
                "15,1": true,
                "15,2": true,
                "16,0": true,
                "16,1": true,
                "16,2": true,
                "17,0": true,
                "17,1": true,
                "17,2": true,
                "18,0": true,
                "18,1": true,
                "18,2": true,
                "19,0": true,
                "19,1": true,
                "19,2": true,
                "20,0": true,
                "20,1": true,
                "20,2": true,
                "21,0": true,
                "21,1": true,
                "21,2": true,
                "0,3": true,
                "0,4": true,
                "0,5": true,
                "1,3": true,
                "1,4": true,
                "1,5": true,
                "2,3": true,
                "2,4": true,
                "2,5": true,
                "3,3": true,
                "3,4": true,
                "3,5": true,
                "4,3": true,
                "4,4": true,
                "4,5": true,
                "5,3": true,
                "5,4": true,
                "5,5": true,
                "6,3": true,
                "6,4": true,
                "6,5": true,
                "7,3": true,
                "7,4": true,
                "7,5": true,
                "8,3": true,
                "8,4": true,
                "8,5": true,
                "9,3": true,
                "9,4": true,
                "9,5": true,
                "10,3": true,
                "10,4": true,
                "10,5": true,
                "11,3": true,
                "11,4": true,
                "11,5": true,
                "12,3": true,
                "12,4": true,
                "12,5": true,
                "13,3": true,
                "13,4": true,
                "13,5": true,
                "14,3": true,
                "14,4": true,
                "14,5": true,
                "15,3": true,
                "15,4": true,
                "15,5": true,
                "16,3": true,
                "16,4": true,
                "16,5": true,
                "17,3": true,
                "17,4": true,
                "17,5": true,
                "18,3": true,
                "18,4": true,
                "18,5": true,
                "19,3": true,
                "19,4": true,
                "19,5": true,
                "20,3": true,
                "20,4": true,
                "20,5": true,
                "21,3": true,
                "21,4": true,
                "21,5": true,
                "0,6": true,
                "0,7": true,
                "0,8": true,
                "1,6": true,
                "1,7": true,
                "1,8": true,
                "2,6": true,
                "2,7": true,
                "2,8": true,
                "3,6": true,
                "3,7": true,
                "3,8": true,
                "4,6": true,
                "4,7": true,
                "4,8": true,
                "5,6": true,
                "5,7": true,
                "5,8": true,
                "6,6": true,
                "6,7": true,
                "6,8": true,
                "7,6": true,
                "8,6": true,
                "9,6": true,
                "10,6": true,
                "11,6": true,
                "12,6": true,
                "13,6": true,
                "14,6": true,
                "15,6": true,
                "16,6": true,
                "17,6": true,
                "18,6": true,
                "19,6": true,
                "20,6": true,
                "21,6": true,
                "12,7": true,
                "12,8": true,
                "13,7": true,
                "13,8": true,
                "14,7": true,
                "14,8": true,
                "15,7": true,
                "15,8": true,
                "16,7": true,
                "16,8": true,
                "17,7": true,
                "17,8": true,
                "18,7": true,
                "18,8": true,
                "19,7": true,
                "19,8": true,
                "20,7": true,
                "20,8": true,
                "21,7": true,
                "21,8": true,
                "14,9": true,
                "15,9": true,
                "16,9": true,
                "17,9": true,
                "18,9": true,
                "19,9": true,
                "20,9": true,
                "21,9": true,
                "14,10": true,
                "15,10": true,
                "16,10": true,
                "17,10": true,
                "18,10": true,
                "19,10": true,
                "20,10": true,
                "21,10": true,
                "18,11": true,
                "18,15": true,
                "18,16": true,
                "18,17": true,
                "18,18": true,
                "19,11": true,
                "19,12": true,
                "20,11": true,
                "20,12": true,
                "21,11": true,
                "21,12": true,
                "17,11": true,
                "0,9": true,
                "1,9": true,
                "2,9": true,
                "3,9": true,
                "4,9": true,
                "0,10": true,
                "1,10": true,
                "2,10": true,
                "3,10": true,
                "0,15": true,
                "0,16": true,
                "0,17": true,
                "0,18": true,
                "0,19": true,
                "0,20": true,
                "0,21": true,
                "1,15": true,
                "1,16": true,
                "1,17": true,
                "1,18": true,
                "1,19": true,
                "1,20": true,
                "1,21": true,
                "2,16": true,
                "2,17": true,
                "2,18": true,
                "2,19": true,
                "2,20": true,
                "2,21": true,
                "3,16": true,
                "3,17": true,
                "3,18": true,
                "3,19": true,
                "3,20": true,
                "3,21": true,
                "4,17": true,
                "4,18": true,
                "4,19": true,
                "4,20": true,
                "4,21": true,
                "5,18": true,
                "5,19": true,
                "5,20": true,
                "5,21": true,
                "6,18": true,
                "6,19": true,
                "6,20": true,
                "6,21": true,
                "7,21": true,
              };
              CollisionMapManager.importMap(JSON.stringify(arcade3CollisionMap));
              console.log("Collision map size:", DEBUG.collisionMap.size);
              console.log("Sample collision check (0,0):", DEBUG.collisionMap.get("0,0"));
              // Store this map for future use
              this.storedCollisionMaps[targetSceneId] = CollisionMapManager.exportMap();
            } else {
              // Clear collision map for other scenes
              CollisionMapManager.resetMap();
            }
          }
        },

        updateMapBounds(width, height) {
          this.state.mapWidth = width || MAP_WIDTH;
          this.state.mapHeight = height || MAP_HEIGHT;
        },
      };

      // Dialogue System
      class DialogueSystemClass {
        constructor() {
          this.isActive = false;
          this.currentDialogue = null;
          this.dialogueContainer = null;
          this.dialogueText = null;
          this.dialogueChoices = null;
          this.onComplete = null;
          this.dialogueData = {
            arcade_glitchstick: [
              { text: "You found a Glitchstick! This rare artifact pulsates with digital energy." },
              { text: "It seems to react to the arcade machines around you." },
              { text: "[Acquired: Glitchstick]" },
            ],
            arcade_glitchstick_found: [
              { text: "The Glitchstick pulses in your inventory, resonating with the arcade machines." },
              { text: "Perhaps there's more to discover in this area..." },
            ],
          };

          this.init();
        }

        init() {
          // Create dialogue container if it doesn't exist
          if (!this.dialogueContainer) {
            console.log("Creating dialogue container");
            this.dialogueContainer = document.createElement("div");
            this.dialogueContainer.className = "dialogue-container";
            this.dialogueContainer.style.display = "none";
            this.dialogueContainer.style.position = "absolute";
            this.dialogueContainer.style.bottom = "100px";
            this.dialogueContainer.style.left = "50%";
            this.dialogueContainer.style.transform = "translateX(-50%)";
            this.dialogueContainer.style.background = "rgba(0, 0, 0, 0.8)";
            this.dialogueContainer.style.color = "#00ffff";
            this.dialogueContainer.style.padding = "15px";
            this.dialogueContainer.style.borderRadius = "5px";
            this.dialogueContainer.style.boxShadow = "0 0 10px rgba(0, 255, 255, 0.5)";
            this.dialogueContainer.style.maxWidth = "80%";
            this.dialogueContainer.style.zIndex = "100";
            this.dialogueContainer.style.animation = "fadeIn 0.3s ease-out";

            // Create dialogue text element
            this.dialogueText = document.createElement("div");
            this.dialogueText.className = "dialogue-text";
            this.dialogueText.style.marginBottom = "10px";
            this.dialogueText.style.lineHeight = "1.5";
            this.dialogueContainer.appendChild(this.dialogueText);

            // Create continue button
            const continueBtn = document.createElement("button");
            continueBtn.className = "dialogue-continue";
            continueBtn.textContent = "Continue";
            continueBtn.style.backgroundColor = "#004466";
            continueBtn.style.color = "#00ffff";
            continueBtn.style.border = "1px solid #00ffff";
            continueBtn.style.padding = "5px 15px";
            continueBtn.style.borderRadius = "3px";
            continueBtn.style.cursor = "pointer";
            continueBtn.addEventListener("click", () => this.nextDialogue());
            this.dialogueContainer.appendChild(continueBtn);

            // Create choices container
            this.dialogueChoices = document.createElement("div");
            this.dialogueChoices.className = "dialogue-choices";
            this.dialogueChoices.style.display = "none";
            this.dialogueContainer.appendChild(this.dialogueChoices);

            document.getElementById("game-container").appendChild(this.dialogueContainer);
            console.log("Dialogue container created and added to game container");
          }
        }

        startDialogue(dialogueId) {
          console.log(`Starting dialogue: ${dialogueId}`);

          if (!this.dialogueData[dialogueId]) {
            console.error(`Dialogue with ID '${dialogueId}' not found`);
            return;
          }

          this.currentDialogue = {
            lines: this.dialogueData[dialogueId],
            currentIndex: 0,
          };

          this.isActive = true;
          this.dialogueContainer.style.display = "block";

          // Show first line
          this.showCurrentLine();

          // If it's the glitchstick dialogue, give the player the item
          if (dialogueId === "arcade_glitchstick") {
            if (!GameStateManager.state.player.hasRelic) {
              GameStateManager.state.player.hasRelic = {};
            }
            GameStateManager.state.player.hasRelic.glitchstick = true;
            console.log("Added glitchstick to player inventory");
          }
        }

        showCurrentLine() {
          const currentLine = this.currentDialogue.lines[this.currentDialogue.currentIndex];
          this.dialogueText.textContent = currentLine.text;

          // Handle choices if present
          if (currentLine.choices && currentLine.choices.length > 0) {
            this.showChoices(currentLine.choices);
          } else {
            this.dialogueChoices.style.display = "none";
          }
        }

        showChoices(choices) {
          // Clear previous choices
          this.dialogueChoices.innerHTML = "";

          choices.forEach((choice, index) => {
            const choiceBtn = document.createElement("button");
            choiceBtn.className = "dialogue-choice";
            choiceBtn.textContent = choice.text;
            choiceBtn.style.backgroundColor = "#004466";
            choiceBtn.style.color = "#00ffff";
            choiceBtn.style.border = "1px solid #00ffff";
            choiceBtn.style.padding = "5px 15px";
            choiceBtn.style.borderRadius = "3px";
            choiceBtn.style.cursor = "pointer";
            choiceBtn.style.marginRight = "10px";
            choiceBtn.style.marginTop = "10px";

            choiceBtn.addEventListener("click", () => {
              this.handleChoice(index);
            });

            this.dialogueChoices.appendChild(choiceBtn);
          });

          this.dialogueChoices.style.display = "block";
        }

        handleChoice(choiceIndex) {
          const currentLine = this.currentDialogue.lines[this.currentDialogue.currentIndex];
          const choice = currentLine.choices[choiceIndex];

          // Handle choice action or next dialogue
          if (choice.nextIndex !== undefined) {
            this.currentDialogue.currentIndex = choice.nextIndex;
            this.showCurrentLine();
          } else if (choice.action) {
            // Execute the action if it's a function
            if (typeof choice.action === "function") {
              choice.action();
            }
            this.nextDialogue();
          } else {
            this.nextDialogue();
          }
        }

        nextDialogue() {
          this.currentDialogue.currentIndex++;

          if (this.currentDialogue.currentIndex >= this.currentDialogue.lines.length) {
            this.endDialogue();
          } else {
            this.showCurrentLine();
          }
        }

        endDialogue() {
          console.log("Dialogue ended");
          this.isActive = false;
          this.dialogueContainer.style.display = "none";

          if (this.onComplete && typeof this.onComplete === "function") {
            this.onComplete();
          }
        }
      }

      // Initialize DialogueSystem on page load to ensure it's ready
      document.addEventListener("DOMContentLoaded", function () {
        if (!window.DialogueSystem) {
          console.log("Creating DialogueSystem on page load");
          window.DialogueSystem = new DialogueSystemClass();
        }
      });

      // Also create a backup reference for Farcade compatibility
      const GCA_DialogueSystem = new DialogueSystemClass();

      // Input Management
      const InputManager = {
        // Track touch state
        touchState: {
          startX: 0,
          startY: 0,
          lastTap: 0,
        },

        // Convert canvas coordinates to game grid coordinates
        canvasToGridCoordinates(canvasX, canvasY) {
          const canvas = document.getElementById("gameCanvas");
          if (!canvas) return null;

          // Get current camera position
          const playerX = GameStateManager.state.player.x;
          const playerY = GameStateManager.state.player.y;

          // Get canvas dimensions
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;

          // Calculate camera offset based on render logic
          // This matches how the camera is calculated in RenderManager.render()
          const cameraX = Math.max(
            0,
            Math.min(
              playerX * GRID_SIZE - canvasWidth / 2,
              RenderManager.backgroundImage ? RenderManager.backgroundImage.width - canvasWidth : 0,
            ),
          );

          const cameraY = Math.max(
            0,
            Math.min(
              playerY * GRID_SIZE - canvasHeight / 2,
              RenderManager.backgroundImage ? RenderManager.backgroundImage.height - canvasHeight : 0,
            ),
          );

          // Perform the accurate conversion with the proper camera offset
          const gridX = Math.floor(canvasX + cameraX) / GRID_SIZE;
          const gridY = Math.floor(canvasY + cameraY) / GRID_SIZE;

          // Round to integers
          return {
            x: Math.floor(gridX),
            y: Math.floor(gridY),
          };
        },

        // Check if tap was on the player sprite
        isTapOnPlayer(gridX, gridY) {
          const player = GameStateManager.state.player;
          return gridX === player.x && gridY === player.y;
        },

        // Check if tap was on an enemy
        findTappedEnemy(gridX, gridY) {
          // Fix: enemies are stored in EnemyManager.enemies, not GameStateManager.state.enemies
          const enemies = EnemyManager.enemies;
          if (!enemies || !enemies.length) return null;

          // Logging for debug
          console.log(`Looking for enemy at (${gridX}, ${gridY}), found ${enemies.length} enemies`);

          // Find the enemy at the specific grid position
          const foundEnemy = enemies.find((enemy) => enemy.x === gridX && enemy.y === gridY);

          if (foundEnemy) {
            console.log(`Found enemy: ${foundEnemy.name} at (${foundEnemy.x}, ${foundEnemy.y})`);
          }

          return foundEnemy;
        },

        // Handle player movement to a grid position
        movePlayerToGrid(targetX, targetY) {
          // CRITICAL FIX: Don't allow movement when menus are open
          const characterScreen = document.getElementById('characterScreen');
          const inventoryScreen = document.getElementById('inventoryScreen');
          
          // Check if any menu is currently displayed
          if ((characterScreen && characterScreen.style.display === 'block') ||
              (inventoryScreen && inventoryScreen.style.display === 'block')) {
            console.log("🔍 DEBUG: Movement blocked - menu is open");
            return;
          }
          
          // Simple implementation: check if adjacent cell is walkable,
          // and if so, move one step in that direction
          const player = GameStateManager.state.player;

          // Don't move if we're already there
          if (player.x === targetX && player.y === targetY) return;

          // Reset idle state and update last movement time when moving
          player.animationState.lastMovementTime = Date.now();
          player.animationState.isIdle = false;
          player.animationState.isMoving = true;

          // Determine direction to move
          const dx = targetX - player.x;
          const dy = targetY - player.y;

          // Store current keys
          const savedKeys = { ...GameStateManager.state.keys };

          // Reset all movement keys
          GameStateManager.state.keys["ArrowUp"] = false;
          GameStateManager.state.keys["ArrowDown"] = false;
          GameStateManager.state.keys["ArrowLeft"] = false;
          GameStateManager.state.keys["ArrowRight"] = false;
          GameStateManager.state.keys["w"] = false;
          GameStateManager.state.keys["s"] = false;
          GameStateManager.state.keys["a"] = false;
          GameStateManager.state.keys["d"] = false;

          // Set key for one step in the appropriate direction
          if (Math.abs(dx) > Math.abs(dy)) {
            // Move horizontally first
            if (dx > 0) {
              GameStateManager.state.keys["ArrowRight"] = true;
              GameStateManager.state.keys["d"] = true;
            } else {
              GameStateManager.state.keys["ArrowLeft"] = true;
              GameStateManager.state.keys["a"] = true;
            }
          } else {
            // Move vertically first
            if (dy > 0) {
              GameStateManager.state.keys["ArrowDown"] = true;
              GameStateManager.state.keys["s"] = true;
            } else {
              GameStateManager.state.keys["ArrowUp"] = true;
              GameStateManager.state.keys["w"] = true;
            }
          }

          // Let the game process one movement step
          GameStateManager.update();

          // Check if player is on special tiles after movement
          // Call checkSpecialTiles as a method of InputManager
          InputManager.checkSpecialTiles();

          // Restore original key state
          GameStateManager.state.keys = savedKeys;
        },

        // Check if player is on special tiles that trigger dialogue
        checkSpecialTiles() {
          console.log(`🔍 DEBUG: checkSpecialTiles called`);
          const player = GameStateManager.state.player;
          const currentScene = GameStateManager.state.currentScene;

          // Only handle special tiles in the arcade1 scene
          if (player && currentScene === "arcade1") {
            console.log(`🔍 DEBUG: Player position (${player.x}, ${player.y}) in scene ${currentScene}`);
            console.log(
              `🔍 DEBUG: Player movement state - canMove: ${player.canMove}, isMoving: ${player.isMoving}, direction: ${player.direction}`,
            );

            // Only trigger the Glitch NPC when player is at the specific position (13,11)
            if (player.x === 13 && player.y === 11) {
              // Record the direction the player came from for debugging
              console.log(`🔍 DEBUG: Player arrived at special tile (13,11) from direction: ${player.direction}`);
              // Store this info for use later
              GameStateManager.state.lastPlayerDirection = player.direction;
              console.log(`🔍 DEBUG: Player is on special tile! Triggering dialogue.`);
              
              // COMPLETE CLEANUP FIRST - remove ALL GlitchNPCs from the game
              // Clear from the GameStateManager.state.npcs array
              if (GameStateManager.state.npcs) {
                console.log(`🔍 DEBUG: Removing all Glitch NPCs from npcs array`);
                GameStateManager.state.npcs = GameStateManager.state.npcs.filter(npc => npc.type !== "GlitchNPC");
              }
              
              // Clear the specific glitchNPC reference
              if (GameStateManager.state.glitchNPC) {
                console.log(`🔍 DEBUG: Clearing glitchNPC reference`);
                GameStateManager.state.glitchNPC = null;
              }
              
              // Then use the manager's remove method as a belt-and-suspenders approach
              if (GlitchNPCManager && typeof GlitchNPCManager.remove === 'function') {
                console.log(`🔍 DEBUG: Calling GlitchNPCManager.remove() for thorough cleanup`);
                GlitchNPCManager.remove();
              }
              
              // Reset the manager completely
              if (GlitchNPCManager) {
                console.log(`🔍 DEBUG: Resetting GlitchNPCManager`);
                GlitchNPCManager.isInitialized = false;
                
                // Explicitly reset the internal state
                GlitchNPCManager.state = {
                  currentState: "hidden",
                  frameIndex: 0,
                  cyclesCompleted: 0,
                  targetCycles: 2,
                  lastFrameUpdate: 0,
                  frameInterval: 180,
                  bobOffset: 0,
                  bobDirection: 1,
                  bobSpeed: 0.05,
                  spacebarPressCount: 0,
                  finalFrame: 2, // Glitch3
                  position: { x: 11, y: 9 },
                  isVisible: false,
                  onCompleteCallback: null,
                  dialogueTriggerId: null,
                  framesInCycle: GlitchNPCManager.frames ? GlitchNPCManager.frames.length : 5,
                };
              } else {
                console.error(`🔍 ERROR: GlitchNPCManager not found!`);
              }
              
              // Re-initialize the manager

              // Add a small delay before showing dialogue to ensure player movement is complete
              setTimeout(() => {
                try {
                  // Check if player has the glitchstick relic already
                  // First check the GameStateManager relics flag (set by the main dialogue)
                  if (
                    (GameStateManager.state.relics && GameStateManager.state.relics.glitchStickClaimed) ||
                    (player.hasRelic && player.hasRelic.glitchstick)
                  ) {
                    console.log(`🔍 DEBUG: Player has glitchstick already, showing appropriate dialogue`);

                    // Create arcade_glitchstick_found dialogue if it doesn't exist yet
                    if (!DialogueSystem.dialogues.arcade_glitchstick_found) {
                      DialogueSystem.dialogues.arcade_glitchstick_found = [
                        {
                          speaker: "🗣️ Guide",
                          text: "The stick is reacting to something in this room... interesting.",
                        },
                        {
                          speaker: "🗣️ Guide",
                          text: "I can feel energy patterns shifting. Keep exploring this area.",
                        },
                      ];
                    }

                    // Start dialogue
                    DialogueSystem.start("arcade_glitchstick_found");
                  } else {
                    console.log(`🔍 DEBUG: Player doesn't have glitchstick yet, showing discovery dialogue`);

                    // Use the main glitchStick dialogue for first discovery
                    // Start dialogue with the full sequence
                    // Note: The DialogueSystem.end method will automatically add the glitchstick to inventory
                    DialogueSystem.start("glitchStick");

                    // Just set the flag for compatibility and debugging
                    console.log(`🔍 DEBUG: glitchStick dialogue started - item will be added when dialogue ends`);

                    // No need to add the glitchstick here as DialogueSystem.end() already adds it
                  }
                } catch (e) {
                  console.error(`🔍 ERROR using DialogueSystem:`, e);
                  // Fall back to direct implementation if DialogueSystem fails
                  this.showDirectDialogue(player.hasRelic && player.hasRelic.glitchstick);
                }
              }, 200);
            }
          }
        },

        // DISABLED: This method has been disabled to avoid duplicate NPCs
        // Now using GlitchNPCManager.createGlitchNPC() exclusively
        createGlitchNPC() {
          console.log(`🔍 DEBUG: InputManager.createGlitchNPC is DISABLED to prevent duplicates`);
          console.log(`🔍 DEBUG: Using GlitchNPCManager.createGlitchNPC() instead`);
          
          // Use GlitchNPCManager if available
          if (typeof GlitchNPCManager !== 'undefined' && typeof GlitchNPCManager.createGlitchNPC === 'function') {
            GlitchNPCManager.createGlitchNPC();
          } else {
            console.error(`🔍 ERROR: GlitchNPCManager not available for NPC creation!`);
          }
        },

        // Direct dialogue implementation that doesn't rely on DialogueSystem class
        showDirectDialogue(hasGlitchstick) {
          console.log(`🔍 DEBUG: Using direct dialogue implementation`);

          // Remove any existing dialogue to avoid duplicates
          const existingDialogue = document.getElementById("direct-dialogue");
          if (existingDialogue) {
            existingDialogue.remove();
          }

          // Create the dialogue element
          const dialogueBox = document.createElement("div");
          dialogueBox.id = "direct-dialogue";
          dialogueBox.style.position = "absolute";
          dialogueBox.style.bottom = "100px";
          dialogueBox.style.left = "50%";
          dialogueBox.style.transform = "translateX(-50%)";
          dialogueBox.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
          dialogueBox.style.color = "#00ffff";
          dialogueBox.style.padding = "15px";
          dialogueBox.style.borderRadius = "5px";
          dialogueBox.style.boxShadow = "0 0 10px rgba(0, 255, 255, 0.5)";
          dialogueBox.style.maxWidth = "80%";
          dialogueBox.style.zIndex = "9999";
          dialogueBox.style.fontFamily = '"Game Font", "Courier New", monospace';

          // Set the dialogue content based on whether player has the glitchstick
          if (hasGlitchstick) {
            dialogueBox.innerHTML = `
              <div style="margin-bottom: 10px;">
                The Glitchstick pulses in your inventory, resonating with the arcade machines.
              </div>
              <div style="margin-bottom: 15px;">
                Perhaps there's more to discover in this area...
              </div>
              <button id="direct-dialogue-close" style="background-color: #004466; color: #00ffff; border: 1px solid #00ffff; padding: 5px 15px; border-radius: 3px; cursor: pointer;">
                Continue
              </button>
            `;
          } else {
            dialogueBox.innerHTML = `
              <div style="margin-bottom: 10px;">
                You found a Glitchstick! This rare artifact pulsates with digital energy.
              </div>
              <div style="margin-bottom: 10px;">
                It seems to react to the arcade machines around you.
              </div>
              <div style="margin-bottom: 15px; color: #00ff00;">
                [Acquired: Glitchstick]
              </div>
              <button id="direct-dialogue-close" style="background-color: #004466; color: #00ffff; border: 1px solid #00ffff; padding: 5px 15px; border-radius: 3px; cursor: pointer;">
                Continue
              </button>
            `;
          }

          // Add to the document
          const gameContainer = document.getElementById("game-container");
          if (gameContainer) {
            gameContainer.appendChild(dialogueBox);
          } else {
            document.body.appendChild(dialogueBox);
          }

          // Add close button functionality
          document.getElementById("direct-dialogue-close").addEventListener("click", function () {
            dialogueBox.remove();
          });
        },

        // Simple fallback dialogue when the DialogueSystem isn't available
        showFallbackDialogue(hasGlitchstick) {
          console.log(`🔍 DEBUG: Using fallback dialogue system`);

          // Create a simple dialogue box if it doesn't exist
          let dialogueBox = document.getElementById("fallback-dialogue");
          if (!dialogueBox) {
            dialogueBox = document.createElement("div");
            dialogueBox.id = "fallback-dialogue";
            dialogueBox.style.position = "absolute";
            dialogueBox.style.bottom = "100px";
            dialogueBox.style.left = "50%";
            dialogueBox.style.transform = "translateX(-50%)";
            dialogueBox.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
            dialogueBox.style.color = "#00ffff";
            dialogueBox.style.padding = "15px";
            dialogueBox.style.borderRadius = "5px";
            dialogueBox.style.boxShadow = "0 0 10px rgba(0, 255, 255, 0.5)";
            dialogueBox.style.maxWidth = "80%";
            dialogueBox.style.zIndex = "100";
            document.getElementById("game-container").appendChild(dialogueBox);
          }

          // Set the dialogue content based on whether player has the glitchstick
          if (hasGlitchstick) {
            dialogueBox.innerHTML = `
              <div style="margin-bottom: 10px;">The Glitchstick pulses in your inventory, resonating with the arcade machines.</div>
              <div style="margin-bottom: 10px;">Perhaps there's more to discover in this area...</div>
              <button id="close-dialogue" style="background-color: #004466; color: #00ffff; border: 1px solid #00ffff; padding: 5px 15px; border-radius: 3px; cursor: pointer;">Continue</button>
            `;
          } else {
            dialogueBox.innerHTML = `
              <div style="margin-bottom: 10px;">You found a Glitchstick! This rare artifact pulsates with digital energy.</div>
              <div style="margin-bottom: 10px;">It seems to react to the arcade machines around you.</div>
              <div style="margin-bottom: 10px;">[Acquired: Glitchstick]</div>
              <button id="close-dialogue" style="background-color: #004466; color: #00ffff; border: 1px solid #00ffff; padding: 5px 15px; border-radius: 3px; cursor: pointer;">Continue</button>
            `;

            // Give the player the glitchstick
            const player = GameStateManager.state.player;
            if (!player.hasRelic) player.hasRelic = {};
            player.hasRelic.glitchstick = true;
            console.log(`🔍 DEBUG: Added glitchstick to player inventory via fallback system`);
          }

          // Add close button functionality
          document.getElementById("close-dialogue").addEventListener("click", function () {
            dialogueBox.remove();
          });
        },

        // Handle touch/click on enemy - move next to them and initiate combat
        handleEnemyTap(enemy) {
          console.log(`🔍 DEBUG: handleEnemyTap called with enemy: ${enemy ? enemy.name : "undefined"}`);
          if (!enemy) {
            console.log(`🔍 DEBUG: handleEnemyTap aborted - enemy is null or undefined`);
            return;
          }
          
          // CRITICAL SAFETY CHECK: Don't initiate combat if any menu is open
          // Don't process if not in EXPLORE state
          if (GameStateManager.state.currentState !== GAME_STATES.EXPLORE) {
            console.log('🔍 DEBUG: Combat prevented - not in EXPLORE state');
            return;
          }
          
          // Check if character screen is open
          const characterScreen = document.getElementById('characterScreen');
          if (characterScreen && window.getComputedStyle(characterScreen).display !== 'none') {
            console.log('🔍 DEBUG: Combat prevented - character screen is open');
            return;
          }
          
          // Check if dialogue box is open
          const dialogueBox = document.querySelector('.dialogue-box');
          if (dialogueBox && window.getComputedStyle(dialogueBox).display !== 'none') {
            console.log('🔍 DEBUG: Combat prevented - dialogue box is open');
            return;
          }
          
          // Check if tooltip is open
          const tooltip = document.getElementById('ability-tooltip');
          if (tooltip && !tooltip.classList.contains('hidden')) {
            console.log('🔍 DEBUG: Combat prevented - tooltip is open');
            return;
          }
          
          // Check if any modal or menu container is open
          const anyModal = document.querySelector('.modal:not(.hidden)');
          if (anyModal) {
            console.log('🔍 DEBUG: Combat prevented - modal dialog is open');
            return;
          }
          
          // Check any tab or menu within character screen that might be open
          const anyMenu = document.querySelector('.menu-container:not([style*="display: none"])');
          if (anyMenu) {
            console.log('🔍 DEBUG: Combat prevented - menu container is open');
            return;
          }

          const player = GameStateManager.state.player;
          console.log(
            `🔍 DEBUG: Player position: (${player.x}, ${player.y}), Enemy position: (${enemy.x}, ${enemy.y})`,
          );

          // If player is already adjacent to the enemy, start battle immediately
          if (this.isAdjacentToEnemy(player, enemy)) {
            console.log(`🔍 DEBUG: Player is already adjacent to enemy - starting battle immediately`);
            BattleSystem.startBattle(enemy);
            return;
          }

          // Find an adjacent cell to move to
          const adjacentCells = [
            { x: enemy.x, y: enemy.y - 1 }, // top
            { x: enemy.x, y: enemy.y + 1 }, // bottom
            { x: enemy.x - 1, y: enemy.y }, // left
            { x: enemy.x + 1, y: enemy.y }, // right
          ];
          console.log(`🔍 DEBUG: Checking ${adjacentCells.length} adjacent cells for walkable path`);

          // Find closest walkable cell adjacent to enemy
          let closestCell = null;
          let minDistance = Infinity;

          for (const cell of adjacentCells) {
            console.log(`🔍 DEBUG: Checking cell (${cell.x}, ${cell.y})`);

            // First check if the cell is within bounds
            if (
              cell.x < 0 ||
              cell.y < 0 ||
              cell.x >= GameStateManager.state.mapWidth ||
              cell.y >= GameStateManager.state.mapHeight
            ) {
              console.log(`🔍 DEBUG: Cell (${cell.x}, ${cell.y}) is out of bounds`);
              continue;
            }

            // Check if there's a collision at this position
            const key = `${cell.x},${cell.y}`;
            if (DEBUG.collisionMap.get(key)) {
              console.log(`🔍 DEBUG: Cell (${cell.x}, ${cell.y}) has a collision`);
              continue;
            }

            // Check if there's already an enemy at this position (different from our target)
            const otherEnemyAtPosition = EnemyManager.enemies.find(
              (e) => e !== enemy && e.x === cell.x && e.y === cell.y,
            );
            if (otherEnemyAtPosition) {
              console.log(`🔍 DEBUG: Cell (${cell.x}, ${cell.y}) is occupied by another enemy`);
              continue;
            }

            // The cell is valid for movement
            const distance = Math.abs(cell.x - player.x) + Math.abs(cell.y - player.y);
            console.log(`🔍 DEBUG: Cell (${cell.x}, ${cell.y}) is valid with distance ${distance}`);

            if (distance < minDistance) {
              minDistance = distance;
              closestCell = cell;
              console.log(`🔍 DEBUG: New closest cell: (${cell.x}, ${cell.y}) with distance ${distance}`);
            }
          }

          if (closestCell) {
            console.log(`🔍 DEBUG: Found closest cell to move to: (${closestCell.x}, ${closestCell.y})`);

            // Store the enemy we're targeting so we can initiate combat after moving
            this.targetEnemy = enemy;
            console.log(`🔍 DEBUG: Set targetEnemy for delayed combat: ${this.targetEnemy.name}`);

            // Move to the adjacent cell
            console.log(`🔍 DEBUG: Attempting to move player to grid position (${closestCell.x}, ${closestCell.y})`);

            // Set player position directly to get to the cell next to the enemy
            // This bypasses normal movement checking and ensures we get next to the enemy
            GameStateManager.state.player.x = closestCell.x;
            GameStateManager.state.player.y = closestCell.y;
            console.log(`🔍 DEBUG: Directly moved player to (${closestCell.x}, ${closestCell.y})`);

            // Immediately start battle since we're now adjacent
            if (this.isAdjacentToEnemy(GameStateManager.state.player, enemy)) {
              console.log(`🔍 DEBUG: Starting battle with ${enemy.name} after positioning player`);
              BattleSystem.startBattle(enemy);
            } else {
              console.log(`🔍 DEBUG: ERROR: Player should be adjacent to enemy but isn't!`);
            }
          } else {
            console.log(`🔍 DEBUG: Could not find any walkable cells adjacent to enemy`);
            // As a fallback, try to force initiate combat even if we can't find a valid adjacent cell
            console.log(`🔍 DEBUG: Attempting to force initiate combat with ${enemy.name}`);
            BattleSystem.startBattle(enemy);
          }
        },

        // Helper function to check if player is adjacent to enemy
        isAdjacentToEnemy(player, enemy) {
          console.log(
            `🔍 DEBUG: Checking adjacency - Player at (${player.x}, ${player.y}), Enemy at (${enemy.x}, ${enemy.y})`,
          );

          // Manhattan distance of 1 means adjacent (orthogonally)
          const distance = Math.abs(player.x - enemy.x) + Math.abs(player.y - enemy.y);
          console.log(`🔍 DEBUG: Manhattan distance between player and enemy: ${distance}`);

          const isAdjacent = distance === 1;
          console.log(`🔍 DEBUG: Player is ${isAdjacent ? "" : "NOT "}adjacent to enemy`);

          return isAdjacent;
        },

        setup() {
          // We'll add the mouse click handler in a safer way after canvas initialization
          // This gets called at the right time during game initialization

          // Add method to safely set up click handler after canvas is available
          this.setupClickHandler = () => {
            console.log("🔍 DEBUG: Click handler setup started");
            try {
              // Make sure canvas exists before adding listener
              const canvasElement = document.getElementById("gameCanvas");
              if (canvasElement) {
                console.log("🔍 DEBUG: Canvas element found, adding click listener");

                // Add mouse click event for PC users
                canvasElement.addEventListener("click", (e) => {
                  console.log("🔍 DEBUG: Canvas click detected");

                  // Don't process clicks during battle or when any UI element is open
                  if (GameStateManager.state.currentState !== GAME_STATES.EXPLORE) {
                    console.log("🔍 DEBUG: Click ignored - not in EXPLORE state");
                    return;
                  }
                  
                  // Also check if tooltip is open, close it instead of processing map click
                  const tooltip = document.getElementById('ability-tooltip');
                  if (tooltip && !tooltip.classList.contains('hidden')) {
                    hideAbilityTooltip();
                    return;
                  }
                  
                  // Check character screen, dialogue box, or any other UI elements
                  const characterScreen = document.getElementById('characterScreen');
                  if (characterScreen && characterScreen.style.display === 'flex') {
                    console.log("🔍 DEBUG: Click ignored - character screen is open");
                    return;
                  }

                  const rect = canvasElement.getBoundingClientRect();
                  const x = e.clientX - rect.left;
                  const y = e.clientY - rect.top;
                  console.log(`🔍 DEBUG: Raw click at canvas coordinates (${x}, ${y})`);

                  // Convert to grid coordinates
                  const gridPos = this.canvasToGridCoordinates(x, y);
                  if (!gridPos) {
                    console.log("🔍 DEBUG: Failed to convert to grid coordinates");
                    return;
                  }
                  console.log(`🔍 DEBUG: Converted to grid coordinates (${gridPos.x}, ${gridPos.y})`);

                  // Check what was clicked
                  if (this.isTapOnPlayer(gridPos.x, gridPos.y)) {
                    console.log("🔍 DEBUG: Click detected on player");
                    // Clicked on player - open character screen
                    toggleCharacterScreen();
                  } else {
                    // Check if clicked on enemy
                    console.log("🔍 DEBUG: Checking for enemy at clicked position");
                    const enemy = this.findTappedEnemy(gridPos.x, gridPos.y);
                    if (enemy) {
                      console.log(`🔍 DEBUG: Enemy found at click position: ${enemy.name}`);
                      // Clicked on enemy - handle enemy tap (move + combat)
                      this.handleEnemyTap(enemy);
                    } else {
                      console.log("🔍 DEBUG: No enemy found at click position");
                      // Clicked on empty cell - move there
                      this.movePlayerToGrid(gridPos.x, gridPos.y);
                    }
                  }
                });
                console.log("Mouse click handler set up successfully");
              }
            } catch (err) {
              console.log("Error setting up click handler:", err);
            }
          };

          // Keyboard setup
          window.addEventListener("keydown", (e) => {
            // Don't register keys during battle
            if (GameStateManager.state.currentState === GAME_STATES.BATTLE) return;

            GameStateManager.state.keys[e.key] = true;

            // Toggle character screen with 'C' key
            if (e.key.toLowerCase() === "c") {
              toggleCharacterScreen();
            }

            // Toggle inventory with 'I' key
            if (e.key.toLowerCase() === "i") {
              toggleCharacterScreen();
              // Switch to items tab
              const itemsTab = document.querySelector('[data-tab="items-tab"]');
              if (itemsTab) {
                itemsTab.click();
              }
            }

            // Toggle messages with 'M' key
            if (e.key.toLowerCase() === "m") {
              toggleMessages();
            }

            // Handle E key press for interactions
            if (e.key === "e" || e.key === "E") {
              // Check if we're at the special tile coordinates in arcade1
              const player = GameStateManager.state.player;
              const currentScene = GameStateManager.state.currentScene?.id;

              // Only trigger at exactly (13,11) to avoid duplicate NPCs
              if (
                player &&
                currentScene === "arcade1" &&
                player.x === 13 && player.y === 11
              ) {
                // Check if relic has been claimed
                if (!GameStateManager.state.relics?.glitchStickClaimed) {
                  console.log("Triggering Glitch Stick dialogue at", player.x, player.y);
                  
                  // Reset Glitch NPC state for the upcoming dialogue
                  if (GlitchNPCManager) {
                    // Ensure we start fresh
                    GlitchNPCManager.state.spacebarPressCount = 0;
                    GlitchNPCManager.state.isVisible = false;
                    GlitchNPCManager.state.currentState = GlitchNPCManager.STATES.HIDDEN;
                    // Make sure no Glitch NPCs exist yet
                    GlitchNPCManager.remove();
                  }

                  // Start dialogue sequence
                  DialogueSystem.start("glitchStick");
                }
              }
            }

            // Ctrl + S to save
            if (e.ctrlKey && e.key === "s") {
              e.preventDefault();
              GameStateManager.save();
            }

            // Ctrl + L to load
            if (e.ctrlKey && e.key === "l") {
              e.preventDefault();
              GameStateManager.load();
            }
          });

          window.addEventListener("keyup", (e) => {
            GameStateManager.state.keys[e.key] = false;
          });

          // Touch support for canvas
          const canvas = document.getElementById("gameCanvas");
          if (canvas) {
            // Prevent default touch behavior on canvas (prevents scrolling)
            canvas.addEventListener(
              "touchstart",
              (e) => {
                e.preventDefault();

                // Don't process touches during non-EXPLORE states
                if (GameStateManager.state.currentState !== GAME_STATES.EXPLORE) {
                  console.log('Touch ignored - not in EXPLORE state');
                  return;
                }
                
                // Check if tooltip is open
                const tooltip = document.getElementById('ability-tooltip');
                if (tooltip && !tooltip.classList.contains('hidden')) {
                  hideAbilityTooltip();
                  return;
                }
                
                // Check character screen
                const characterScreen = document.getElementById('characterScreen');
                if (characterScreen && characterScreen.style.display === 'flex') {
                  console.log('Touch ignored - character screen is open');
                  return;
                }

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                // Convert to grid coordinates
                const gridPos = this.canvasToGridCoordinates(x, y);
                if (!gridPos) return;

                // Check what was tapped
                if (this.isTapOnPlayer(gridPos.x, gridPos.y)) {
                  // Tapped on player - open character screen
                  toggleCharacterScreen();
                } else {
                  // Check if tapped on enemy
                  const enemy = this.findTappedEnemy(gridPos.x, gridPos.y);
                  if (enemy) {
                    // Tapped on enemy - move next to it
                    this.handleEnemyTap(enemy);
                  } else {
                    // Tapped on empty cell - move there
                    this.movePlayerToGrid(gridPos.x, gridPos.y);
                  }
                }
              },
              { passive: false },
            );
          }
        },
      };

      // Glitch NPC Manager
      let instance = null;
      const GlitchNPCManager = {
        // Singleton flag to prevent multiple initializations
        isInitialized: false,
        
        // Constants
        STATES: {
          HIDDEN: "hidden",
          APPEARING: "appearing",
          IDLE: "idle",
          SPECIAL_ANIMATION: "special_animation",
          BOBBING: "bobbing",
          DISMISSING: "dismissing"
        },
        
        // Track if the manager is already initialized to prevent duplicates
        isInitialized: false,

        // Animation frames
        frames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch1-p2MLYFtyBu70EfEzX38RisTZlDPz34.png?Uexu",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch2-wuGkXV6PbAhek8PI8QmClEcb2RWQNs.png?vrAB",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch3-VJR80WmbDycduGMWQoDAcXwVzUGb0k.png?npHD",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch2-wuGkXV6PbAhek8PI8QmClEcb2RWQNs.png?vrAB",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch1-p2MLYFtyBu70EfEzX38RisTZlDPz34.png?Uexu",
        ],

        // State tracking
        state: {
          currentState: "hidden",
          frameIndex: 0,
          cyclesCompleted: 0,
          targetCycles: 2,
          lastFrameUpdate: 0,
          frameInterval: 150,
          bobOffset: 0,
          bobDirection: 1,
          bobSpeed: 0.05,
          spacebarPressCount: 0,
          finalFrame: 2, // Glitch3
          position: { x: 14, y: 11 },
          isVisible: false,
          onCompleteCallback: null,
          dialogueTriggerId: null,
          framesInCycle: 5, // Number of frames in one complete cycle
        },

        // Initialize the manager
        init() {
          // Prevent multiple initializations
          if (this.isInitialized) {
            console.log("🔍 DEBUG: GlitchNPCManager already initialized, skipping");
            return;
          }
          
          console.log("🔍 DEBUG: Initializing GlitchNPCManager");
          this.preloadFrames();

          // Listen for spacebar events to track dialogue progression
          document.addEventListener("keydown", (event) => {
            if (event.code === "Space" && DialogueSystem.isActive) {
              this.handleSpacebarPress();
            }
          });

          // Listen for dialogue end
          const originalEndDialogue = DialogueSystem.endDialogue;
          DialogueSystem.endDialogue = function () {
            originalEndDialogue.apply(this, arguments);
            GlitchNPCManager.handleDialogueEnd();
          };
          
          // Mark as initialized
          this.isInitialized = true;
        },

        // Preload all animation frames
        preloadFrames() {
          this.frameImages = [];
          this.frames.forEach((frameSrc, index) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = frameSrc;
            img.onload = () => console.log(`🔍 DEBUG: Glitch frame ${index} loaded`);
            img.onerror = () => console.error(`🔍 ERROR: Failed to load Glitch frame ${index}`);
            this.frameImages[index] = img;
          });
        },

        // Track spacebar presses during dialogue
        // NOTE: This method should no longer be called directly by DialogueSystem
        // The counter is now managed directly in DialogueSystem.nextMessage
        handleSpacebarPress() {
          // We don't need to increment the counter here anymore 
          // as it's already being incremented in the DialogueSystem
          
          console.log(`🔍 DEBUG: Direct call to handleSpacebarPress with current count ${this.state.spacebarPressCount}`);

          // Still handle the 4th press case if somehow this gets called directly
          if (this.state.spacebarPressCount === 4 && 
              !GameStateManager.state.relics?.glitchStickClaimed) {
            console.log(`🔍 DEBUG: Triggering special animation on 4th spacebar press`);
            
            // Remove any existing NPC before creating a new one
            this.remove();
            
            // Force immediate animation without setTimeout
            this.playSpecialAnimation();
            
            // Make sure the NPC is visible during dialogue
            if (GameStateManager.state.glitchNPC) {
              // These are the critical settings to ensure animation plays during dialogue
              GameStateManager.state.glitchNPC.isVisible = true;
              GameStateManager.state.glitchNPC.frameIndex = 0;
              GameStateManager.state.glitchNPC.lastFrameUpdate = 0; // Force immediate frame update
              GameStateManager.state.glitchNPC.animationState = this.STATES.SPECIAL_ANIMATION;
              
              // Force the animation update to run immediately
              this.updateSpecialAnimation(Date.now());
              
              console.log(`🔍 DEBUG: Forced NPC visibility and animation during dialogue`);
            } else {
              console.log(`🔍 DEBUG: Failed to create Glitch NPC on spacebar press 4`);
            }
          }
        },

        // Handle dialogue end
        handleDialogueEnd() {
          console.log("🔍 DEBUG: Dialogue ended");
          
          // Only process in arcade1 scene
          if (GameStateManager.state.currentScene !== "arcade1") {
            console.log("🔍 DEBUG: Not in arcade1 scene, skipping Glitch NPC actions");
            // Make sure player can move again
            GameStateManager.state.playerCanMove = true;
            return;
          }

          // If this is the FIRST dialogue completion (glitch stick not yet claimed)
          if (!GameStateManager.state.relics?.glitchStickClaimed) {
            console.log("🔍 DEBUG: First dialogue completion, dismissing Glitch NPC with animation");
            
            // Dismiss the Glitch NPC with animation if it exists
            if (GameStateManager.state.glitchNPC) {
              // Set a short timer to make the dismissal more dramatic
              setTimeout(() => {
                // Flash and remove the NPC
                this.dismissWithAnimation();
                UIManager.log("The glitching entity vanishes in a flash of light...");
                
                // Make sure player can move after the animation completes
                setTimeout(() => {
                  // Make absolutely sure the NPC is gone
                  this.remove();
                  GameStateManager.state.playerCanMove = true;
                  
                  // Prevent any further animation by forcing the state to HIDDEN
                  this.state.currentState = this.STATES.HIDDEN;
                  this.state.isVisible = false;
                  
                  console.log("🔍 DEBUG: Re-enabled player movement after Glitch dismissal");
                }, 1000); // Give enough time for the dismissal animation to complete
              }, 500);
            } else {
              // If no NPC, still make sure player can move
              GameStateManager.state.playerCanMove = true;
            }
          } else {
            console.log("🔍 DEBUG: Second dialogue completion, no Glitch NPC actions needed");
            // For the second dialogue interaction, we don't want Glitch to appear at all
            this.remove();
            
            // Double-check that no glitch NPC exists or will be created
            this.state.currentState = this.STATES.HIDDEN;
            this.state.isVisible = false;
            this.state.spacebarPressCount = 0; // Reset counter too
            
            // Make sure player can move again
            GameStateManager.state.playerCanMove = true;
          }
          
          console.log("🔍 DEBUG: Dialogue end processing complete");
        },
        // Remove all instances of Glitch NPCs
        remove() {
          console.log("🔍 DEBUG: Removing all Glitch NPCs");
          
          // Remove from game state if it exists
          if (GameStateManager.state.npcs) {
            GameStateManager.state.npcs = GameStateManager.state.npcs.filter(npc => npc.type !== "GlitchNPC");
          }
          
          // Clear direct reference
          GameStateManager.state.glitchNPC = null;
          
          // Reset our state
          this.state.isVisible = false;
          this.state.currentState = this.STATES.HIDDEN;
          
          // Clear from DOM if any visual elements exist
          const existingElements = document.querySelectorAll('.glitch-npc');
          if (existingElements.length > 0) {
            existingElements.forEach(element => {
              element.remove();
            });
          }
          
          console.log("🔍 DEBUG: All Glitch NPCs removed");
        },
        
        // Summon the Glitch NPC with options
        summon(options = {}) {
          // Initialize if not already done
          if (!this.isInitialized) {
            this.init();
          }
          
          // Remove any existing Glitch NPCs first to avoid duplicates
          this.remove();
          
          const defaults = {
            position: { x: 11, y: 9 },
            animation: "appear",
            dialogueTrigger: null,
            dismissAfterDialogue: true,
            cycles: 2,
            onComplete: null,
            frameInterval: 150,
          };

          const config = { ...defaults, ...options };
          
          console.log(`🔍 DEBUG: Preparing to summon Glitch NPC with ${config.cycles} animation cycles`);

          // Reset state completely
          this.state = {
            currentState: "hidden",
            frameIndex: 0,
            cyclesCompleted: 0,
            targetCycles: config.cycles,
            lastFrameUpdate: 0,
            frameInterval: config.frameInterval || 150,
            bobOffset: 0,
            bobDirection: 1,
            bobSpeed: 0.05,
            spacebarPressCount: 0,
            finalFrame: 2, // Glitch3
            position: config.position,
            isVisible: true,
            onCompleteCallback: config.onComplete,
            dialogueTriggerId: config.dialogueTrigger,
            framesInCycle: this.frames.length, // Number of frames in one complete cycle
          };

          // Create or update the NPC object
          this.createGlitchNPC();

          console.log(`🔍 DEBUG: Summoned Glitch NPC at (${config.position.x}, ${config.position.y})`);

          // If we have a dialogue trigger, reset spacebar count
          if (config.dialogueTrigger) {
            this.state.spacebarPressCount = 0;
          }

          // Start with appearance animation
          if (config.animation === "appear") {
            this.changeState(this.STATES.APPEARING);
          } else if (config.animation === "special") {
            this.changeState(this.STATES.SPECIAL_ANIMATION);
            this.state.frameIndex = 0;
            this.state.cyclesCompleted = 0;
            this.state.lastFrameUpdate = 0; // Force immediate update
          } else {
            this.changeState(this.STATES.IDLE);
          }

          return this;
        },

        // Play the special animation sequence
        playSpecialAnimation() {
          console.log("🔍 DEBUG: Playing Glitch special animation");
          
          // Only proceed if we're at the 4th spacebar press in the first dialogue
          // This check is now intentionally commented out as we WANT to show the animation
          // when called from handleSpacebarPress (which only calls on the 4th press)
          
          // First ensure we don't have any existing NPCs
          this.remove();
          
          // IMPORTANT: Preserve the spacebar count
          const savedSpacebarCount = this.state.spacebarPressCount;
          
          // Set up all state parameters for the animation
          this.state = {
            currentState: this.STATES.SPECIAL_ANIMATION,
            frameIndex: 0,                // Start at the first frame
            cyclesCompleted: 0,           // Start a fresh animation cycle
            targetCycles: 2,              // Complete 2 full cycles
            lastFrameUpdate: Date.now() - 1000, // Force immediate first frame
            frameInterval: 150,           // Speed of animation in ms
            bobOffset: 0,
            bobDirection: 1,
            bobSpeed: 0.05,
            spacebarPressCount: savedSpacebarCount, // Restore the spacebar count
            finalFrame: 2,                // Glitch3 frame
            position: { x: 11, y: 9 },    // Fixed position
            isVisible: true,              // Must be visible
            framesInCycle: this.frames.length, // Number of frames in a complete cycle
          };
          
          // Create a single NPC instance
          const glitchNPC = this.createGlitchNPC();
          
          // Force full visibility 
          if (GameStateManager.state.glitchNPC) {
            GameStateManager.state.glitchNPC.isVisible = true;
            GameStateManager.state.glitchNPC.frameIndex = 0; // Start at the first frame
            
            // Force animation state on the NPC
            GameStateManager.state.glitchNPC.animationState = this.STATES.SPECIAL_ANIMATION;
            
            // Log success
            console.log("🔍 DEBUG: Successfully created and configured Glitch NPC for animation");
          } else {
            console.log("🔍 ERROR: Failed to create Glitch NPC in playSpecialAnimation!");
          }
          
          // Add a visual message
          UIManager.log("A strange glitching entity appears in the arcade...");
          
          return this;
        },
        
        // Set the animation state and handle state transitions
        changeState(newState) {
          const oldState = this.state.currentState;
          this.state.currentState = newState;
          console.log(`🔍 DEBUG: Glitch state changed from ${oldState} to ${newState}`);
          
          // Reset frame index when changing states
          if (oldState !== newState) {
            this.state.frameIndex = 0;
            this.state.cyclesCompleted = 0;
          }
        },

        // Dismiss with animation
        dismissWithAnimation() {
          console.log("🔍 DEBUG: Dismissing Glitch with animation");
          
          // Make sure we have an NPC to dismiss
          if (!GameStateManager.state.glitchNPC) {
            console.log("🔍 DEBUG: No Glitch NPC to dismiss");
            return this;
          }
          
          // Set animation state
          this.changeState(this.STATES.DISMISSING);
          this.state.frameIndex = 0;
          this.state.cyclesCompleted = 0;
          
          // Create a flash effect
          const createFlash = () => {
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) return;
            
            // Create a flash overlay
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = 'white';
            flash.style.opacity = '0.7';
            flash.style.zIndex = '1000';
            flash.style.pointerEvents = 'none';
            flash.style.animation = 'flashFade 0.5s forwards';
            
            // Add a CSS animation
            const style = document.createElement('style');
            style.textContent = `
              @keyframes flashFade {
                0% { opacity: 0.7; }
                100% { opacity: 0; }
              }
            `;
            document.head.appendChild(style);
            
            // Add to DOM
            document.body.appendChild(flash);
            
            // Remove after animation
            setTimeout(() => {
              flash.remove();
              style.remove();
            }, 500);
          };
          
          // Run a quick animation cycle and then remove with flash effect
          setTimeout(() => {
            createFlash();
            this.remove();
          }, 500);

          return this;
        },

        // Create the Glitch NPC sprite and add it to the game
        createGlitchNPC() {
          console.log(`🔍 DEBUG: Creating fresh Glitch NPC at position (${this.state.position.x}, ${this.state.position.y})`);
          
          // We no longer call this.remove() here since it creates infinite recursion
          // Remove any existing Glitch NPCs directly from game state
          if (GameStateManager.state.npcs) {
            GameStateManager.state.npcs = GameStateManager.state.npcs.filter(npc => npc.type !== "GlitchNPC");
          }
          
          // Ensure NPCs array exists
          if (!GameStateManager.state.npcs) {
            GameStateManager.state.npcs = [];
          }
          
          // Always use position 11,9 for consistency
          if (!this.state.position || this.state.position.x !== 11 || this.state.position.y !== 9) {
            console.log(`🔍 DEBUG: Enforcing correct position (11,9) for Glitch NPC`);
            this.state.position = { x: 11, y: 9 };
          }
          
          // Only create the NPC if we're actually in a state where it should be visible
          // Don't create if it's hidden or we haven't reached the 4th spacebar press yet
          if (this.state.currentState === this.STATES.HIDDEN && this.state.spacebarPressCount < 4) {
            console.log(`🔍 DEBUG: Skipping NPC creation - hidden state or before 4th spacebar press`);
            return null;
          }
          
          // Create a new NPC with animation state already set up
          const glitchNPC = {
            x: 11,
            y: 9,
            type: "GlitchNPC",
            name: "Glitch",
            frameImages: this.frameImages,
            frameIndex: 0, // Always start at first frame
            animationState: this.STATES.SPECIAL_ANIMATION, // Always start with animation
            bobOffset: 0,
            bobDirection: 1,
            bobSpeed: 0.05,
            lastFrameUpdate: Date.now() - 1000, // Force immediate update
            frameInterval: 180,
            isVisible: true,
            uniqueId: `glitch-${Date.now()}`
          };

          // Add to game state
          GameStateManager.state.npcs.push(glitchNPC);
          GameStateManager.state.glitchNPC = glitchNPC;
          
          console.log(`🔍 DEBUG: Created animated Glitch NPC at (11,9) in state ${this.state.currentState}`);
          return glitchNPC;
        },

        // Update the animation state
        update() {
          if (!this.state.isVisible) return;

          const now = Date.now();
          let glitchNPC = GameStateManager.state.glitchNPC;
          
          // If no NPC exists but we're supposed to be visible, create one
          if (!glitchNPC && this.state.isVisible && this.state.currentState !== this.STATES.HIDDEN) {
            console.log("🔍 DEBUG: NPC missing but should be visible, recreating");
            glitchNPC = this.createGlitchNPC();
          }
          
          // Safety check - if still no NPC, exit
          if (!glitchNPC) return;
          
          // First check if there are any duplicate NPCs and clean them up
          if (GameStateManager.state.npcs) {
            const glitchNPCs = GameStateManager.state.npcs.filter(npc => npc.type === "GlitchNPC");
            if (glitchNPCs.length > 1) {
              console.log(`🔍 CLEANUP: Found ${glitchNPCs.length} Glitch NPCs during update, cleaning duplicates`);
              // Keep only the first one
              GameStateManager.state.npcs = GameStateManager.state.npcs.filter(npc => npc.type !== "GlitchNPC");
              GameStateManager.state.npcs.push(glitchNPCs[0]);
              GameStateManager.state.glitchNPC = glitchNPCs[0];
              glitchNPC = glitchNPCs[0];
            } else if (glitchNPCs.length === 0) {
              console.log(`🔍 ERROR: No Glitch NPCs found in npcs array but manager is active. Recreating...`);
              this.createGlitchNPC();
              glitchNPC = GameStateManager.state.glitchNPC;
            }
          }

          // If NPC doesn't exist after cleanup checks, recreate it
          if (!glitchNPC) {
            console.log(`🔍 ERROR: Still no glitchNPC found in GameStateManager state. Recreating...`);
            this.createGlitchNPC();
            glitchNPC = GameStateManager.state.glitchNPC;
            if (!glitchNPC) {
              console.log(`🔍 CRITICAL ERROR: Failed to create Glitch NPC`); 
              return; // Cannot proceed without NPC
            }
          }
          
          // Ensure NPC visibility matches our state
          glitchNPC.isVisible = this.state.isVisible;
          
          // Force the NPC to use the animation state from the manager
          glitchNPC.animationState = this.state.currentState;
          
          // Based on the current state, update the appropriate animation
          if (this.state.currentState === this.STATES.SPECIAL_ANIMATION) {
            this.updateSpecialAnimation(now);
          } else if (this.state.currentState === this.STATES.BOBBING) {
            this.updateBobbingAnimation();
          } else if (this.state.currentState === this.STATES.DISMISSING) {
            this.updateDismissAnimation();
          } else if (this.state.currentState === this.STATES.APPEARING) {
            this.updateAppearAnimation();
          }
          
          // Check if we're in special animation and have completed cycles (safety check)
          if (this.state.currentState === this.STATES.SPECIAL_ANIMATION && 
              this.state.cyclesCompleted >= this.state.targetCycles) {
            console.log(`🔍 FIXUP: Found NPC in special animation with ${this.state.cyclesCompleted}/${this.state.targetCycles} cycles complete - forcing bobbing state`);
            this.state.currentState = this.STATES.BOBBING;
            this.state.frameIndex = this.state.finalFrame;
            glitchNPC.animationState = this.STATES.BOBBING;
            glitchNPC.frameIndex = this.state.finalFrame;
          }
          
          // Sync with the NPC after any state updates
          this.syncWithNPC();
          
          // Print debug information (less frequently to avoid console spam)
          if (now % 5000 < 50) { // Log approximately once every 5 seconds
            console.log(`🔍 ANIM DEBUG: Glitch state=${this.state.currentState}, frame=${this.state.frameIndex}, cycles=${this.state.cyclesCompleted}/${this.state.targetCycles}`);
          }
        },
        
        // Update the special frame animation sequence
        updateSpecialAnimation(now) {
          // IMPORTANT: We've removed the spacebar check here because by the time we call this method,
          // the animation should already be playing (as checked in handleSpacebarPress)
          // This ensures the animation will progress regardless of state
          
          const timeElapsed = now - this.state.lastFrameUpdate;
          
          // If we're in a special animation, update frame based on interval
          if (timeElapsed >= this.state.frameInterval) {
            // Get the current frame index and increment it
            const currentFrame = this.state.frameIndex;
            const nextFrame = (currentFrame + 1) % this.frames.length;

            // Update frame index
            this.state.frameIndex = nextFrame;
            this.state.lastFrameUpdate = now;

            // Ensure the NPC is visible during animation
            if (GameStateManager.state.glitchNPC) {
              GameStateManager.state.glitchNPC.isVisible = true;
              GameStateManager.state.glitchNPC.frameIndex = nextFrame;
            }

            // Debug log for animation tracking (less frequent)
            if (now % 1000 < 50) { // Only log occasionally to reduce spam
              console.log(`🔍 FRAME DEBUG: Changed to frame ${nextFrame} (${this.frames.length} total frames)`);
            }

            // If we've completed a full cycle (returned to frame 0)
            if (nextFrame === 0) {
              this.state.cyclesCompleted++;
              console.log(`🔍 DEBUG: Animation cycle completed (${this.state.cyclesCompleted}/${this.state.targetCycles})`);

              // If we've completed the target number of cycles, transition to bobbing
              if (this.state.cyclesCompleted >= this.state.targetCycles) {
                console.log(`🔍 DEBUG: All ${this.state.targetCycles} cycles completed! Transitioning to bobbing.`);
                
                // Set to the final frame (Glitch3, usually index 2)
                this.state.frameIndex = this.state.finalFrame || 2;
                
                // Important: Explicitly change state to bobbing
                this.changeState(this.STATES.BOBBING);
                
                // Update the NPC immediately
                if (GameStateManager.state.glitchNPC) {
                  GameStateManager.state.glitchNPC.frameIndex = this.state.finalFrame || 2;
                  GameStateManager.state.glitchNPC.animationState = this.STATES.BOBBING;
                }
                
                // Force sync to ensure the change takes effect immediately
                this.syncWithNPC();
                
                // Double-check after a small delay to ensure the state transition persisted
                setTimeout(() => {
                  if (this.state.currentState !== this.STATES.BOBBING) {
                    console.log(`🔍 DEBUG: State didn't persist, forcing bobbing state again`);
                    this.changeState(this.STATES.BOBBING);
                    this.syncWithNPC();
                  }
                }, 100);
              }
            }
          }
        },

        // Update the bobbing animation
        updateBobbingAnimation() {
          // Only animate if we completed the special animation first
          // AND we're after the 4th spacebar press
          if (this.state.spacebarPressCount < 4 || 
              (this.state.currentState === this.STATES.SPECIAL_ANIMATION && 
               this.state.cyclesCompleted < this.state.targetCycles)) {
            return;
          }
        
          this.state.bobOffset += this.state.bobSpeed * this.state.bobDirection;
          
          // Reverse direction when reaching limits
          if (this.state.bobOffset > 2 || this.state.bobOffset < -2) {
            this.state.bobDirection *= -1;
          }
          
          // Apply the bobbing effect to the NPC sprite if it exists
          if (GameStateManager.state.glitchNPC) {
            GameStateManager.state.glitchNPC.bobOffset = this.state.bobOffset;
          }
        },

        // Update the dismissal animation
        updateDismissAnimation() {
          // Fade out animation (reverse of appearance)
          this.state.frameIndex = (this.state.frameIndex + 1) % this.frames.length;

          // If we went through all frames twice, make it invisible
          if (this.state.frameIndex === 0) {
            this.state.cyclesCompleted++;
            if (this.state.cyclesCompleted >= 2) {
              this.state.isVisible = false;
            }
          }
        },

        // Update appearance animation
        updateAppearAnimation() {
          // Use the normal animation sequence, but go to special animation
          // to ensure we run through all frames twice
          this.state.frameIndex = (this.state.frameIndex + 1) % this.frames.length;

          if (this.state.frameIndex === 0) {
            // Once we complete one cycle, move to special animation instead of idle
            this.changeState(this.STATES.SPECIAL_ANIMATION);
            this.state.frameIndex = 0;
            this.state.cyclesCompleted = 1; // Count this as first cycle completed
          }
        },

        // Sync our state with the NPC object
        syncWithNPC() {
          let glitchNPC = GameStateManager.state.glitchNPC;
          
          // If it doesn't exist, create it
          if (!glitchNPC) {
            console.log(`🔍 ERROR: Cannot sync - glitchNPC not found in GameStateManager state, creating new one`);
            this.createGlitchNPC();
            glitchNPC = GameStateManager.state.glitchNPC;
            if (!glitchNPC) {
              console.log(`🔍 CRITICAL ERROR: Failed to create Glitch NPC during sync`);
              return; // Cannot proceed
            }
          }

          // Apply all of our state properties to the NPC object
          glitchNPC.frameIndex = this.state.frameIndex;
          glitchNPC.animationState = this.state.currentState;
          glitchNPC.bobOffset = this.state.bobOffset;
          glitchNPC.bobDirection = this.state.bobDirection;
          glitchNPC.isVisible = this.state.isVisible;
          glitchNPC.frameInterval = this.state.frameInterval;
          glitchNPC.x = this.state.position.x;
          glitchNPC.y = this.state.position.y;
          
          // Update the timestamp for animation timing
          glitchNPC.lastFrameUpdate = Date.now();
          
          // Force frame image update
          if (this.frameImages && this.frameImages.length > 0) {
            glitchNPC.frameImages = this.frameImages;
          }
          
          // Special handling for bobbing state - always use the final frame
          if (this.state.currentState === this.STATES.BOBBING) {
            glitchNPC.frameIndex = this.state.finalFrame;
            // Make sure we're still in the GameStateManager's npcs array
            if (GameStateManager.state.npcs) {
              const found = GameStateManager.state.npcs.some(npc => npc === glitchNPC);
              if (!found) {
                console.log(`🔍 ERROR: Glitch NPC not in NPCs array during sync, adding it back`);
                GameStateManager.state.npcs.push(glitchNPC);
              }
            }
          }
          
          // Log sync operations (only for important frames to avoid console spam)
          if (this.state.frameIndex === 0 || this.state.frameIndex === this.state.finalFrame || this.state.currentState === this.STATES.BOBBING) {
            console.log(`🔍 SYNC DEBUG: NPC synced with frame ${this.state.frameIndex}, state ${this.state.currentState}, visible: ${this.state.isVisible}`);
          }
        },

        // Change state with logging
        changeState(newState) {
          console.log(`🔍 DEBUG: Glitch state change: ${this.state.currentState} -> ${newState}`);
          this.state.currentState = newState;

          // Reset relevant state variables
          if (newState === this.STATES.SPECIAL_ANIMATION || newState === this.STATES.APPEARING) {
            this.state.frameIndex = 0;
            this.state.cyclesCompleted = 0;
            this.state.lastFrameUpdate = 0; // Force immediate update
          }
          
          // When entering bobbing state, ensure we're on the right frame
          if (newState === this.STATES.BOBBING) {
            this.state.frameIndex = this.state.finalFrame;
          }
          
          // Apply state change to the NPC object immediately
          this.syncWithNPC();
        },

        // Get the current frame image
        getCurrentFrame() {
          return this.frameImages[this.state.frameIndex];
        },

        // Completely remove the NPC
        remove() {
          console.log("🔍 DEBUG: Removing Glitch NPC completely");
          this.state.isVisible = false;
          this.state.currentState = this.STATES.HIDDEN;

          // Remove from npcs array
          if (GameStateManager.state.npcs) {
            GameStateManager.state.npcs = GameStateManager.state.npcs.filter((npc) => npc.type !== "GlitchNPC");
          }

          // Remove direct reference
          GameStateManager.state.glitchNPC = null;

          // Call completion callback if provided
          if (typeof this.state.onCompleteCallback === "function") {
            this.state.onCompleteCallback();
          }
        },
      };

      // UI Management
      const UIManager = {
        elements: null,

        init() {
          // Cache DOM elements
          this.elements = {
            hp: document.getElementById("hp"),
            mp: document.getElementById("mp"),
            gold: document.getElementById("goldAmount"),
            xp: document.getElementById("xp"),
            level: document.getElementById("level"),
            gameLog: document.getElementById("gameLog"),
            characterScreen: document.getElementById("characterScreen"),
            startScreen: document.getElementById("startScreen"),
            characterSelect: document.getElementById("characterSelect"),
            inventoryScreen: document.getElementById("inventoryScreen"),
            inventoryList: document.getElementById("inventoryList"),
            // Character screen elements
            charStrength: document.getElementById("char-strength"),
            charIntelligence: document.getElementById("char-intelligence"),
            charVitality: document.getElementById("char-vitality"),
            charDexterity: document.getElementById("char-dexterity"),
            charFortune: document.getElementById("char-fortune"),
            charCharisma: document.getElementById("char-charisma"),
            strengthFill: document.getElementById("strength-fill"),
            intelligenceFill: document.getElementById("intelligence-fill"),
            vitalityFill: document.getElementById("vitality-fill"),
            dexterityFill: document.getElementById("dexterity-fill"),
            fortuneFill: document.getElementById("fortune-fill"),
            charismaFill: document.getElementById("charisma-fill"),
            charCurrentHp: document.getElementById("char-current-hp"),
            charMaxHp: document.getElementById("char-max-hp"),
            charCurrentMp: document.getElementById("char-current-mp"),
            charMaxMp: document.getElementById("char-max-mp"),
            charCurrentXp: document.getElementById("char-current-xp"),
            charNextLevelXp: document.getElementById("char-next-level-xp"),
            hpFill: document.getElementById("hp-fill"),
            mpFill: document.getElementById("mp-fill"),
            xpFill: document.getElementById("xp-fill"),
          };

          // Ensure game log is hidden during initialization
          if (this.elements.gameLog) {
            this.elements.gameLog.style.display = "none";
          }

          // Ensure inventory screen is hidden during initialization
          if (this.elements.inventoryScreen) {
            this.elements.inventoryScreen.style.display = "none";
          }
        },

        log(message) {
          if (!this.elements) this.init();

          // Create timestamp
          const now = new Date();
          const timestamp = `${now.getHours().toString().padStart(2, "0")}:${now.getMinutes().toString().padStart(2, "0")}:${now.getSeconds().toString().padStart(2, "0")}`;

          // If in battle, send to battle message area instead
          if (GameStateManager.state.currentState === GAME_STATES.BATTLE) {
            BattleSystem.displayBattleMessage(`[${timestamp}] ${message}`);
            return;
          }

          // Only add to game log if not in battle
          const entry = document.createElement("div");
          entry.textContent = `[${timestamp}] ${message}`;
          entry.style.color = "#00ffff";
          entry.style.marginBottom = "5px";

          this.elements.gameLog.appendChild(entry);
          this.elements.gameLog.scrollTop = this.elements.gameLog.scrollHeight;

          // Only show game log if manually toggled with 'M'
          if (this._isManuallyToggled) {
            this.elements.gameLog.style.display = "block";
          } else {
            this.elements.gameLog.style.display = "none";
          }
        },

        update() {
          if (!this.elements) this.init();
          if (!GameStateManager.state.player) return;

          const player = GameStateManager.state.player;

          // Add null checks for each element
          if (this.elements.hp) this.elements.hp.textContent = player.hp;
          if (this.elements.mp) this.elements.mp.textContent = player.mp;
          if (this.elements.gold) this.elements.gold.textContent = player.gold;
          if (this.elements.xp) this.elements.xp.textContent = player.xp;
          if (this.elements.level) this.elements.level.textContent = player.level;
        },

        showGameScreen() {
          if (!this.elements) this.init();
          this.elements.startScreen.style.display = "none";
          this.elements.characterSelect.style.display = "none";
          this.elements.gameLog.style.display = "none";
          this.update();
        },

        toggleCharacterScreen() {
          if (!this.elements) this.init();
          const isHidden =
            this.elements.characterScreen.style.display === "none" || !this.elements.characterScreen.style.display;
          this.elements.characterScreen.style.display = isHidden ? "block" : "none";
          GameStateManager.state.isPaused = isHidden;

          if (isHidden) {
            // Force stats tab to be active when opening the screen
            const statsTab = this.elements.characterScreen.querySelector('[data-tab="stats-tab"]');
            if (statsTab) {
              statsTab.click();
            }
            this.updateCharacterScreen();
          }
        },

        toggleInventoryScreen() {
          if (!this.elements) this.init();
          const isHidden =
            this.elements.inventoryScreen.style.display === "none" || !this.elements.inventoryScreen.style.display;
          this.elements.inventoryScreen.style.display = isHidden ? "block" : "none";
          GameStateManager.state.isPaused = isHidden;

          if (isHidden) {
            this.updateInventoryUI();
          }
        },

        toggleMessages() {
          const gameLog = document.getElementById("gameLog");
          if (!gameLog) return;

          if (gameLog.style.display === "none" || gameLog.style.display === "") {
            gameLog.style.display = "block";
            UIManager._isManuallyToggled = true;
          } else {
            gameLog.style.display = "none";
            UIManager._isManuallyToggled = false;
          }
        },

        updateCharacterScreen() {
          const characterScreen = document.getElementById("characterScreen");
          if (!characterScreen) return;

          const player = GameStateManager.state.player;
          if (!player) return;

          // Get current active tab
          const currentTab = characterScreen.querySelector(".tab-button.active");
          const currentTabId = currentTab ? currentTab.getAttribute("data-tab") : "equipment-tab";

          // Create the base structure
          characterScreen.innerHTML = `
                    <div class="character-screen-content" style="margin-top: 1px;">
                        <div class="character-header" style="margin: 0 0 -5px 0;">
                            <h2 style="margin: 0 0 2px 0;">${player.name}</h2>
                            <p style="margin: 0 0 2px 0;">Level ${player.level} ${player.class}</p>
                            <div class="character-portrait" style="padding: 2px 2px 2px 2px; margin: 2px auto 0 auto;">
                                <img src="${player.sprite || "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flexecutioner-YTnx5DSfVR0ALUTlZc9Kt5xLlJFP4m.png?DUxz"}" alt="${player.class} portrait" style="width: 64px; height: 64px;">
                            </div>
                        </div>
                        <div class="tab-navigation" style="margin-top: -10px;">
                            <button class="tab-button ${currentTabId === "stats-tab" ? "active" : ""}" data-tab="stats-tab">Stats</button>
                            <button class="tab-button ${currentTabId === "equipment-tab" ? "active" : ""}" data-tab="equipment-tab">Equipment</button>
                            <button class="tab-button ${currentTabId === "items-tab" ? "active" : ""}" data-tab="items-tab">Items</button>
                            <button class="tab-button ${currentTabId === "skills-tab" ? "active" : ""}" data-tab="skills-tab">Skills</button>
                            <button class="tab-button ${currentTabId === "spells-tab" ? "active" : ""}" data-tab="spells-tab">Spells</button>
                            <button class="tab-button ${currentTabId === "relics-tab" ? "active" : ""}" data-tab="relics-tab">Relics</button>
                        </div>
                        <div class="tab-content active" id="stats-tab">
                            <div class="stats-grid">
                                <div class="stat-box">
                                    <span class="stat-label">Strength</span>
                                    <span class="stat-controls">
                                        <button class="stat-button minus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'strength', -1)">-</button>
                                        <span class="stat-value">${player.stats.strength}</span>
                                        <button class="stat-button plus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'strength', 1)">+</button>
                                    </span>
                                </div>
                                <div class="stat-box">
                                    <span class="stat-label">Intelligence</span>
                                    <span class="stat-controls">
                                        <button class="stat-button minus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'intelligence', -1)">-</button>
                                        <span class="stat-value">${player.stats.intelligence}</span>
                                        <button class="stat-button plus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'intelligence', 1)">+</button>
                                    </span>
                                </div>
                                <div class="stat-box">
                                    <span class="stat-label">Vitality</span>
                                    <span class="stat-controls">
                                        <button class="stat-button minus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'vitality', -1)">-</button>
                                        <span class="stat-value">${player.stats.vitality}</span>
                                        <button class="stat-button plus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'vitality', 1)">+</button>
                                    </span>
                                </div>
                                <div class="stat-box">
                                    <span class="stat-label">Dexterity</span>
                                    <span class="stat-controls">
                                        <button class="stat-button minus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'dexterity', -1)">-</button>
                                        <span class="stat-value">${player.stats.dexterity}</span>
                                        <button class="stat-button plus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'dexterity', 1)">+</button>
                                    </span>
                                </div>
                                <div class="stat-box">
                                    <span class="stat-label">Fortune</span>
                                    <span class="stat-controls">
                                        <button class="stat-button minus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'fortune', -1)">-</button>
                                        <span class="stat-value">${player.stats.fortune}</span>
                                        <button class="stat-button plus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'fortune', 1)">+</button>
                                    </span>
                                </div>
                                <div class="stat-box">
                                    <span class="stat-label">Charisma</span>
                                    <span class="stat-controls">
                                        <button class="stat-button minus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'charisma', -1)">-</button>
                                        <span class="stat-value">${player.stats.charisma}</span>
                                        <button class="stat-button plus" onclick="LEVELING_SYSTEM.allocateStatPoint(GameStateManager.state.player, 'charisma', 1)">+</button>
                                    </span>
                                </div>
                            </div>
                            <div class="progress-stats">
                                <div class="progress-stat">
                                    <div class="progress-label">
                                        <span>Health</span>
                                        <span>${player.hp}/${player.derivedStats?.maxHp}</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div class="hp-fill" style="width: ${(player.hp / player.derivedStats?.maxHp) * 100}%"></div>
                                    </div>
                                </div>
                                <div class="progress-stat">
                                    <div class="progress-label">
                                        <span>Magic</span>
                                        <span>${player.mp}/${player.derivedStats?.maxMp}</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div class="mp-fill" style="width: ${(player.mp / player.derivedStats?.maxMp) * 100}%"></div>
                                    </div>
                                </div>
                                <div class="progress-stat">
                                    <div class="progress-label">
                                        <span>Experience</span>
                                        <span>${player.xp}/${player.xpToNextLevel}</span>
                                    </div>
                                    <div class="progress-bar">
                                        <div class="xp-fill" style="width: ${(player.xp / player.xpToNextLevel) * 100}%"></div>
                                    </div>
                                </div>
                                <div class="progress-stat">
                                    <div class="progress-label">
                                        <span>Stat Points</span>
                                        <span>${player.statPoints}</span>
                                    </div>
                                </div>
                                <div class="progress-stat">
                                    <div class="progress-label">
                                        <span>Gold</span>
                                        <span style="color: #ffd700;">${player.gold || 0}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="menu-buttons">
                                <button class="menu-button" onclick="saveGame()">Save</button>
                                <button class="menu-button" onclick="loadGame()">Load</button>
                                ${player.statPoints === 0 && !player.statsLocked ? '<button class="menu-button confirm" onclick="confirmStatAllocation()">Confirm</button>' : ""}
                            </div>
                        </div>
                        <div class="tab-content" id="equipment-tab">
                            <div class="equipment-screen-content">
                                <div class="equipment-list">
                                    <!-- All equipment slots using fixed array including relic slots, with case-insensitivity -->
                                    ${['main_hand', 'off_hand', 'head', 'body', 'legs', 'feet', 'relic_1', 'relic_2'].map(slot => {
                                        // Find the item regardless of case by checking all equipment slots
                                        let item = player.equipment[slot];
                                        
                                        // If no exact match, try case-insensitive match
                                        if (!item && player.equipment) {
                                            const upperSlot = slot.toUpperCase();
                                            for (const [equipSlot, equipItem] of Object.entries(player.equipment)) {
                                                if (equipSlot.toUpperCase() === upperSlot) {
                                                    item = equipItem;
                                                    break;
                                                }
                                            }
                                        }
                                        
                                        const isRelic = slot.startsWith('relic_');
                                        const displaySlot = isRelic ? (slot === 'relic_1' ? 'Relic 1' : 'Relic 2') : slot.replace(/_/g, " ");
                                        
                                        return `
                                    <div class="equipment-item ${isRelic ? 'custom-relic-slot' : ''}" 
                                        data-slot="${slot}"
                                        onmouseover="showEquipmentInfo('${slot}', ${item ? JSON.stringify(item).replace(/"/g, "&quot;") : null})"
                                        onmouseout="hideEquipmentInfo()"
                                        onclick="${item ? (isRelic ? `toggleRelicEquip('${item.relicId}')` : `EquipmentManager.unequip(GameStateManager.state.player, '${slot}')`) : ''}"
                                    >
                                        <span class="slot-label">${displaySlot}</span>
                                        ${item
                                            ? isRelic 
                                                ? `<div class="item">
                                                    <span class="item-name relic-name" title="${item.name} (Level ${item.level}) - Click to unequip">${item.name}</span>
                                                  </div>` 
                                                : `<div class="item"><span class="item-name" title="${item.name}">${getItemAcronym(item.name)}</span></div>`
                                            : '<span class="empty-slot">Empty</span>'
                                        }
                                    </div>
                                        `;
                                    }).join('')}
                                </div>
                                <div class="equipment-tooltip" id="equipmentTooltip">
                                    <div class="title">Equipment Information</div>
                                    <div class="description">Hover over equipment to see details</div>
                                </div>
                            </div>
                        </div>
                        <div class="tab-content" id="items-tab">
                            <div class="equipment-screen-content">
                                <div class="equipment-list">
                                    ${
                                      GameStateManager.state.inventory.length > 0
                                        ? GameStateManager.state.inventory
                                            .filter(item => item.type !== 'relic') /* Filter out relic items from inventory tab */
                                            .map((item) => `
                                            <div class="equipment-item" 
                                                onmouseover="showItemInfo(${JSON.stringify(item).replace(/"/g, "&quot;")})"
                                                onmouseout="hideItemInfo()"
                                                onclick="${
                                                  item.type === "consumable"
                                                    ? `useItem('${item.id}')`
                                                    : GameStateManager.state.player.equipment[item.slot] === item
                                                      ? `EquipmentManager.unequip(GameStateManager.state.player, '${item.slot}')`
                                                      : `EquipmentManager.equip(GameStateManager.state.player, ${JSON.stringify(item).replace(/"/g, "&quot;")})`
                                                }"
                                            >
                                                <span class="slot-label">${item.name}</span>
                                                <div class="item">
                                                    <span class="item-name" title="${item.name}">${getItemAcronym(item.name)}</span>
                                                </div>
                                                    ${
                                                      item.type === "consumable"
                                                        ? `
                                                        <span class="item-quantity">x${item.quantity}</span>
                                                    `
                                                        : ""
                                                    }
                                            </div>
                                        `,
                                            )
                                            .join("")
                                        : '<p class="no-items">No items in inventory</p>'
                                    }
                                </div>
                                <div class="equipment-tooltip" id="itemTooltip">
                                    <div class="title">Item Information</div>
                                    <div class="description">Hover over an item to see details</div>
                                </div>
                            </div>
                        </div>
                        <div class="tab-content" id="skills-tab">
                            <div class="equipment-screen-content">
                                <div class="equipment-list">
                                    ${
                                      player.skills.length > 0
                                        ? `
                                        ${player.skills
                                          .map(
                                            (skill) => `
                                            <div class="equipment-item" 
                                                onmouseover="showSkillInfo(${JSON.stringify(skill).replace(/"/g, "&quot;")})"
                                                onmouseout="hideSkillInfo()"
                                            >
                                                <div class="skill-icon-container" style="display: flex; align-items: center;">
                                                    <img src="${skill.icon || ""}" class="skill-icon" style="width: 32px; height: 32px; margin-right: 8px; border: 1px solid #00ffff; border-radius: 4px;" alt="${skill.name}" />
                                                    <span class="slot-label" style="flex: 1;">${skill.name}</span>
                                                </div>
                                                <div class="item">
                                                    <span class="item-name" title="${skill.name}">${getSkillAcronym(skill.name)}</span>
                                                </div>
                                            </div>
                                        `,
                                          )
                                          .join("")}
                                    `
                                        : '<p class="no-items">No skills unlocked yet</p>'
                                    }
                                </div>
                                <div class="equipment-tooltip" id="skillTooltip">
                                    <div class="title">Skill Information</div>
                                    <div class="description">Click on a skill to see details</div>
                                </div>
                            </div>
                        </div>
                        <div class="tab-content" id="spells-tab">
                            <div class="equipment-screen-content">
                                <div class="equipment-list">
                                    ${
                                      player.spells.length > 0
                                        ? `
                                        ${player.spells
                                          .map(
                                            (spell) => `
                                            <div class="equipment-item" 
                                                onmouseover="showSpellInfo(${JSON.stringify(spell).replace(/"/g, "&quot;")})"
                                                onmouseout="hideSpellInfo()"
                                            >
                                                <span class="slot-label">${spell.name}</span>
                                                <div class="item">
                                                    <span class="item-name" title="${spell.name}">${getSpellAcronym(spell.name)}</span>
                                                </div>
                                            </div>
                                        `,
                                          )
                                          .join("")}
                                    `
                                        : '<p class="no-items">No spells learned yet</p>'
                                    }
                                </div>
                                <div class="equipment-tooltip" id="spellTooltip">
                                    <div class="title">Spell Information</div>
                                    <div class="description">Click on a spell to see details</div>
                                </div>
                            </div>
                        </div>
                        <div class="tab-content ${currentTabId === "relics-tab" ? "active" : ""}" id="relics-tab">
                            <div class="equipment-screen-content">
                                <div class="equipment-list">
                                    <div id="relics-container">
                                        ${player.relics && Object.keys(player.relics).length > 0 ?
                                            Object.entries(player.relics)
                                            .filter(([relicKey, relic]) => relic.level > 0 || (player.equipment?.relic_1?.relicId === relicKey || player.equipment?.relic_2?.relicId === relicKey))
                                            .map(([relicKey, relic]) => {
                                                const isEquipped = player.appliedRelicBonuses && player.appliedRelicBonuses[relicKey] === true;
                                                
                                                // Generate abilities HTML
                                                let abilitiesHTML = '';
                                                if (relic.abilities && relic.abilities.length > 0) {
                                                    abilitiesHTML = relic.abilities.map(ability => `
                                                        <div class="ability-item" data-ability-name="${ability.name}" data-ability-level="${ability.level}" data-ability-unlocked="${ability.level <= relic.level}" data-ability-description="${ability.description}" onmouseover="showAbilityTooltip(this, ${JSON.stringify(ability.name).replace(/"/g, '&quot;')}, ${JSON.stringify(ability.description).replace(/"/g, '&quot;')}, ${ability.level <= relic.level})" onmouseout="hideAbilityTooltip()">
                                                            <div class="ability-level ${ability.level <= relic.level ? 'unlocked' : 'locked'}"><div class="level-number">${ability.level}</div></div>
                                                            <div class="ability-name ${ability.level <= relic.level ? '' : 'locked'}" style="text-align: left !important;">${ability.name}</div>
                                                        </div>
                                                    `).join('');
                                                }
                                                
                                                // Generate fury bar HTML
                                                let furyBarHTML = '';
                                                if (relic.level < (relic.maxLevel || 5)) {
                                                    const furyPercent = Math.min(100, Math.floor((relic.fury / relic.furyToNextLevel) * 100));
                                                    furyBarHTML = `
                                                        <div class="fury-bar">
                                                            <div class="fury-fill" style="width: ${furyPercent}%"></div>
                                                        </div>
                                                        <div class="fury-text">${relic.fury}/${relic.furyToNextLevel} Fury</div>
                                                    `;
                                                }
                                                
                                                return `
                                                    <div class="relic-item ${isEquipped ? 'equipped' : ''}" data-relic-key="${relicKey}">
                                                        <div class="relic-header" onclick="toggleRelicEquip('${relicKey}')">
                                                            <span class="relic-name">${relic.name} ${isEquipped ? '(Equipped)' : ''}</span>
                                                            <span class="relic-level">Lvl ${relic.level}</span>
                                                        </div>
                                                        <div class="relic-description">${relic.description || ''}</div>
                                                        ${furyBarHTML}
                                                        <div class="relic-stats">+${relic.level} to all stats when equipped</div>
                                                        <div class="relic-abilities relic-grid">
                                                            ${(() => {
                                                                let abilitiesHTML = '';
                                                                
                                                                // Process existing abilities
                                                                if (relic.abilities && relic.abilities.length > 0) {
                                                                  abilitiesHTML = relic.abilities.map((ability) => {
                                                                    return `
                                                                      <div class="ability-item" 
                                                                          data-ability-name="${ability.name}" 
                                                                          data-ability-level="${ability.level}" 
                                                                          data-ability-unlocked="${ability.level <= relic.level}" 
                                                                          data-ability-description="${ability.description}"
                                                                          onmouseover="showAbilityTooltip(this, ${JSON.stringify(ability.name).replace(/"/g, '&quot;')}, ${JSON.stringify(ability.description).replace(/"/g, '&quot;')}, ${ability.level <= relic.level})"
                                                                          onmouseout="hideAbilityTooltip()">
                                                                        <div class="ability-level ${ability.level <= relic.level ? 'unlocked' : 'locked'}">
                                                                          <div class="level-number">${ability.level}</div>
                                                                        </div>
                                                                        <div class="ability-name ${ability.level <= relic.level ? 'unlocked' : 'locked'}" style="text-align: left !important;">${ability.name}</div>
                                                                      </div>
                                                                    `;
                                                                  }).join('');
                                                                }
                                                                
                                                                // Fill in empty slots if needed
                                                                const missingCount = 6 - (relic.abilities?.length || 0);
                                                                if (missingCount > 0) {
                                                                  for (let i = 0; i < missingCount; i++) {
                                                                    const level = (relic.abilities?.length || 0) + i + 1;
                                                                    abilitiesHTML += `
                                                                      <div class="ability-item">
                                                                        <div class="ability-level locked">
                                                                          <div class="level-number">${level}</div>
                                                                        </div>
                                                                        <div class="ability-name" style="text-align: left !important;">Undiscovered</div>
                                                                      </div>
                                                                    `;
                                                                  }
                                                                }
                                                                
                                                                return abilitiesHTML;
                                                            })()
                                                            }
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('') : '<div class="empty-message">No relics found</div>'
                                        }
                                    </div>
                                </div>
                                <div class="equipment-tooltip" id="relicTooltip">
                                    <div class="title">Relic Information</div>
                                    <div class="description">Click on a relic ability to see details</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

          // Add tab functionality
          const tabButtons = characterScreen.querySelectorAll(".tab-button");
          const tabContents = characterScreen.querySelectorAll(".tab-content");

          tabButtons.forEach((button) => {
            button.addEventListener("click", () => {
              // Remove active class from all buttons and contents
              tabButtons.forEach((btn) => btn.classList.remove("active"));
              tabContents.forEach((content) => content.classList.remove("active"));

              // Add active class to clicked button and corresponding content
              button.classList.add("active");
              const tabId = button.getAttribute("data-tab");
              const content = characterScreen.querySelector(`#${tabId}`);
              if (content) content.classList.add("active");
            });
          });
        },

        updateProgressStat(statType, current, max) {
          if (!this.elements) this.init();
          const currentId = `charCurrent${statType.toUpperCase()}`;
          const maxId = `charMax${statType.toUpperCase()}`;
          const fillId = `${statType}Fill`;

          if (this.elements[currentId]) {
            this.elements[currentId].textContent = current;
          }

          if (this.elements[maxId]) {
            this.elements[maxId].textContent = max;
          }

          if (this.elements[fillId]) {
            this.elements[fillId].style.width = `${(current / max) * 100}%`;
          }
        },

        updateInventoryUI() {
          if (!this.elements) this.init();
          const inventoryList = this.elements.inventoryList;
          inventoryList.innerHTML = "";

          GameStateManager.state.inventory.forEach((item) => {
            const itemElement = document.createElement("div");
            itemElement.className = "inventory-item";

            const icon = document.createElement("img");
            icon.className = "item-icon";
            icon.src = item.iconUrl;
            icon.alt = item.name;

            const details = document.createElement("div");
            details.className = "item-details";

            const name = document.createElement("div");
            name.className = "item-name";
            name.textContent = item.name;

            const description = document.createElement("div");
            description.className = "item-description";
            description.textContent = item.description;

            const quantity = document.createElement("div");
            quantity.className = "item-quantity";
            quantity.textContent = `Quantity: ${item.quantity}`;

            details.appendChild(name);
            details.appendChild(description);
            details.appendChild(quantity);

            itemElement.appendChild(icon);
            itemElement.appendChild(details);

            // Add use button if item is consumable
            if (item.type === "consumable") {
              const useButton = document.createElement("button");
              useButton.textContent = "Use";
              useButton.style.marginLeft = "10px";
              useButton.style.padding = "5px 10px";
              useButton.style.background = "#00ffff";
              useButton.style.border = "none";
              useButton.style.borderRadius = "3px";
              useButton.style.cursor = "pointer";
              useButton.onclick = (e) => {
                e.stopPropagation();
                useItem(item);
              };
              itemElement.appendChild(useButton);
            }

            itemElement.onclick = () => {
              this.log(`Examining ${item.name}: ${item.description}`);
            };

            inventoryList.appendChild(itemElement);
          });
        },

        // Add this property to track if messages are manually toggled
        _isManuallyToggled: false,
      };

      // Render Management
      const RenderManager = {
        canvas: null,
        ctx: null,
        backgroundImage: null,
        mapWidth: 0,
        mapHeight: 0,

        init() {
          this.canvas = document.getElementById("gameCanvas");
          if (!this.canvas) {
            console.error("Canvas not found");
            return;
          }

          this.ctx = this.canvas.getContext("2d");
          if (!this.ctx) {
            console.error("Could not get canvas context");
            return;
          }

          // Now that canvas is initialized, set up the click handler
          // This is safe because canvas is now properly initialized
          if (InputManager && typeof InputManager.setupClickHandler === "function") {
            try {
              InputManager.setupClickHandler();
            } catch (err) {
              console.error("Error setting up click handler:", err);
              // Non-fatal error, game can continue
            }
          }

          // Set canvas size based on game container
          const gameContainer = document.getElementById("game-container");
          const containerWidth = gameContainer ? gameContainer.offsetWidth : 800;
          const containerHeight = gameContainer ? gameContainer.offsetHeight : 600;

          // Get nav height with fallback
          const nav = document.querySelector("#topNav");
          const navHeight = nav ? nav.offsetHeight : 0;

          // Set canvas dimensions
          this.canvas.width = containerWidth;
          this.canvas.height = containerHeight - navHeight;

          // Load background for current scene
          this.loadBackground(SCENES[GameStateManager.state.currentScene.toUpperCase()].background);
        },

        loadBackground(backgroundUrl) {
          if (!backgroundUrl) {
            console.error("No background URL provided");
            return;
          }

          const img = new Image();
          img.crossOrigin = "anonymous";

          img.onload = () => {
            this.backgroundImage = img;

            // Set map dimensions based on actual image size
            this.mapWidth = Math.floor(img.width / GRID_SIZE);
            this.mapHeight = Math.floor(img.height / GRID_SIZE);

            // Generate the map now that we have the dimensions
            generateMap();

            // Update map bounds in GameStateManager
            GameStateManager.updateMapBounds(this.mapWidth, this.mapHeight);

            this.render();
          };

          img.onerror = (e) => {
            console.error("Failed to load background image:", e);
          };

          img.src = backgroundUrl;
        },

        render() {
          if (!this.canvas || !this.ctx) return;

          // Clear the canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Get player position for camera
          const player = GameStateManager.state.player;
          if (!player) return;

          // Calculate camera offset to center on player
          const cameraX = Math.max(
            0,
            Math.min(
              player.x * GRID_SIZE - this.canvas.width / 2,
              this.backgroundImage ? this.backgroundImage.width - this.canvas.width : 0,
            ),
          );
          const cameraY = Math.max(
            0,
            Math.min(
              player.y * GRID_SIZE - this.canvas.height / 2,
              this.backgroundImage ? this.backgroundImage.height - this.canvas.height : 0,
            ),
          );

          // Draw background with camera offset
          this.ctx.save();

          if (this.backgroundImage) {
            // Draw the background at its original size
            this.ctx.drawImage(
              this.backgroundImage,
              cameraX,
              cameraY,
              this.canvas.width,
              this.canvas.height,
              0,
              0,
              this.canvas.width,
              this.canvas.height,
            );
          }

          // Draw debug grid and coordinates only when debug mode is enabled
          if (DEBUG.enabled) {
            this.ctx.strokeStyle = "rgba(255, 0, 0, 0.3)";
            this.ctx.lineWidth = 1;

            // Adjust grid drawing to account for camera offset
            const startX = Math.floor(cameraX / GRID_SIZE) * GRID_SIZE - cameraX;
            const startY = Math.floor(cameraY / GRID_SIZE) * GRID_SIZE - cameraY;

            // Draw collision tiles first
            for (const [key, isActive] of DEBUG.collisionMap) {
              if (isActive) {
                const [tileX, tileY] = key.split(",").map(Number);
                const screenX = tileX * GRID_SIZE - cameraX;
                const screenY = tileY * GRID_SIZE - cameraY;

                // Draw collision tile
                this.ctx.fillStyle = DEBUG.colors.active;
                this.ctx.fillRect(screenX, screenY, GRID_SIZE, GRID_SIZE);

                // Highlight if this is the selected tile
                if (DEBUG.selectedTile && DEBUG.selectedTile.x === tileX && DEBUG.selectedTile.y === tileY) {
                  this.ctx.fillStyle = DEBUG.colors.selected;
                  this.ctx.fillRect(screenX, screenY, GRID_SIZE, GRID_SIZE);
                }
              }
            }

            // Draw vertical lines
            for (let x = startX; x <= this.canvas.width; x += GRID_SIZE) {
              this.ctx.beginPath();
              this.ctx.moveTo(x, 0);
              this.ctx.lineTo(x, this.canvas.height);
              this.ctx.stroke();
            }

            // Draw horizontal lines
            for (let y = startY; y <= this.canvas.height; y += GRID_SIZE) {
              this.ctx.beginPath();
              this.ctx.moveTo(0, y);
              this.ctx.lineTo(this.canvas.width, y);
              this.ctx.stroke();
            }

            // Draw grid coordinates
            this.ctx.fillStyle = "rgba(255, 0, 0, 0.7)";
            this.ctx.font = "10px Arial";
            const startGridX = Math.floor(cameraX / GRID_SIZE);
            const startGridY = Math.floor(cameraY / GRID_SIZE);

            for (let y = startY; y <= this.canvas.height; y += GRID_SIZE) {
              for (let x = startX; x <= this.canvas.width; x += GRID_SIZE) {
                const gridX = startGridX + Math.floor((x - startX) / GRID_SIZE);
                const gridY = startGridY + Math.floor((y - startY) / GRID_SIZE);
                this.ctx.fillText(`${gridX},${gridY}`, x + 2, y + 10);
              }
            }
          }

          // Update enemy animations
          const currentTime = Date.now();
          EnemyManager.updateAnimations(currentTime);

          // Draw enemies
          EnemyManager.enemies.forEach((enemy) => {
            const screenX = enemy.x * GRID_SIZE - cameraX - (GRID_SIZE * PLAYER_SCALE - GRID_SIZE) / 2;
            const screenY = enemy.y * GRID_SIZE - cameraY - (GRID_SIZE * PLAYER_SCALE - GRID_SIZE) / 2;

            if (!enemy.portalAnimationComplete && enemy.portalFrames && Array.isArray(enemy.portalFrames)) {
              // Draw portal animation
              const frameIndex = Math.floor(enemy.portalFrameIndex);
              if (
                frameIndex >= 0 &&
                frameIndex < enemy.portalFrames.length &&
                enemy.portalFrames[frameIndex] &&
                enemy.portalFrames[frameIndex].complete
              ) {
                this.ctx.drawImage(
                  enemy.portalFrames[frameIndex],
                  screenX - GRID_SIZE,
                  screenY - GRID_SIZE,
                  GRID_SIZE * PLAYER_SCALE * 2,
                  GRID_SIZE * PLAYER_SCALE * 2,
                );

                // Update portal animation
                enemy.portalFrameIndex += enemy.portalAnimationSpeed;
                if (enemy.portalFrameIndex >= enemy.portalFrames.length) {
                  enemy.portalAnimationComplete = true;
                  console.log("Portal animation complete for:", enemy.name);
                }
              }
            } else {
              // CRITICAL FIX: Check for any enemy that should use animated frames
              // Fix the rendering logic to handle all animated enemy types, not just Space Goblins
              if (enemy.useAnimatedSprite && enemy.portalAnimationComplete) {
                // Restore original name/type for Cyber Orcs if needed
                if (enemy.originalName === "Cyber Orc" && enemy.name !== "Cyber Orc") {
                  enemy.name = "Cyber Orc";
                  enemy.type = "Cyber Orc";
                }

                // Get the correct animation frame for this enemy type
                const spriteImage = EnemyManager.getEnemySprite(enemy);

                if (spriteImage && spriteImage.complete) {
                  this.ctx.drawImage(
                    spriteImage,
                    0,
                    0,
                    spriteImage.width || GRID_SIZE,
                    spriteImage.height || GRID_SIZE,
                    screenX,
                    screenY,
                    GRID_SIZE * PLAYER_SCALE,
                    GRID_SIZE * PLAYER_SCALE,
                  );
                }
              } else if (enemy.sprite) {
                // Add safety check for image state
                try {
                  // Only draw if image is completely loaded and not in broken state
                  if (enemy.sprite.complete && enemy.sprite.naturalWidth > 0) {
                    // Draw regular enemy sprite for other enemy types
                    this.ctx.drawImage(
                      enemy.sprite,
                      0,
                      0,
                      enemy.sprite.width || GRID_SIZE,
                      enemy.sprite.height || GRID_SIZE,
                      screenX,
                      screenY,
                      GRID_SIZE * PLAYER_SCALE,
                      GRID_SIZE * PLAYER_SCALE,
                    );
                  }
                } catch (err) {
                  console.error(`Error drawing enemy sprite: ${err.message}`);
                }
              }
            }
          });

          // Draw NPCs if they exist
          if (GameStateManager.state.npcs && GameStateManager.state.npcs.length > 0) {
            GameStateManager.state.npcs.forEach((npc) => {
              // Calculate screen position
              const screenX = npc.x * GRID_SIZE - cameraX - (GRID_SIZE * PLAYER_SCALE - GRID_SIZE) / 2;
              const screenY = npc.y * GRID_SIZE - cameraY - (GRID_SIZE * PLAYER_SCALE - GRID_SIZE) / 2;

              try {
                // Special rendering for Glitch NPC
                if (npc.type === "GlitchNPC" && npc.isVisible) {
                  // Get the current frame based on animation state
                  let currentFrame;

                  if (npc.frameImages && npc.frameImages.length > 0) {
                    currentFrame = npc.frameImages[npc.frameIndex];
                  }

                  // Only draw if the frame is available and loaded properly
                  if (currentFrame && currentFrame.complete && currentFrame.naturalWidth > 0) {
                    // Apply bobbing effect if in bobbing state
                    const offsetY =
                      npc.animationState === GlitchNPCManager.STATES.BOBBING ? npc.bobOffset * GRID_SIZE : 0;

                    this.ctx.drawImage(
                      currentFrame,
                      0,
                      0,
                      currentFrame.width || GRID_SIZE,
                      currentFrame.height || GRID_SIZE,
                      screenX,
                      screenY + offsetY, // Add vertical offset for bobbing
                      GRID_SIZE * PLAYER_SCALE,
                      GRID_SIZE * PLAYER_SCALE,
                    );
                  }
                }
                // Standard rendering for other NPCs
                else if (npc.sprite && npc.sprite.complete && npc.sprite.naturalWidth > 0) {
                  this.ctx.drawImage(
                    npc.sprite,
                    0,
                    0,
                    npc.sprite.width || GRID_SIZE,
                    npc.sprite.height || GRID_SIZE,
                    screenX,
                    screenY,
                    GRID_SIZE * PLAYER_SCALE,
                    GRID_SIZE * PLAYER_SCALE,
                  );
                }
              } catch (err) {
                console.error(`Error drawing NPC sprite: ${err.message}`);
              }
            });
          }

          // Draw player
          if (player && player.sprite) {
            const spriteSize = GRID_SIZE * PLAYER_SCALE;
            const currentTime = Date.now();

            // Check if player should be in idle state (3 seconds of inactivity)
            const idleThreshold = 3000; // 3 seconds
            const timeSinceLastMovement = currentTime - player.animationState.lastMovementTime;
            const shouldBeIdle = timeSinceLastMovement >= idleThreshold;

            // Don't override movement state with idle if the player is actively moving
            if (!player.animationState.isMoving) {
              // Handle transition to idle state only if player isn't moving
              if (shouldBeIdle && !player.animationState.isIdle) {
                player.animationState.isIdle = true;
                player.animationState.currentFrame = 0; // Reset frame when entering idle state
                player.animationState.lastFrameUpdate = currentTime;
                console.log("Player entering idle animation state");
              }
              // In case we need to exit idle state for some reason other than movement
              else if (!shouldBeIdle && player.animationState.isIdle) {
                player.animationState.isIdle = false;
                player.animationState.currentFrame = 0; // Reset frame when exiting idle state
                player.animationState.lastFrameUpdate = currentTime;
                console.log("Player exiting idle animation state");
              }
            }

            // Update animation frame if enough time has passed
            const frameInterval = player.animationState.isIdle
              ? player.animationState.idleFrameInterval
              : player.animationState.frameInterval;

            if (currentTime - player.animationState.lastFrameUpdate >= frameInterval) {
              // If idle, cycle through idle frames, otherwise use directional frames
              if (player.animationState.isIdle) {
                player.animationState.currentFrame =
                  (player.animationState.currentFrame + 1) % player.animationState.idleFrames.length;
              } else if (player.animationState.isMoving) {
                player.animationState.currentFrame =
                  (player.animationState.currentFrame + 1) % player.animationState.totalFrames;
              }
              player.animationState.lastFrameUpdate = currentTime;
            }

            // Get the appropriate image for the current frame
            let currentImage;
            if (player.animationState.isIdle) {
              // Use idle animation frames
              currentImage = player.animationState.frameImages.idle[player.animationState.currentFrame];
            } else {
              // Use directional animation frames
              currentImage = player.animationState.frameImages[player.direction][player.animationState.currentFrame];
            }

            if (currentImage) {
              const screenX = player.x * GRID_SIZE - cameraX - (spriteSize - GRID_SIZE) / 2;
              const screenY = player.y * GRID_SIZE - cameraY - (spriteSize - GRID_SIZE) / 2;

              try {
                // Only draw if image is completely loaded and not in broken state
                if (currentImage.complete && currentImage.naturalWidth > 0) {
                  this.ctx.drawImage(
                    currentImage,
                    0,
                    0,
                    currentImage.width || GRID_SIZE,
                    currentImage.height || GRID_SIZE,
                    screenX,
                    screenY,
                    spriteSize,
                    spriteSize,
                  );
                }
              } catch (err) {
                console.error(`Error drawing player sprite: ${err.message}`);
              }
            }
          }

          this.ctx.restore();
        },
      };

      // Setup game loop to handle animation and updates
      // Using a variable reference instead of a function declaration to avoid conflicts
      function mainGameLoop(timestamp) {
        // Request next frame
        window.requestAnimationFrame(mainGameLoop);

        // Skip if the game is paused
        if (GameStateManager.state.paused) return;

        // Process battle animations in the battle system
        if (GameStateManager.state.currentState === GAME_STATES.BATTLE && BattleSystem && BattleSystem.isActive) {
          BattleSystem.handleAnimationUpdates(timestamp);
        }

        // Update the game
        GameStateManager.update();

        // Update Glitch NPC animations if active
        GlitchNPCManager.update();

        // Poll for input instead of relying on events (more reliable)
        handleInputPolling();

        // Update UI once per frame
        UIManager.update();

        // Render the game
        RenderManager.render();
      }

      // Function to update sprite elements in battle UI
      function updateBattleSprites() {
        const enemySide = document.getElementById("enemySide");
        if (!enemySide) return;

        // Get all enemy sprite containers
        const enemySprites = enemySide.querySelectorAll(".battle-sprite-container");

        // Update each enemy sprite with current animation frame
        if (enemySprites.length > 0) {
          enemySprites.forEach((container, index) => {
            const enemy = BattleSystem.enemyGroup[index];
            // CRITICAL FIX: Check for useAnimatedSprite flag rather than specific name
            // Restore original type for Cyber Orcs if needed
            if (enemy && enemy.originalName === "Cyber Orc" && enemy.name !== "Cyber Orc") {
              enemy.name = "Cyber Orc";
              enemy.type = "Cyber Orc";
            }

            // Now check for any animated enemy, not just Space Goblins
            if (enemy && enemy.useAnimatedSprite && container) {
              const img = container.querySelector("img");
              if (img) {
                // Get the appropriate sprite based on animation frame
                const spriteImage = BattleSystem.getBattleSprite(enemy);
                if (spriteImage && spriteImage.src) {
                  img.src = spriteImage.src;
                }
              }
            }
          });
        }
      }

      // We already have an AudioManager defined above, so we don't need a duplicate here

      // Add event listener to initialize audio on first user interaction
      document.addEventListener(
        "click",
        function initAudioOnFirstClick() {
          AudioManager.init();
          // Remove this listener after first initialization
          document.removeEventListener("click", initAudioOnFirstClick);
          console.log("[Audio] Initialized audio context on user interaction");
        },
        { once: true },
      );

      // Global interaction tracking
      let lastClickTime = 0;
      let mousePos = { x: 0, y: 0 };
      let isMouseDown = false;

      // Track mouse position and clicks without relying on canvas events
      document.addEventListener("mousemove", function (e) {
        // Only track mouse position if we're not in intro screen
        if (GameStateManager && GameStateManager.state && GameStateManager.state.currentState !== GAME_STATES.START) {
          mousePos.x = e.clientX;
          mousePos.y = e.clientY;
        }
      });

      document.addEventListener("mousedown", function () {
        // Only track mouse down if we're not in intro screen
        if (GameStateManager && GameStateManager.state && GameStateManager.state.currentState !== GAME_STATES.START) {
          isMouseDown = true;
        }
      });

      document.addEventListener("mouseup", function () {
        // Only track mouse up if we're not in intro screen
        if (GameStateManager && GameStateManager.state && GameStateManager.state.currentState !== GAME_STATES.START) {
          isMouseDown = false;
        }
      });

      document.addEventListener("touchstart", function (e) {
        // Only track touch if we're not in intro screen
        if (GameStateManager && GameStateManager.state && GameStateManager.state.currentState !== GAME_STATES.START) {
          if (e.touches && e.touches[0]) {
            mousePos.x = e.touches[0].clientX;
            mousePos.y = e.touches[0].clientY;
            isMouseDown = true;
          }
        }
      });

      document.addEventListener("touchend", function () {
        // Only track touch end if we're not in intro screen
        if (GameStateManager && GameStateManager.state && GameStateManager.state.currentState !== GAME_STATES.START) {
          isMouseDown = false;
        }
      });

      // This function polls for input instead of relying on events
      function handleInputPolling() {
        // Make sure GameStateManager exists and is initialized
        if (!GameStateManager || !GameStateManager.state) {
          return;
        }

        // Only process in exploration mode
        if (GameStateManager.state.currentState !== GAME_STATES.EXPLORE) {
          return;
        }

        // Check if mouse is clicked (with simple debounce)
        const currentTime = Date.now();
        if (isMouseDown && currentTime - lastClickTime > 300) {
          lastClickTime = currentTime;

          // Convert to canvas coordinates
          const canvas = document.getElementById("gameCanvas");
          if (canvas) {
            const rect = canvas.getBoundingClientRect();

            // Check if click is inside canvas
            if (
              mousePos.x >= rect.left &&
              mousePos.x <= rect.right &&
              mousePos.y >= rect.top &&
              mousePos.y <= rect.bottom
            ) {
              const canvasX = mousePos.x - rect.left;
              const canvasY = mousePos.y - rect.top;

              console.log(`Direct input polling: click at canvas position (${canvasX}, ${canvasY})`);

              // Convert to grid coordinates
              const gridPos = InputManager.canvasToGridCoordinates(canvasX, canvasY);
              if (gridPos) {
                console.log(`Direct input polling: grid position (${gridPos.x}, ${gridPos.y})`);

                // Check for enemies at the clicked position
                if (EnemyManager && EnemyManager.enemies && EnemyManager.enemies.length > 0) {
                  const enemy = EnemyManager.enemies.find((e) => e.x === gridPos.x && e.y === gridPos.y);

                  if (enemy) {
                    console.log(`Direct input polling: Enemy found at (${enemy.x}, ${enemy.y}) - ${enemy.name}`);
                    InputManager.handleEnemyTap(enemy);
                    return;
                  }
                }

                // If no enemy, check if clicked on player
                if (InputManager.isTapOnPlayer(gridPos.x, gridPos.y)) {
                  console.log(`Direct input polling: Player clicked`);
                  toggleCharacterScreen();
                } else {
                  // Otherwise move player
                  InputManager.movePlayerToGrid(gridPos.x, gridPos.y);
                }
              }
            }
          }
        }
      }

      // Game Loop - renamed to avoid duplicate function declaration
      function gameUpdateLoop() {
        if (GameStateManager && GameStateManager.state && !GameStateManager.state.isPaused) {
          if (GameStateManager.state.currentState === GAME_STATES.EXPLORE) {
            GameStateManager.update();
            EnemyManager.update();
          }
          // Always render, but GameStateManager.update() will prevent movement during battle
          RenderManager.render();
        }
        // Handle input polling - this is a more reliable approach than click events
        // Make sure GameStateManager is initialized before polling input
        if (GameStateManager && GameStateManager.state) {
          handleInputPolling();
        }
        requestAnimationFrame(gameUpdateLoop);
      }

      // Initialize Game
      function initGame() {
        // Initialize all game managers
        RenderManager.init();
        InputManager.setup();
        UIManager.init();
        GameStateManager.init(); // Initialize GameStateManager and storedCollisionMaps
        UIManager.update();
        // Start the game update loop
        requestAnimationFrame(gameUpdateLoop);
      }

      // Character Creation with expanded stats
      function createCharacter(characterClass, savedStats) {
        const baseStats = savedStats || CHARACTER_CLASSES[characterClass].getBaseStats();
        const hp = baseStats.vitality * 20;
        const mp = baseStats.intelligence * 15;

        // Get player name from input, limit to 5 characters
        const playerName =
          document.getElementById("playerNameInput").value.substring(0, 5) || characterClass.substring(0, 5);

        // Create player object
        GameStateManager.state.player = {
          name: playerName,
          class: characterClass,
          stats: baseStats,
          hp: hp,
          maxHp: hp,
          mp: mp,
          maxMp: mp,
          gold: 0,
          xp: 0,
          level: 1,
          xpToNextLevel: 100,
          // Use custom spawn point if available for current scene
          x: GameStateManager.state.spawnPoints[GameStateManager.state.currentScene]?.x || 6,
          y: GameStateManager.state.spawnPoints[GameStateManager.state.currentScene]?.y || 6,
          direction: "down",
          frame: 0,
          sprite: CHARACTER_CLASSES[characterClass].sprite,
          // Initialize leveling system
          statPoints: 0,
          skills: Object.values(CHARACTER_CLASSES[characterClass].skills)
            .filter((skill) => skill.level <= 1) // Only get skills available at level 1
            .map((skill) => ({
              ...skill,
              currentCooldown: 0,
            })),
          spells: Object.values(CHARACTER_CLASSES[characterClass].spells || {}) // Use empty object if no spells defined
            .filter((spell) => spell.level <= 1) // Only get spells available at level 1
            .map((spell) => ({
              ...spell,
              currentCooldown: 0,
            })),
          passives: [],
          statsLocked: true, // Start locked until first level up
          baseStats: { ...baseStats }, // Save initial stats as base stats
          // Animation state
          animationState: {
            currentFrame: 0,
            totalFrames: 4,
            lastMovementTime: Date.now(), // Track when the player last moved
            directions: {
              up: [
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Up_1-3gnXLDoi238Iwc2ewJALzssjcW4Kff.png?EdIl",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Up_2-sDxsjXCQLs5A8unWh8ElJg3jayk59O.png?VUv5",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Up_3-v8dWSHKADjZttvhKNYSziizqe5EGMN.png?D42r",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Up_4-KnJ4Nhvv6C7BejBwuwlDF5KtvYagQx.png?GZor",
              ],
              down: [
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Down_1-YTRt0ftHO6VqrH39PSe2j60u2nicmL.png?90pi",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Down_2-bBPOdQ8UQtEMh7LhuSdh3wLV8mMFJT.png?wyXZ",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Down_3-AToaD4hpS5eBCPrEozzV7vhyH0tNcv.png?NaqA",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Down_4-K4PlYZ87NGsvHaxBd2ET8biEYo5CRw.png?1XtQ",
              ],
              right: [
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Right_1-XAY40z1tQ7w11EJ1AxQ8nhyZxqqsaS.png?DgfY",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Right_2-tS9ZGXV3SPI3fIx0LoHLyRJSqqIHXt.png?FBWC",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Right_3-yOZMrXwue2ypbiuncwFA4Mx05lIb0f.png?6jka",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Right_4-yNvA8SdMROLnP88Fvut3t7fwGmaRCL.png?ckWX",
              ],
              left: [
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Left_1-5bCP84DENqE91jqjNcLDfksjUGCIcS.png?4ziR",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Left_2-qDrFNiSd5YiH3lqO7L3XI7dsP7wi9N.png?2mU6",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Left_3-EXBaOEiU5LhaGe2Npb5GbkKS0f0TPV.png?wryk",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flex_Left_4-QN3Yp0EwaAPWBJ76CHCSCMu9Q4NAnR.png?QiWm",
              ],
            },
            idleFrames: [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexIdle1-dKEJbc2mGdesYoJ9gFfeAdFjdemJFt.png?5hsY",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexIdle2-dbGQIhB4InIp4cJ78fZS05JrBuqr2E.png?VcSb",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexIdle3-gqrHMyCgwTBPw2wBFoJwJIjc2RiKsZ.png?JjOJ",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexIdle4-1Gd50rBykVcq2AdD5oYoe9m09pRA8W.png?xmrK",
            ],
            frameImages: {},
            lastFrameUpdate: 0,
            frameInterval: 150,
            idleFrameInterval: 250,
            isMoving: false,
            isIdle: true,
          },
          // Initialize equipment slots
          equipment: {
            MAIN_HAND: null,
            OFF_HAND: null,
            HEAD: null,
            BODY: null,
            LEGS: null,
            FEET: null,
            RELIC_1: null,
            RELIC_2: null,
          },
          // Initialize inventory
          inventory: [],
          // Initialize effects
          effects: [],
        };

        // Initialize leveling system
        LEVELING_SYSTEM.initializeCharacter(GameStateManager.state.player);

        // Preload animation frames
        preloadAnimationFrames(GameStateManager.state.player);

        // Set game state to explore
        GameStateManager.state.currentState = "explore";

        // Load the sprite image
        const spriteImage = new Image();
        spriteImage.crossOrigin = "anonymous";
        spriteImage.onload = () => {
          GameStateManager.state.player.spriteImage = spriteImage;
        };
        spriteImage.src = CHARACTER_CLASSES[characterClass].sprite;

        // Add starting items
        addItemToInventory({ ...ITEMS.HEALTH_POTION });
        addItemToInventory({ ...ITEMS.MANA_POTION });

        // Add starting equipment based on class
        switch (characterClass) {
          case "FLEXECUTIONER":
            addItemToInventory({ ...BASE_EQUIPMENT.RUBBER_DUMBELLS });
            break;
          case "INFLUMANCER":
            addItemToInventory({ ...BASE_EQUIPMENT.WOODEN_STAFF });
            addItemToInventory({ ...BASE_EQUIPMENT.CLOTH_ROBE });
            break;
          case "SUS_ASSIN":
            const dagger = { ...BASE_EQUIPMENT.RUBBER_DUMBELLS };
            dagger.weaponType = WEAPON_TYPES.DAGGER;
            dagger.name = "Training Dagger";
            dagger.stats.damage = 2;
            dagger.stats.hitChance = 0.9;
            addItemToInventory(dagger);
            break;
          case "MOM_FRIEND":
            const mace = { ...BASE_EQUIPMENT.RUBBER_DUMBELLS };
            mace.weaponType = WEAPON_TYPES.MACE;
            mace.name = "Wooden Mace";
            addItemToInventory(mace);
            addItemToInventory({ ...BASE_EQUIPMENT.WOODEN_SHIELD });
            break;
        }

        GameStateManager.state.currentState = GAME_STATES.EXPLORE;
        UIManager.showGameScreen();
      }

      // Map Generation
      function generateMap() {
        // We'll generate the map after the background is loaded
        // This ensures we have the correct dimensions
        if (RenderManager.backgroundImage) {
          const mapWidth = Math.floor(RenderManager.backgroundImage.width / GRID_SIZE);
          const mapHeight = Math.floor(RenderManager.backgroundImage.height / GRID_SIZE);
          const arcade1Map = generateMapForScene("arcade1", mapWidth, mapHeight);
          GameStateManager.state.map = arcade1Map;
          SCENES.ARCADE1.map = arcade1Map;
        }
      }

      function generateArcade1Map(width = MAP_WIDTH, height = MAP_HEIGHT) {
        const map = [];
        for (let y = 0; y < height; y++) {
          const row = [];
          for (let x = 0; x < width; x++) {
            // Create a border around the map
            if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
              row.push(1); // Wall (collision)
            } else {
              row.push(0); // Floor (no collision)
            }
          }
          map.push(row);
        }
        return map;
      }

      function generateMapForScene(sceneId, width = MAP_WIDTH, height = MAP_HEIGHT) {
        // We only need arcade1 map now
        return generateArcade1Map(width, height);
      }

      // Movement Check
      function canMove(x, y, isNPC = false) {
        // Ensure we're only moving one tile at a time
        const currentX = GameStateManager.state.player.x;
        const currentY = GameStateManager.state.player.y;
        const distance = Math.abs(x - currentX) + Math.abs(y - currentY);

        if (distance > 1) {
          return false;
        }

        // Check bounds using the stored map dimensions
        if (x < 0 || y < 0 || x >= GameStateManager.state.mapWidth || y >= GameStateManager.state.mapHeight) {
          return false;
        }

        // Special case for the glitch NPC at position (11,9)
        // Allow it to spawn on collision tiles since it's an NPC, not an enemy
        if (isNPC || (x === 11 && y === 9 && GameStateManager.state.currentScene === "arcade1")) {
          console.log(`DEBUG: Allowing NPC/glitch at (${x}, ${y}) to bypass collision check`);
          // Skip collision check and continue with the rest of the checks
        } else {
          // Check for collision tiles for regular player movement
          const key = `${x},${y}`;
          if (DEBUG.collisionMap.get(key)) {
            return false;
          }
        }

        // Check if there's an enemy at this position
        if (EnemyManager && EnemyManager.enemies) {
          const enemyAtPosition = EnemyManager.enemies.find((enemy) => enemy.x === x && enemy.y === y);
          if (enemyAtPosition) {
            console.log(
              `🔍 DEBUG: Player bumped into enemy ${enemyAtPosition.name} at (${x}, ${y}) - initiating combat`,
            );
            // Start combat when player bumps into an enemy
            setTimeout(() => {
              BattleSystem.startBattle(enemyAtPosition);
            }, 10); // Small delay to ensure game state is updated first
            return false; // Still prevent movement to the enemy's position
          }
        }

        return true;
      }

      // Start Game
      function startGame() {
        const startScreen = document.getElementById("startScreen");
        const characterSelect = document.getElementById("characterSelect");

        startScreen.style.display = "none";
        characterSelect.style.display = "flex";

        // Play click sound
        AudioManager.play("click");

        // Setup character selection
        populateCharacterSelect();
      }

      // Add descriptions object before populateCharacterSelect function
      const descriptions = {
        flexecutioner:
          "A gym‑bro hero whose biceps have biceps. They solve problems by lifting the problems and throwing them at other problems.",
        influmancer:
          "A spell‑slinger who monetizes mana. Every fireball is cross‑posted, every crit is a collab, and cooldowns drop when the algorithm smiles.",
        sus_assin:
          "Sneaky gremlin with a vent map tattooed on their arm. Claims they're 'just doing tasks,' but bodies keep turning up in electrical.",
        mom_friend:
          "Carries wet wipes, granola bars, and the crushing weight of keeping everyone alive. Will resurrect you and scold you in the same breath.",
      };

      function populateCharacterSelect() {
        const characterList = document.getElementById("characterList");
        characterList.innerHTML = `
                <div style="
                    background: rgba(0, 0, 0, 0.8);
                    border: 2px solid #00ffff;
                    border-radius: 8px;
                    padding: 3px 20px;
                    width: calc(100% - 3px);
                    margin: 0 0 2px 0;
                    box-sizing: border-box;
                ">
                    <div style="
                        display: flex;
                        flex-direction: column;
                        align-items: flex-start;
                        margin-bottom: 10px;
                        user-select: none;
                        width: calc(100% - 3px);
                    ">
                        <div style="
                            display: flex;
                            align-items: center;
                            margin: 0;
                            padding: 0;
                            width: 100%;
                            height: 64px;
                        ">
                            <img id="characterSprite" style="
                                width: 96px;
                                height: 96px;
                                margin-right: 10px;
                                margin-top: 25px;
                                margin-left: -10px;
                                pointer-events: none;
                                flex-shrink: 0;
                            ">
                            <h3 id="characterTitle" style="
                                color: #00ffff;
                                font-size: 18.5px;
                                margin: 0;
                                padding: 0;
                                cursor: pointer;
                                flex-shrink: 0;
                                min-width: 100px;
                                line-height: 1;
                            " onclick="showClassDescription()"></h3>
                        </div>
                        <input id="playerNameInput" type="text" maxLength="5" placeholder="Name (5 chars)" style="
                            padding: 8px;
                            width: 120px;
                            background: rgba(0, 0, 0, 0.7);
                            border: 2px solid #00ffff;
                            border-radius: 4px;
                            color: #00ffff;
                            text-align: center;
                            font-size: 12px;
                            margin-left: 79px;
                            margin-top: 3px;
                            box-sizing: border-box;
                        ">
                    </div>
                    <div id="statsTable" style="
                        display: grid;
                        grid-template-columns: repeat(2, 1fr);
                        gap: 8px;
                        margin-bottom: 15px;
                        width: 90%;
                        margin-left: auto;
                        margin-right: auto;
                    "></div>
                    <div id="resourcesBox" style="
                        background: rgba(0, 0, 0, 0.5);
                        border: 2px solid #00ffff;
                        border-radius: 4px;
                        padding: 8px;
                        margin-bottom: 15px;
                        display: flex;
                        justify-content: space-around;
                        color: #00ffff;
                        width: 85%;
                        margin-left: auto;
                        margin-right: auto;
                    "></div>
                    <div id="descriptionBox" style="
                        background: rgba(0, 0, 0, 0.5);
                        border: 2px solid #00ffff;
                        border-radius: 4px;
                        padding: 8px;
                        margin-bottom: 15px;
                        color: #fff;
                        min-height: 60px;
                        width: 85%;
                        margin-left: auto;
                        margin-right: auto;
                        font-size: 90%;
                    "></div>
                    <div style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        width: 85%;
                        margin-left: auto;
                        margin-right: auto;
                        padding: 0 1px;
                    ">
                        <div style="
                            background: none;
                            border: none;
                            color: #00ffff;
                            font-size: 24px;
                            cursor: pointer;
                            width: 40px;
                            height: 40px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            user-select: none;
                        " onclick="document.querySelector('.nav-arrow.prev').click()">←</div>
                        <div style="
                            background: rgba(0, 0, 0, 0.7);
                            border: 2px solid #00ffff;
                            border-radius: 4px;
                            padding: 8px 16px;
                            color: #00ffff;
                            cursor: pointer;
                            font-size: 12px;
                            text-align: center;
                        " onclick="document.querySelector('.choose-button').click()">Choose</div>
                        <div style="
                            background: none;
                            border: none;
                            color: #00ffff;
                            font-size: 24px;
                            cursor: pointer;
                            width: 40px;
                            height: 40px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            user-select: none;
                        " onclick="document.querySelector('.nav-arrow.next').click()">→</div>
                    </div>
                </div>
                <button class="nav-arrow prev" style="display: none;">←</button>
                <button class="nav-arrow next" style="display: none;">→</button>
                <button class="choose-button" style="display: none;">Choose</button>
            `;

        // Add keyboard event handler for name input
        const nameInput = document.getElementById("playerNameInput");
        nameInput.addEventListener("keydown", (event) => {
          if (!event || typeof event.key !== "string") return;

          if (event.key === "Enter") {
            event.preventDefault();
            nameInput.blur();
            return;
          }

          const validCharRegex = /^[a-zA-Z0-9\-_.]$/;
          if (
            !validCharRegex.test(event.key) &&
            !["Backspace", "Delete", "ArrowLeft", "ArrowRight", "Tab"].includes(event.key)
          ) {
            event.preventDefault();
          }
        });

        nameInput.addEventListener("input", () => {
          nameInput.value = nameInput.value.substring(0, 5);
        });

        const characters = Object.entries(CHARACTER_CLASSES);
        let currentIndex = 0;
        let currentDescription = "";
        let currentStats = null; // Store the current character's stats

        function updateDisplay() {
          const [key, char] = characters[currentIndex];
          currentStats = char.getBaseStats(); // Generate and store stats
          const baseStats = currentStats;
          const hp = baseStats.vitality * 20;
          const mp = baseStats.intelligence * 15;

          // Update sprite and title
          document.getElementById("characterSprite").src = char.sprite;
          document.getElementById("characterTitle").textContent = char.name;

          // Store current description
          currentDescription = descriptions[key.toLowerCase()];

          // Update description box with class description
          const descriptionBox = document.getElementById("descriptionBox");
          descriptionBox.textContent = currentDescription;

          // Update stats
          const statsTable = document.getElementById("statsTable");
          statsTable.innerHTML = "";
          const stats = [
            { name: "Strength", value: baseStats.strength, desc: "Physical damage and carrying capacity" },
            { name: "Intelligence", value: baseStats.intelligence, desc: "Magic power and MP pool" },
            { name: "Vitality", value: baseStats.vitality, desc: "Health points and defense" },
            { name: "Dexterity", value: baseStats.dexterity, desc: "Attack speed and accuracy" },
            { name: "Fortune", value: baseStats.fortune, desc: "Critical hits and item discovery" },
            { name: "Charisma", value: baseStats.charisma, desc: "NPC interactions and shop prices" },
          ];

          stats.forEach((stat) => {
            const statBox = document.createElement("div");
            statBox.style.cssText = `
                        border: 2px solid #00ffff;
                        padding: 8px;
                        display: flex;
                        justify-content: space-between;
                        background: rgba(0, 0, 0, 0.5);
                        cursor: pointer;
                    `;

            const statName = document.createElement("span");
            statName.style.color = "#00ffff";
            statName.textContent = stat.name;

            const statValue = document.createElement("span");
            statValue.style.color = "#fff";
            statValue.textContent = stat.value;

            statBox.appendChild(statName);
            statBox.appendChild(statValue);

            statBox.addEventListener("click", () => {
              descriptionBox.textContent = stat.desc;
            });

            statsTable.appendChild(statBox);
          });

          // Add click handler for character header to restore class description
          document.querySelector(".character-header").addEventListener("click", () => {
            descriptionBox.textContent = currentDescription;
          });

          // Update HP/MP
          const resourcesBox = document.getElementById("resourcesBox");
          resourcesBox.innerHTML = `
                    <span>HP ${hp}</span>
                    <span>MP ${mp}</span>
                `;
        }

        // Set up navigation
        document.querySelector(".nav-arrow.prev").onclick = () => {
          currentIndex = (currentIndex - 1 + characters.length) % characters.length;
          updateDisplay();
        };

        document.querySelector(".nav-arrow.next").onclick = () => {
          currentIndex = (currentIndex + 1) % characters.length;
          updateDisplay();
        };

        document.querySelector(".choose-button").onclick = () => {
          const [key, char] = characters[currentIndex];
          createCharacter(key, currentStats); // Pass the stored stats
        };

        // Initialize display
        updateDisplay();
      }

      // Initialize the game
      window.onload = () => {
        initGame();
        gameLoop();

        // Initialize audio and check audio permissions
        document.addEventListener(
          "click",
          function initAudio() {
            // Play a silent sound to unlock audio
            console.log("Audio context unlocked by user interaction");
            AudioManager.init();
            AudioManager.play("click");
            // Remove this listener after first click
            document.removeEventListener("click", initAudio);
          },
          { once: true },
        );

        // Add a global click handler at the document level to ensure enemy interactions work
        document.addEventListener("click", function (e) {
          // Only process if we're in exploration mode
          if (
            GameStateManager &&
            GameStateManager.state &&
            GameStateManager.state.currentState === GAME_STATES.EXPLORATION
          ) {
            console.log("Document click detected, checking for enemies");

            // See if this was a click on the canvas
            const canvas = document.getElementById("gameCanvas");
            if (canvas) {
              const rect = canvas.getBoundingClientRect();
              if (
                e.clientX >= rect.left &&
                e.clientX <= rect.right &&
                e.clientY >= rect.top &&
                e.clientY <= rect.bottom
              ) {
                // Get canvas coordinates
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;

                // Convert to grid coordinates
                if (InputManager) {
                  const gridPos = InputManager.canvasToGridCoordinates(canvasX, canvasY);
                  if (gridPos) {
                    console.log(`Click detected at grid position (${gridPos.x}, ${gridPos.y})`);

                    // Check if we clicked on an enemy
                    if (EnemyManager && EnemyManager.enemies) {
                      const enemy = EnemyManager.enemies.find((e) => e.x === gridPos.x && e.y === gridPos.y);

                      if (enemy) {
                        console.log(`Found enemy ${enemy.name} at (${enemy.x}, ${enemy.y})! Initiating combat.`);
                        // Handle enemy interaction
                        InputManager.handleEnemyTap(enemy);
                        return;
                      }
                    }

                    // If not on enemy, check if on player
                    if (InputManager.isTapOnPlayer(gridPos.x, gridPos.y)) {
                      console.log("Click on player detected");
                      toggleCharacterScreen();
                    } else {
                      // Otherwise move player
                      InputManager.movePlayerToGrid(gridPos.x, gridPos.y);
                    }
                  }
                }
              }
            }
          }
        });
      };

      // Add these functions to handle save/load button clicks
      function saveGame() {
        GameStateManager.save();
      }

      function loadGame() {
        GameStateManager.load();
      }

      // Inventory Management
      function addItemToInventory(item) {
        const existingItem = GameStateManager.state.inventory.find((i) => i.id === item.id);

        if (existingItem) {
          existingItem.quantity += item.quantity;
        } else {
          GameStateManager.state.inventory.push({ ...item });
        }

        // Update UI if inventory screen is visible
        if (UIManager.elements.inventoryScreen.style.display === "block") {
          UIManager.updateInventoryUI();
        }

        UIManager.log(`Added ${item.quantity}x ${item.name} to inventory`);
      }

      function useItem(itemId) {
        const player = GameStateManager.state.player;
        const inventory = GameStateManager.state.inventory;

        // Find the item in inventory
        const inventoryItem = inventory.find((i) => i.id === itemId);
        if (!inventoryItem) {
          UIManager.log("Item not found in inventory!");
          return;
        }

        // Get the item definition
        const itemDefinition = Object.values(ITEMS).find((i) => i.id === itemId);
        if (!itemDefinition) {
          UIManager.log("Invalid item!");
          return;
        }

        // Ensure maxHp/maxMp are synced
        if (!player.maxHp) player.maxHp = player.derivedStats.maxHp;
        if (!player.maxMp) player.maxMp = player.derivedStats.maxMp;

        // Apply item effects
        switch (itemDefinition.type) {
          case "consumable":
            if (itemDefinition.effect === "heal") {
              const oldHp = player.hp;
              const maxHp = player.derivedStats.maxHp;
              player.hp = Math.min(player.hp + itemDefinition.value, maxHp);
              const healed = player.hp - oldHp;
              UIManager.log(`Used ${itemDefinition.name}! Restored ${healed} HP.`);
            } else if (itemDefinition.effect === "mana") {
              const oldMp = player.mp;
              const maxMp = player.derivedStats.maxMp;
              player.mp = Math.min(player.mp + itemDefinition.value, maxMp);
              const restored = player.mp - oldMp;
              UIManager.log(`Used ${itemDefinition.name}! Restored ${restored} MP.`);
            }
            break;
        }

        // Decrement quantity
        inventoryItem.quantity--;

        // Remove item if quantity is 0
        if (inventoryItem.quantity <= 0) {
          const index = inventory.indexOf(inventoryItem);
          if (index > -1) {
            inventory.splice(index, 1);
          }
        }

        // Update all UI elements to ensure consistent display
        UIManager.update();
        UIManager.updateInventoryUI();

        // Get the current active tab
        const activeTab = document.querySelector(".tab-button.active");
        if (activeTab) {
          const tabId = activeTab.getAttribute("data-tab");
          // Update character screen and switch back to the active tab
          UIManager.updateCharacterScreen();
          document.querySelector(`[data-tab="${tabId}"]`).click();
        }
      }

      // Sample items for testing
      const ITEMS = {
        HEALTH_POTION: {
          id: "health_potion",
          name: "Health Potion",
          type: "consumable",
          effect: "heal",
          value: 50,
          description: "Restores 50 HP when consumed",
          quantity: 1,
          iconUrl:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/HP-1ZKK6dAxTTGqM7n16hCEnobDxYAsv2.png?I1UO",
        },
        MANA_POTION: {
          id: "mana_potion",
          name: "Mana Potion",
          type: "consumable",
          effect: "mana",
          value: 30,
          description: "Restores 30 MP when consumed",
          quantity: 1,
          iconUrl:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/MP-ziN5NpopfuoTWmE8fTlnoncWgLhFM7.png?wMfk",
        },
      };

      // Helper function to calculate physical damage
      function calculatePhysicalDamage(attackerATK, defenderDEF) {
        return Math.max(1, Math.floor(attackerATK * (100 / (100 + defenderDEF))));
      }

      // Helper function to truncate button text to 15 characters
      function truncateButtonText(text, maxLength = 15) {
        // Reserve 5 characters for the cost/cooldown display: " (XX)"
        const maxNameLength = maxLength - 5;

        if (text.length <= maxNameLength) return text;

        // Split into words
        const words = text.split(" ");

        if (words.length === 1) {
          // Single word - truncate from both ends
          if (text.length > maxNameLength) {
            const charsFromEachEnd = Math.floor(maxNameLength / 2);
            return text.substring(0, charsFromEachEnd) + ".." + text.substring(text.length - charsFromEachEnd);
          }
          return text;
        }

        // Multiple words - try to keep first and last partial words
        if (words.length === 2) {
          const firstWord = words[0];
          const lastWord = words[1];
          const totalLength = firstWord.length + lastWord.length;
          const charsPerWord = Math.floor(maxNameLength / 2);

          return firstWord.substring(0, charsPerWord) + ".." + lastWord.substring(lastWord.length - charsPerWord);
        }

        // More than two words
        const firstWord = words[0];
        const lastWord = words[words.length - 1];
        const charsPerEnd = Math.floor(maxNameLength / 2) - 1;

        return firstWord.substring(0, charsPerEnd) + ".." + lastWord.substring(lastWord.length - charsPerEnd);
      }

      // Battle System
      const BattleSystem = {
        // Flag to prevent action spamming
        isActionInProgress: false,

        // Animation properties for battle idle animations
        animationFrameRate: 500, // milliseconds per frame (slowed down by 50%)
        lastFrameTime: 0,
        currentAnimationFrame: 0,
        animationTimers: {},
        debugAnimations: true, // Set to true to enable animation debugging

        // Animation frames for enemy types - using the working animation files pattern
        spaceGoblinIdleFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/IdleGob1-lAD0YuwStAmTVR5y5PLDLg9pgZDkWk.png?ulAb",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/IdleGob2-zv7jML6xoty4qMWhPbq5j6QqCaw7Hd.png?ZzzR",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/IdleGob3-xWaNuWPOC7oEsWqPM8IB4yh3pmlNvM.png?bSyw",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/IdleGob4-LrgjZsJ9HtjppJ3YR3w9TCZ3Mi17e1.png?RQ4W",
        ],
        spaceGoblinIdleFrameImages: [],

        // Cyber Orc animation frames
        cyberOrcIdleFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Orcidle1-tIHYu4iKpGIkvSeVxPFMXlVHcge99h.png?DMfe",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Orcidle2-MINruHfyfYteSoEnFEK2i2sL0eKWuw.png?pb5I",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Orcidle3-8x3RcmRZoaNEcy3QuxlTf2d46ibMLa.png?PoNF",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Orcidle4-6MF80s9THdUcfSaK8QGSyHUnvt0HrW.png?vrSw",
        ],
        cyberOrcIdleFrameImages: [],

        cyberOrcHitFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit1-Z3JxjiJ5lUV1RDd0BI2YciiXnC4rqx.png?jN4v",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit2-h4mQBbxIIL0TfvJ4MSrhYqXlnBy910.png?TqWl",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit3-W1S8bpuUt0VAGi6kryJuNGMjjA1qlZ.png?usrf",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit4-GmumGPXWv1ggmVGEXYCwZEWdieIWZp.png?NSc6",
        ],
        cyberOrcHitFrameImages: [],

        cyberOrcAttackFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot1-0UdRg4aj8OP1AWAR0Vq5nrsWGj0Pep.png?ADXW",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot2-Jxemlizz9MMFqXn36ZclwjOpwMqm96.png?gAo3",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot3-BhNo7CtJmCeEsEj9pSz7WaMYzWRAMV.png?PjlM",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot4-End5wwXjUv7JkLNvakyNzJeqcIvM37.png?MNJ2",
        ],
        cyberOrcAttackFrameImages: [],

        // Meta Troll animation frames
        metaTrollIdleFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Idle_1-k4ROEaNhVkwqcosB8UbbrlwNkYyb94.png?qrLx",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Idle_2-f7cpS5NytmHONIQnXIKAR0ZHIsSYq7.png?S2SG",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Idle_3-wV1Mr0FtV1hgxiqbQnIs6gnEahYeem.png?1B2L",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Idle_4-KWrZET3JkYQBdCBHz8kx4AdcwX6886.png?Q8Zy",
        ],
        metaTrollIdleFrameImages: [],

        metaTrollAttackFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_1-BcG4hrD1BZVmW0UkKQ1g1xTrMLTsGF.png?f2LA",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_2-bv2od1zpdNDbt3rrN3tzHC2wa0v6Uu.png?IkSe",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_3-qTXvBL3mNYlaGNfgkqopgvNFscgTrS.png?WubI",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_4-OtB270wajPYBFWrRVmXGleiGqJ8Wwj.png?VhAs",
        ],
        metaTrollAttackFrameImages: [],

        // Meta Troll damage frames
        metaTrollDamageFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_1-7HXxomEVKjjM0FrgxQxsrpTYLiHcwZ.png?4cGL",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_2-tpDFg7C9hgDajhb59B8C3OomKg0OAp.png?C5gY",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_3-XGOEsD0gi1PtjG4WejhRtsUP9ANT9A.png?ce1w",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_4-ME7OEC0JoKJFhH7asG5iORVeLfPY6D.png?u2fj",
        ],
        metaTrollDamageFrameImages: [],

        // Animation frames for player classes - using the working overworld animation files
        flexecutionerIdleFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexIdle1-dKEJbc2mGdesYoJ9gFfeAdFjdemJFt.png?5hsY",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexIdle2-dbGQIhB4InIp4cJ78fZS05JrBuqr2E.png?VcSb",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexIdle3-gqrHMyCgwTBPw2wBFoJwJIjc2RiKsZ.png?JjOJ",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexIdle4-1Gd50rBykVcq2AdD5oYoe9m09pRA8W.png?xmrK",
        ],
        flexecutionerIdleFrameImages: [],

        // Combat background images
        combatBackgrounds: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/CombatBG1-asfI5exK7uPuar3VsnzR2qZp4LYu7p.png?2Vc2",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/CombatBG2-Pn8lQig3i3jraYGHmrFokNhe0fNNPO.png?G21c",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/CombatBG3-3VVMDzQej8Hah5JrSGCixr8hHnAw7s.png?TKJW",
        ],
        isActive: false,
        currentEnemy: null,
        enemyGroup: [], // Array to hold multiple enemies of the same type
        currentEnemyIndex: 0, // Track which enemy in the group we're fighting
        turn: "player",
        selectedAction: null,
        actionQueue: [],
        targetingMode: false,
        currentTarget: null,

        preloadAnimationFrames() {
          // Preload Space Goblin idle frames if not already loaded
          if (this.spaceGoblinIdleFrameImages.length === 0) {
            this.spaceGoblinIdleFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Space Goblin animation frame ${index + 1} loaded`);
              };
              this.spaceGoblinIdleFrameImages.push(img);
            });
          }

          // Preload Cyber Orc idle frames
          if (this.cyberOrcIdleFrameImages.length === 0) {
            this.cyberOrcIdleFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Cyber Orc idle animation frame ${index + 1} loaded`);
              };
              this.cyberOrcIdleFrameImages.push(img);
            });
          }

          // Preload Cyber Orc hit frames
          if (this.cyberOrcHitFrameImages.length === 0) {
            this.cyberOrcHitFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Cyber Orc hit animation frame ${index + 1} loaded`);
              };
              this.cyberOrcHitFrameImages.push(img);
            });
          }

          // Preload Cyber Orc attack frames
          if (this.cyberOrcAttackFrameImages.length === 0) {
            this.cyberOrcAttackFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Cyber Orc attack animation frame ${index + 1} loaded`);
              };
              this.cyberOrcAttackFrameImages.push(img);
            });
          }

          // Preload Meta Troll idle frames
          if (this.metaTrollIdleFrameImages.length === 0) {
            this.metaTrollIdleFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Meta Troll idle animation frame ${index + 1} loaded`);
              };
              this.metaTrollIdleFrameImages.push(img);
            });
          }

          // Preload Meta Troll attack frames
          if (this.metaTrollAttackFrameImages.length === 0) {
            this.metaTrollAttackFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Meta Troll attack animation frame ${index + 1} loaded`);
              };
              this.metaTrollAttackFrameImages.push(img);
            });
          }

          // Preload Meta Troll damage frames
          if (this.metaTrollDamageFrameImages.length === 0) {
            this.metaTrollDamageFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Meta Troll damage animation frame ${index + 1} loaded`);
              };
              this.metaTrollDamageFrameImages.push(img);
            });
          }

          // Preload Flexecutioner idle frames if not already loaded
          if (this.flexecutionerIdleFrameImages.length === 0) {
            this.flexecutionerIdleFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Flexecutioner animation frame ${index + 1} loaded`);
              };
              this.flexecutionerIdleFrameImages.push(img);
            });
          }
        },

        updateAnimations(timestamp) {
          // Only update animations during battle
          if (!this.isActive) {
            if (this.debugAnimations) console.log("[Animation Debug] Battle not active, skipping animations");
            return;
          }

          // Check if enough time has passed for the next frame
          if (timestamp - this.lastFrameTime > this.animationFrameRate) {
            this.lastFrameTime = timestamp;
            const oldFrame = this.currentAnimationFrame;
            this.currentAnimationFrame = (this.currentAnimationFrame + 1) % this.spaceGoblinIdleFrames.length;

            if (this.debugAnimations) {
              console.log(`[Animation Debug] Animation frame changed: ${oldFrame} -> ${this.currentAnimationFrame}`);
              console.log(
                `[Animation Debug] Frame rate: ${this.animationFrameRate}ms, Time since last: ${timestamp - this.lastFrameTime}ms`,
              );
            }

            // Update all battle sprites with new frame
            this.updateBattleSprites();
          }
        },

        // Call this in the game loop to ensure animations are updated
        handleAnimationUpdates(timestamp) {
          // Process animations if in battle
          if (this.isActive) {
            this.updateAnimations(timestamp);

            // Debug - force an update every second regardless of framerate
            const now = Date.now();
            if (!this._lastForceUpdate || now - this._lastForceUpdate > 1000) {
              if (this.debugAnimations) console.log("[Animation Debug] Forcing animation update");
              this.updateAnimations(now);
              this._lastForceUpdate = now;
            }
          }
        },

        // Call this when starting battle to initialize animations
        initializeAnimations() {
          this.preloadAnimationFrames();
          this.currentAnimationFrame = 0;
          this.lastFrameTime = 0;
          if (this.debugAnimations) console.log("[Animation Debug] Animations initialized for battle");

          // Start the animation loop immediately
          this.startAnimationLoop();
        },

        // Start a dedicated animation timer for combat animations
        startAnimationLoop() {
          // Clear any existing animation timer
          if (this.animationTimer) {
            clearInterval(this.animationTimer);
          }

          // Create a new animation timer that runs every 250ms (4 frames per second)
          this.animationTimer = setInterval(() => {
            // Advance to the next frame
            this.currentAnimationFrame = (this.currentAnimationFrame + 1) % 4; // Assuming 4 frames

            // Log animation updates if debugging is enabled
            if (this.debugAnimations) {
              console.log(`[Animation Debug] Animation frame changed to ${this.currentAnimationFrame}`);
            }

            // Update the battle sprites with the new frame
            this.updateBattleSprites();
          }, 250); // Update every 250ms for smooth animation

          console.log("[Animation] Combat animation loop started");
        },

        // Stop the animation loop when battle ends
        stopAnimationLoop() {
          if (this.animationTimer) {
            clearInterval(this.animationTimer);
            this.animationTimer = null;
            console.log("[Animation] Combat animation loop stopped");
          }
        },

        // Get the appropriate battle sprite based on entity type and animation frame
        getBattleSprite(entity) {
          // Make sure animation frame is valid
          if (this.currentAnimationFrame === undefined) {
            this.currentAnimationFrame = 0;
          }

          // For enemies
          if (entity.type === "enemy" || (!entity.type && entity.name)) {
            // Use animation frames for Space Goblin
            if (
              entity.name === "Space Goblin" &&
              this.spaceGoblinIdleFrameImages &&
              this.spaceGoblinIdleFrameImages.length > 0
            ) {
              // Ensure index is within bounds
              const frameIndex = this.currentAnimationFrame % this.spaceGoblinIdleFrameImages.length;
              const frame = this.spaceGoblinIdleFrameImages[frameIndex];
              if (frame && frame.complete) {
                console.log(`[Animation Debug] Using Space Goblin frame ${frameIndex}`);
                return frame;
              }
            }

            // Use animation frames for Cyber Orc
            if (
              entity.name === "Cyber Orc" &&
              this.cyberOrcIdleFrameImages &&
              this.cyberOrcIdleFrameImages.length > 0
            ) {
              // Ensure index is within bounds
              const frameIndex = this.currentAnimationFrame % this.cyberOrcIdleFrameImages.length;
              const frame = this.cyberOrcIdleFrameImages[frameIndex];
              if (frame && frame.complete) {
                console.log(`[Animation Debug] Using Cyber Orc idle frame ${frameIndex}`);
                return frame;
              }
            }

            // Use animation frames for Meta Troll
            if (
              entity.name === "Meta Troll" &&
              this.metaTrollIdleFrameImages &&
              this.metaTrollIdleFrameImages.length > 0
            ) {
              // Ensure index is within bounds
              const frameIndex = this.currentAnimationFrame % this.metaTrollIdleFrameImages.length;
              const frame = this.metaTrollIdleFrameImages[frameIndex];
              if (frame && frame.complete) {
                console.log(`[Animation Debug] Using Meta Troll idle frame ${frameIndex}`);
                return frame;
              }
            }

            // For other enemy types, fall back to static sprite
            return entity.sprite;
          }

          // For player characters
          if (entity.type === "player" || (!entity.type && entity.class)) {
            // Use player class to determine animation - note that player class may be uppercase
            const isFlexecutioner = entity.class && entity.class.toUpperCase() === "FLEXECUTIONER";
            if (isFlexecutioner && this.flexecutionerIdleFrameImages && this.flexecutionerIdleFrameImages.length > 0) {
              // Ensure index is within bounds
              const frameIndex = this.currentAnimationFrame % this.flexecutionerIdleFrameImages.length;
              const frame = this.flexecutionerIdleFrameImages[frameIndex];
              if (frame && frame.complete) {
                console.log(`[Animation Debug] Using Flexecutioner frame ${frameIndex}`);
                return frame;
              }
            }

            // Fall back to static sprite for other classes
            return entity.sprite;
          }

          // Default fallback
          return entity.sprite;
        },

        // Update all sprite images in the battle UI
        updateBattleSprites() {
          if (this.debugAnimations) console.log("[Animation Debug] Updating battle sprites...");

          // Update enemy sprites
          const enemySide = document.getElementById("enemySide");
          if (!enemySide) {
            if (this.debugAnimations) console.log("[Animation Debug] ERROR: enemySide not found in DOM");
            return;
          }

          // Update enemy container
          const enemyContainer = enemySide.querySelector(".enemy-container");
          if (enemyContainer) {
            const img = enemyContainer.querySelector("img");
            if (img && this.currentEnemy) {
              if (this.currentEnemy.name === "Space Goblin") {
                // Use the preloaded image object instead of URL
                if (this.spaceGoblinIdleFrameImages && this.spaceGoblinIdleFrameImages.length > 0) {
                  const spriteImg = this.spaceGoblinIdleFrameImages[this.currentAnimationFrame];
                  if (spriteImg && spriteImg.complete) {
                    if (this.debugAnimations)
                      console.log(
                        `[Animation Debug] Updating Space Goblin sprite to frame ${this.currentAnimationFrame}`,
                      );
                    img.src = spriteImg.src;
                  } else {
                    // Fallback to URL if image isn't loaded
                    const spriteUrl = this.spaceGoblinIdleFrames[this.currentAnimationFrame];
                    if (spriteUrl) {
                      if (this.debugAnimations)
                        console.log(`[Animation Debug] Falling back to URL for Space Goblin: ${spriteUrl}`);
                      img.src = spriteUrl;
                    }
                  }
                }
              } else if (this.currentEnemy.name === "Cyber Orc") {
                // Use the preloaded image object instead of URL for Cyber Orc
                if (this.cyberOrcIdleFrameImages && this.cyberOrcIdleFrameImages.length > 0) {
                  const spriteImg = this.cyberOrcIdleFrameImages[this.currentAnimationFrame];
                  if (spriteImg && spriteImg.complete) {
                    if (this.debugAnimations)
                      console.log(`[Animation Debug] Updating Cyber Orc sprite to frame ${this.currentAnimationFrame}`);
                    img.src = spriteImg.src;
                  } else {
                    // Fallback to URL if image isn't loaded
                    const spriteUrl = this.cyberOrcIdleFrames[this.currentAnimationFrame];
                    if (spriteUrl) {
                      if (this.debugAnimations)
                        console.log(`[Animation Debug] Falling back to URL for Cyber Orc: ${spriteUrl}`);
                      img.src = spriteUrl;
                    }
                  }
                }
              } else if (this.currentEnemy.name === "Meta Troll") {
                // Use the preloaded image object instead of URL for Meta Troll
                if (this.metaTrollIdleFrameImages && this.metaTrollIdleFrameImages.length > 0) {
                  const spriteImg = this.metaTrollIdleFrameImages[this.currentAnimationFrame];
                  if (spriteImg && spriteImg.complete) {
                    if (this.debugAnimations)
                      console.log(
                        `[Animation Debug] Updating Meta Troll sprite to frame ${this.currentAnimationFrame}`,
                      );
                    img.src = spriteImg.src;
                  } else {
                    // Fallback to URL if image isn't loaded
                    const spriteUrl = this.metaTrollIdleFrames[this.currentAnimationFrame];
                    if (spriteUrl) {
                      if (this.debugAnimations)
                        console.log(`[Animation Debug] Falling back to URL for Meta Troll: ${spriteUrl}`);
                      img.src = spriteUrl;
                    }
                  }
                }
              } else {
                if (this.debugAnimations)
                  console.log(
                    `[Animation Debug] Enemy ${this.currentEnemy.name} is not animated, no animation applied`,
                  );
              }
            } else {
              if (this.debugAnimations) console.log("[Animation Debug] ERROR: enemy image or current enemy not found");
            }
          } else {
            if (this.debugAnimations) console.log("[Animation Debug] ERROR: enemyContainer not found in DOM");
          }

          // Update player sprites
          const playerSide = document.getElementById("playerSide");
          if (!playerSide) {
            if (this.debugAnimations) console.log("[Animation Debug] ERROR: playerSide not found in DOM");
            return;
          }

          const playerContainer = playerSide.querySelector(".player-container");
          if (playerContainer) {
            const img = playerContainer.querySelector("img");
            const player = GameStateManager.state.player;
            if (img && player) {
              if (player.class && player.class.toUpperCase() === "FLEXECUTIONER") {
                // Use the preloaded image object instead of URL
                if (this.flexecutionerIdleFrameImages && this.flexecutionerIdleFrameImages.length > 0) {
                  const spriteImg = this.flexecutionerIdleFrameImages[this.currentAnimationFrame];
                  if (spriteImg && spriteImg.complete) {
                    if (this.debugAnimations)
                      console.log(
                        `[Animation Debug] Updating Flexecutioner sprite to frame ${this.currentAnimationFrame}`,
                      );
                    img.src = spriteImg.src;
                  } else {
                    // Fallback to URL if image isn't loaded
                    const spriteUrl = this.flexecutionerIdleFrames[this.currentAnimationFrame];
                    if (spriteUrl) {
                      if (this.debugAnimations)
                        console.log(`[Animation Debug] Falling back to URL for Flexecutioner: ${spriteUrl}`);
                      img.src = spriteUrl;
                    }
                  }
                }
              } else {
                if (this.debugAnimations)
                  console.log(
                    `[Animation Debug] Player class is "${player.class}", not Flexecutioner, no animation applied`,
                  );
              }
            } else {
              if (this.debugAnimations) console.log("[Animation Debug] ERROR: player image or player object not found");
            }
          } else {
            if (this.debugAnimations) console.log("[Animation Debug] ERROR: playerContainer not found in DOM");
          }
        },

        createMiniBattleUI() {
          // Create battle UI elements for mini-games
        },

        displayMiniMessage(message) {
          // Display battle message in mini-games
          console.log(message);
        },

        endMiniBattle() {
          // End mini-battle
          this.isActive = false;
          this.currentEnemy = null;
          // Return to game state
          GameStateManager.state.currentState = GAME_STATES.EXPLORE;
        },

        executeMiniBattleAction(action) {
          // Execute player action in mini-games
        },

        startMiniBattle(enemy) {
          // Start mini-battle with enemy
          this.isActive = true;
          this.currentEnemy = enemy;
        },

        processMiniBattleEnemyTurn() {
          // Process enemy turn in mini-games
        },

        checkMiniBattleEnd() {
          // Check if mini-battle has ended
          return !this.isActive;
        },

        handleMiniBattlePlayerDeath() {
          // Handle player death in mini-games
          this.endMiniBattle();
          // Game over state
          GameStateManager.state.currentState = GAME_STATES.GAME_OVER;
        },

        startBattle(enemy) {
          if (this.isActive) {
            console.log("[Battle Start] Battle already in progress");
            return;
          }
          if (!enemy) {
            console.error("No enemy provided to startBattle");
            return;
          }

          // Set game state to battle
          GameStateManager.state.currentState = GAME_STATES.BATTLE;

          // Initialize animations
          this.initializeAnimations();

          // Initialize player if needed
          const player = GameStateManager.state.player;

          // Select a random combat background
          const randomBgIndex = Math.floor(Math.random() * this.combatBackgrounds.length);
          const selectedBackground = this.combatBackgrounds[randomBgIndex];

          console.log("[Battle Debug] Background URLs:", this.combatBackgrounds);
          console.log("[Battle Debug] Selected background index:", randomBgIndex);
          console.log("[Battle Debug] Selected background URL:", selectedBackground);

          // Apply the background to the battleSides container
          const battleSidesElement = document.getElementById("battleSides");
          console.log("[Battle Debug] BattleSides element exists:", !!battleSidesElement);

          // This will be delayed to make sure the element is ready
          setTimeout(() => {
            const battleSidesElement = document.getElementById("battleSides");
            if (battleSidesElement) {
              // Set background with important flags to override any other styles
              battleSidesElement.style.cssText += `
                background-image: url('${selectedBackground}') !important;
                background-size: cover !important;
                background-position: center !important;
                background-repeat: no-repeat !important;
                z-index: 0 !important;
              `;
              console.log("[Battle Debug] Applied background with URL:", selectedBackground);
              console.log("[Battle Debug] Current battleSides style:", battleSidesElement.style.cssText);
            } else {
              console.error("[Battle Debug] BattleSides element not found after delay");
            }
          }, 300); // Small delay to ensure UI is ready

          // Reset enemy index for the new battle
          this.currentEnemyIndex = 0;

          // Create a group of enemies for this battle
          // For now, we'll generate 1-3 enemies of randomly selected types
          this.enemyGroup = [];

          // First, add the encountered enemy to the group
          this.enemyGroup.push(enemy);

          // Randomly add 0-2 more enemies of different types
          const enemyTypes = ["Space Goblin", "Meta Troll", "Cyber Orc"];

          // Determine how many additional enemies to add (0-2)
          const additionalEnemies = Math.floor(Math.random() * 3);
          console.log(`[Battle Start] Adding ${additionalEnemies} additional enemies to the battle`);

          for (let i = 0; i < additionalEnemies; i++) {
            // Select a random enemy type
            const randomType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

            // Get base stats for this enemy type
            const enemyStats = EnemyManager.getEnemyStatsByType(randomType);

            if (enemyStats) {
              // Create a new enemy object
              const newEnemy = {
                name: randomType,
                stats: {
                  hp: enemyStats.hp,
                  maxHp: enemyStats.hp,
                  attack: enemyStats.attack,
                  defense: enemyStats.defense,
                },
                maxHp: enemyStats.hp,
                hp: enemyStats.hp,
                exp: enemyStats.exp || 10,
                gold: enemyStats.gold || 5,
              };

              // Get sprite URL based on enemy type
              const spriteUrl = EnemyManager.enemySprites[randomType] || EnemyManager.enemySprites["default"];
              const spriteImg = new Image();
              spriteImg.src = spriteUrl;
              newEnemy.sprite = spriteImg;

              // Add to the enemy group
              this.enemyGroup.push(newEnemy);
              console.log(`[Battle Start] Added ${randomType} to the battle group`);
            }
          }

          // Select the first enemy in the group as the current enemy
          this.currentEnemy = this.enemyGroup[this.currentEnemyIndex];
          console.log(`[Battle Start] Total enemies in battle: ${this.enemyGroup.length}`);
          console.log(`[Battle Start] First enemy: ${this.currentEnemy.name}`);

          if (!player.stats) {
            player.stats = {
              strength: 10,
              defense: 5,
              intelligence: 8,
              vitality: 10,
              dexterity: 8,
            };
          }
          if (!player.derivedStats) {
            player.derivedStats = {
              maxHp: 100,
              maxMp: 50,
            };
          }
          if (typeof player.hp !== "number") {
            player.hp = player.derivedStats.maxHp;
          }
          if (typeof player.mp !== "number") {
            player.mp = player.derivedStats.maxMp;
          }

          // Hide game log during battle
          const gameLog = document.getElementById("gameLog");
          if (gameLog) {
            gameLog.style.display = "none";
          }

          // Initialize enemy stats
          enemy.maxHp = enemy.stats.hp || 30;
          enemy.hp = enemy.maxHp;
          enemy.stats = enemy.stats || {
            hp: 30,
            maxHp: 30,
            attack: 5,
            defense: 2,
          };

          // Set base stats
          enemy.maxHp = enemy.stats.maxHp;
          enemy.hp = enemy.maxHp;
          enemy.strength = enemy.stats.attack;
          enemy.defense = enemy.stats.defense;
          enemy.derivedStats = {
            defense: enemy.stats.defense,
            magicDefense: Math.floor(enemy.stats.defense / 2),
            blockChance: 0,
            maxHp: enemy.maxHp,
          };

          // Ensure all numeric stats are properly initialized
          enemy.hp = Number(enemy.hp) || enemy.maxHp;
          enemy.strength = Number(enemy.strength) || enemy.stats.attack;
          enemy.defense = Number(enemy.defense) || enemy.stats.defense;

          // Create battle UI elements if they don't exist
          if (!document.getElementById("battleUI")) {
            const battleUI = document.createElement("div");
            battleUI.id = "battleUI";
            battleUI.style.cssText = `
                        position: fixed;
                        top: 2px;
                        left: 2px;
                        right: 2px;
                        bottom: 2px;
                        background: rgba(0, 0, 0, 0.7);
                        border: 2px solid #444;
                        display: flex;
                        flex-direction: column;
                        z-index: 1000;
                    `;
            document.body.appendChild(battleUI);

            // Create battle sides container
            const battleSides = document.createElement("div");
            battleSides.id = "battleSides";
            battleSides.style.cssText = `
                        display: flex;
                        justify-content: space-between;
                        padding: 3px;
                        gap: 5px;
                        flex: 1;
                        position: relative;
                        background-image: none;
                        background-size: cover;
                        background-position: center;
                        background-repeat: no-repeat;
                        min-height: 300px;
                    `;
            console.log("[Battle Debug] Created battleSides container with ID:", battleSides.id);
            battleUI.appendChild(battleSides);

            // Create combat animation container
            const combatAnimationContainer = document.createElement("div");
            combatAnimationContainer.id = "combatAnimationContainer";
            combatAnimationContainer.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        pointer-events: none;
                        z-index: 5;
                    `;
            battleSides.appendChild(combatAnimationContainer);

            // Create player side
            const playerSide = document.createElement("div");
            playerSide.id = "playerSide";
            playerSide.style.cssText = `
                        width: 195px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        padding: 5px;
                        background: rgba(0, 0, 0, 0.5);
                        border: 1px solid #444;
                        border-radius: 4px;
                        margin: 5px;
                        box-sizing: border-box;
                        z-index: 2;
                    `;
            battleSides.appendChild(playerSide);

            // Create enemy side
            const enemySide = document.createElement("div");
            enemySide.id = "enemySide";
            enemySide.style.cssText = `
                        width: 170px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        padding: 5px;
                        background: rgba(0, 0, 0, 0.5);
                        border: 1px solid #444;
                        border-radius: 4px;
                        margin: 5px;
                        box-sizing: border-box;
                        z-index: 2;
                    `;
            battleSides.appendChild(enemySide);

            // Create message container
            const messageContainer = document.createElement("div");
            messageContainer.id = "battleMessageContainer";
            messageContainer.style.cssText = `
                        position: absolute;
                        bottom: 120px;
                        left: 50%;
                        transform: translateX(-50%);
                        width: 80%;
                        max-width: 600px;
                        background: rgba(0, 0, 0, 0.9);
                        border: 1px solid #444;
                        border-radius: 4px;
                        padding: 10px;
                        z-index: 1002;
                    `;
            battleUI.appendChild(messageContainer);

            // Create message area
            const messageArea = document.createElement("div");
            messageArea.id = "battleMessages";
            messageArea.style.cssText = `
                        height: 100px;
                        overflow-y: auto;
                        color: #00ffff;
                        font-size: 12px;
                        line-height: 1.4;
                    `;
            messageContainer.appendChild(messageArea);
          }

          // Don't override the currentEnemy that was set from the enemyGroup
          this.isActive = true;
          this.turn = "player";
          this.targetingMode = false;
          this.currentTarget = null;

          // Show battle UI and its components
          const battleUI = document.getElementById("battleUI");
          const playerSide = document.getElementById("playerSide");
          const enemySide = document.getElementById("enemySide");
          const battleSides = document.getElementById("battleSides");

          if (battleUI) {
            battleUI.style.display = "flex";
            battleUI.style.opacity = "1";
            battleUI.style.pointerEvents = "auto";
          }
          if (playerSide) {
            playerSide.style.display = "flex";
            playerSide.style.opacity = "1";
            playerSide.style.pointerEvents = "auto";
          }
          if (enemySide) {
            enemySide.style.display = "flex";
            enemySide.style.opacity = "1";
            enemySide.style.pointerEvents = "auto";
          }
          if (battleSides) {
            battleSides.style.display = "flex";
            battleSides.style.opacity = "1";
            battleSides.style.pointerEvents = "auto";
          }

          this.updateUI();
          this.showBattleMenu();
        },

        calculateDamage(attacker, defender, isMagic = false, now = Date.now()) {
          if (!attacker || !defender) return { damage: 0, wasBlocked: false };

          console.log("Damage Calculation Debug:");
          console.log("Attacker:", attacker);
          console.log("Defender:", defender);
          console.log("Is Magic:", isMagic);

          // Get base stats and tiers
          let attackStat = 0;
          if (attacker.stats && attacker.stats.fortune !== undefined) {
            // Player stats - normal damage
            attackStat = Math.floor(Number(isMagic ? attacker.stats.intelligence : attacker.stats.strength)) || 1;
            console.log("Player attack stat:", attackStat);

            // Check for Nitric Aura (8% crit rate when HP > 75%)
            if (
              attacker.class === "FLEXECUTIONER" &&
              attacker.hp > attacker.maxHp * 0.75 &&
              attacker.unlockedSkills?.includes("nitricAura")
            ) {
              attacker.stats.fortune += 8;
              console.log("Nitric Aura active: +8% crit chance");
            }

            // Check for Plyometric Guard (30% damage after dodging)
            if (
              attacker.class === "FLEXECUTIONER" &&
              attacker.lastDodgeTime &&
              now - attacker.lastDodgeTime < 5000 &&
              attacker.unlockedSkills?.includes("plyometricGuard")
            ) {
              attackStat = Math.floor(attackStat * 1.3);
              console.log("Plyometric Guard active: +30% damage");
            }
          } else {
            // Enemy stats - normal damage
            attackStat = Math.floor(Number(isMagic ? attacker.intelligence : attacker.attack)) || 1;
            console.log("Enemy attack stat:", attackStat);
          }

          // Apply buffs if they exist
          if (attacker.buffs) {
            attacker.buffs.forEach((buff) => {
              if (buff.effect === "buff") {
                attackStat += Number(buff.strength) || 0;
              }
            });
            console.log("Attack stat after buffs:", attackStat);
          }

          // Get defense stat
          let defenseStat = 0;
          if (defender.derivedStats) {
            defenseStat = Number(isMagic ? defender.derivedStats.magicDefense : defender.derivedStats.defense) || 0;
            console.log("Defense from derivedStats:", defenseStat);

            // Check for Form Check (10% damage reduction if not moved)
            if (
              defender.class === "FLEXECUTIONER" &&
              defender.lastMoveTime &&
              now - defender.lastMoveTime > 1000 &&
              defender.unlockedSkills?.includes("formCheck")
            ) {
              defenseStat = Math.floor(defenseStat * 1.1);
              console.log("Form Check active: +10% defense");
            }
          } else if (defender.stats) {
            defenseStat = Number(defender.stats.defense) || 0;
            if (isMagic) {
              defenseStat = Math.floor(defenseStat / 2);
            }
            console.log("Defense from stats:", defenseStat);
          }

          // Calculate tiers and damage
          const tier = getTier(attacker.stats, {
            name: "DICE_PROGRESSION",
            stat: isMagic ? "intelligence" : "strength",
          });
          const critTier = getTier(attacker.stats, { name: "CRITICAL_SYSTEM", stat: "fortune" });
          const penTier = getTier(attacker.stats, {
            name: "PENETRATION_SYSTEM",
            stat: isMagic ? "intelligence" : "strength",
          });

          console.log("Combat Tiers:", { tier, critTier, penTier });

          // Check if dodge successful
          const dodgeChance = defender.derivedStats?.evasion || 0;
          const isDodged = Math.random() < dodgeChance / 100;
          if (isDodged) {
            console.log("Attack dodged!");
            // Set lastDodgeTime for Plyometric Guard
            if (defender.class === "FLEXECUTIONER" && defender.unlockedSkills?.includes("plyometricGuard")) {
              defender.lastDodgeTime = now;
              console.log("Plyometric Guard primed!");
            }
            return { damage: 0, wasBlocked: false, isDodged: true };
          }

          // Calculate base damage with improved scaling
          const diceSystem = COMBAT_SYSTEMS.DICE_PROGRESSION[tier];
          const diceRolls = Math.floor(attackStat / 15) + 1; // Reduced dice rolls scaling

          // Actually roll the dice to add randomness - using a standard d6 (6-sided die)
          let diceSum = 0;
          for (let i = 0; i < diceRolls; i++) {
            // Roll a standard d6 die (1-6)
            const diceValue = Math.floor(Math.random() * 6) + 1;
            diceSum += diceValue;
          }

          // Base damage now combines the fixed stat multiplier with the random dice rolls
          const statMultiplier = Math.floor(attackStat * diceSystem.multiplier);
          const baseDamage = statMultiplier + diceSum;
          console.log("Dice rolls:", diceRolls, "with sum:", diceSum);
          console.log("Base damage after tier:", baseDamage);

          // Apply defense penetration
          const penetration = COMBAT_SYSTEMS.PENETRATION_SYSTEM[penTier].penetration;
          const effectiveDefense = Math.floor(defenseStat * (1 - penetration));
          const damageAfterDefense = Math.max(1, Math.floor(baseDamage - effectiveDefense));
          console.log("Damage after defense:", damageAfterDefense);

          // Check for critical hit
          const critChance = (attacker.stats?.fortune || 0) * 0.01;
          const isCritical = Math.random() < critChance;
          let finalDamage = isCritical
            ? Math.floor(damageAfterDefense * COMBAT_SYSTEMS.CRITICAL_SYSTEM[critTier].multiplier)
            : damageAfterDefense;
          console.log("Final damage:", finalDamage);

          // Check for block
          if (!isMagic && defender.derivedStats && defender.derivedStats.blockChance > 0) {
            if (Math.random() < defender.derivedStats.blockChance) {
              const blockedDamage = Math.max(1, Math.floor(finalDamage * 0.5));
              console.log("Damage was blocked! Reduced to:", blockedDamage);
              return {
                damage: blockedDamage,
                wasBlocked: true,
                isCritical,
              };
            }
          }

          // Check for passive skill effects
          if (attacker.class === "FLEXECUTIONER") {
            // Form Check passive (10% damage reduction when not moving)
            if (defender.lastMoveTime && now - defender.lastMoveTime > 1000) {
              finalDamage = Math.floor(finalDamage * 0.9); // 10% damage reduction
              console.log("Form Check activated: 10% damage reduction");
            }

            // Plyometric Guard passive (30% damage boost after dodge)
            if (attacker.plyometricGuardActive) {
              finalDamage = Math.floor(finalDamage * 1.3); // 30% damage boost
              attacker.plyometricGuardActive = false; // Use up the boost
              console.log("Plyometric Guard activated: 30% damage boost");
            }

            // Nitric Aura passive (8% crit rate when HP > 75%)
            if (attacker.hp / attacker.derivedStats.maxHp > 0.75) {
              const extraCritChance = 0.08; // 8% extra crit chance
              if (Math.random() < extraCritChance) {
                finalDamage = Math.floor(finalDamage * 1.5); // Critical hit!
                console.log("Nitric Aura activated: Critical hit!");
              }
            }
          }

          // Check for other special effects
          const effects = checkSpecialEffects(attacker, defender);
          if (effects.length > 0) {
            console.log("Special effects applied:", effects);
            effects.forEach((effect) => {
              switch (effect) {
                case "stun":
                  defender.stunned = true;
                  break;
                case "cleave":
                  // Apply cleave damage to nearby enemies
                  break;
                case "execute":
                  // Deal extra damage if target is below 20% HP
                  if (defender.hp / defender.maxHp < 0.2) {
                    finalDamage *= 1.5;
                    console.log("Execute effect triggered! Damage increased by 50%");
                  }
                  break;
                case "lifesteal":
                  // Heal for a portion of damage dealt
                  const healAmount = Math.floor(finalDamage * 0.1);
                  attacker.hp = Math.min(attacker.derivedStats.maxHp, attacker.hp + healAmount);
                  console.log("Lifesteal effect triggered! Healed for:", healAmount);
                  break;
              }
            });
          }

          return {
            damage: finalDamage,
            wasBlocked: false,
            isCritical,
            effects: effects,
          };
        },

        // Process the defeat of the current enemy and move to the next one if available
        processEnemyDefeat() {
          // Track rewards from the defeated enemy
          const defeatedEnemy = this.currentEnemy;
          // Make sure we're getting values from the right properties
          let earnedXP = defeatedEnemy.exp || defeatedEnemy.drops?.xp || 10;
          let earnedGold = defeatedEnemy.gold || defeatedEnemy.drops?.gold || 5;

          // Play victory sound
          AudioManager.play("victory");

          // Check if we're already at the last enemy
          if (this.currentEnemyIndex + 1 >= this.enemyGroup.length) {
            // This was the last enemy, battle is complete
            // Don't increment the index since we're done
            console.log(
              `[Enemy Defeat] Last enemy (${defeatedEnemy.name}) defeated. Index: ${this.currentEnemyIndex}, Total: ${this.enemyGroup.length}`,
            );
            return { battleComplete: true, xp: earnedXP, gold: earnedGold };
          }

          // We have more enemies to fight, so move to the next one
          this.currentEnemyIndex++;

          // Set the next enemy as the current enemy
          this.currentEnemy = this.enemyGroup[this.currentEnemyIndex];

          // Ensure the sprite property is properly set for the next enemy
          const enemyName = this.currentEnemy.name;
          // Get sprite URL based on enemy type from our dictionary
          let spriteUrl = EnemyManager.enemySprites[enemyName] || EnemyManager.enemySprites["default"];

          // Create a new Image object every time to avoid object reference issues
          const spriteImg = new Image();
          spriteImg.src = spriteUrl;
          this.currentEnemy.sprite = spriteImg;

          // Update battle UI with the full updateUI instead of just updating stats
          this.updateUI();

          // Show a message that we're moving to the next enemy
          const messageSystem = document.querySelector("#battleMessages");
          if (messageSystem) {
            const msg = document.createElement("div");
            msg.textContent = `${defeatedEnemy.name} defeated! Next opponent appears...`;
            messageSystem.appendChild(msg);
            messageSystem.scrollTop = messageSystem.scrollHeight;
          }

          console.log(
            `[Enemy Defeat] Moving to next enemy. Index: ${this.currentEnemyIndex}, Total: ${this.enemyGroup.length}`,
          );
          return { battleComplete: false, xp: earnedXP, gold: earnedGold };
        },

        showBattleMenu() {
          console.log("[showBattleMenu] Called");
          if (this.turn === "enemy") return;

          // Remove any existing menu first
          const existingMenu = document.getElementById("BattleMenu");
          if (existingMenu) {
            existingMenu.remove();
          }

          // Create menu container with 3-column layout
          const menuContainer = document.createElement("div");
          menuContainer.id = "BattleMenu";
          menuContainer.className = "battle-menu-box";
          menuContainer.style.cssText = `
                    background: rgba(0, 0, 0, 0.93);
                    border: 3px solid #00ffff;
                    border-radius: 8px 8px 0 0;
                    box-shadow: 0 -2px 32px #00ffff33;
                    color: #00ffff;
                    font-family: 'Courier New', Courier, monospace;
                    letter-spacing: 1px;
                    display: grid;
                    grid-template-columns: 1fr 1fr 1fr;
                    gap: 3px;
                    position: absolute;
                    bottom: 12px;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 320px;
                    max-width: 95vw;
                    z-index: 20;
                    padding: 5px 5px 4px 5px;
                `;

          // Define button layout
          const buttonLayout = [
            [
              { text: "Attack", action: "attack" },
              { text: "Cast", action: "cast" },
            ],
            [
              { text: "Skills", action: "skill" },
              { text: "Use", action: "use" },
            ],
            [{ text: "Flee", action: "flee" }],
          ];

          // Create columns
          buttonLayout.forEach((column, colIndex) => {
            const columnDiv = document.createElement("div");
            Object.assign(columnDiv.style, {
              display: "flex",
              flexDirection: "column",
              gap: "5px",
            });

            column.forEach((btn) => {
              const button = document.createElement("button");
              console.log(`[showBattleMenu] Creating button: ${btn.text}, action: ${btn.action}`);
              Object.assign(button.style, {
                padding: "4px 4px",
                background: "rgba(0,0,0,0.7)",
                border: "2px solid #00ffff",
                borderRadius: "4px",
                color: "#00ffff",
                cursor: "pointer",
                fontWeight: "bold",
                fontSize: "10px",
                textShadow: "0 0 6px #000, 0 0 12px #00ffff44",
                margin: "1px 0",
                fontFamily: "'Courier New', Courier, monospace",
                letterSpacing: "1px",
                transition: "background 0.2s, border 0.2s",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                height: "38px",
              });
              button.textContent = truncateButtonText(btn.text);
              button.onclick = () => {
                console.log(`[showBattleMenu] Button clicked: ${btn.text}, action: ${btn.action}`);
                this.handleAction(btn.action);
              };
              columnDiv.appendChild(button);
            });

            menuContainer.appendChild(columnDiv);
          });

          document.getElementById("battleUI").appendChild(menuContainer);
        },

        handleAction(action) {
          console.log("[handleAction] Called with action:", action);
          switch (action) {
            case "attack":
              this.attack(this.currentEnemy);
              break;
            case "cast":
              this.currentPage = 0; // Reset page counter
              this.showSubMenu("spells");
              break;
            case "skill":
              this.currentPage = 0; // Reset page counter
              this.showSubMenu("skills");
              break;
            case "use":
              this.currentPage = 0; // Reset page counter
              this.showSubMenu("items");
              break;
            case "flee":
              this.flee();
              break;
          }
        },

        showSubMenu(type) {
          console.log("[showSubMenu] Called with type:", type);
          const menuContainer = document.getElementById("BattleMenu");
          console.log("[showSubMenu] menuContainer:", menuContainer);
          if (!menuContainer) {
            console.error("[showSubMenu] menuContainer not found!");
            return;
          }

          // Clear previous menu (safe, as all elements are recreated below)
          menuContainer.innerHTML = "";
          console.log("[showSubMenu] Cleared menuContainer.innerHTML");

          // Get items for the menu
          let items = [];
          const player = GameStateManager.state.player;
          console.log("[showSubMenu] Player:", player);
          switch (type) {
            case "spells":
              items = player.spells || [];
              break;
            case "skills":
              // Filter out passive skills for battle menu
              items = (player.skills || []).filter((skill) => {
                // Check if the skill exists and is not passive type
                return skill && skill.type !== "passive";
              });
              break;
            case "items":
              items = GameStateManager.state.inventory || [];
              break;
          }

          // Initialize page counter if not set
          if (typeof this.currentPage !== "number") {
            this.currentPage = 0;
          }
          console.log("[showSubMenu] items:", items, "length:", items.length);

          // If no items, show message and back button
          if (!items || items.length === 0) {
            const messageContainer = document.createElement("div");
            messageContainer.style.cssText = `
                        display: flex;
                        flex-direction: row;
                        align-items: center;
                        justify-content: space-between;
                        width: 100%;
                        padding: 5px 8px;
                        gap: 5px;
                    `;

            const message = document.createElement("div");
            message.style.cssText = `
                        color: #00ffff;
                        text-align: left;
                        padding: 5px;
                        font-size: 12px;
                        flex: 1;
                    `;
            message.textContent = `No ${type} available.`;

            const backButton = document.createElement("button");
            Object.assign(backButton.style, {
              padding: "4px 4px",
              background: "rgba(0,0,0,0.7)",
              border: "2px solid #00ffff",
              borderRadius: "4px",
              color: "#00ffff",
              cursor: "pointer",
              fontWeight: "bold",
              fontSize: "10px",
              textShadow: "0 0 6px #000, 0 0 12px #00ffff44",
              margin: "1px 0",
              fontFamily: "'Courier New', Courier, monospace",
              letterSpacing: "1px",
              transition: "background 0.2s, border 0.2s",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              minHeight: "38px",
              minWidth: "80px",
            });
            backButton.textContent = "Back";
            backButton.onclick = () => {
              this.showBattleMenu();
            };

            messageContainer.appendChild(message);
            messageContainer.appendChild(backButton);
            menuContainer.appendChild(messageContainer);
            return;
          }

          // Create menu items container with 3x2 grid
          const itemsContainer = document.createElement("div");
          itemsContainer.style.cssText = `
                    display: grid;
                    grid-template-columns: repeat(3, 1fr);
                    grid-template-rows: repeat(2, auto);
                    gap: 3px;
                    padding: 5px;
                    position: absolute;
                    bottom: 5px;
                    left: 5px;
                    right: 5px;
                `;
          console.log("[showSubMenu] About to append itemsContainer");
          menuContainer.appendChild(itemsContainer);
          console.log("[showSubMenu] itemsContainer appended:", itemsContainer);
          // Calculate current page items
          const itemsPerPage = 5;
          const startIndex = this.currentPage * itemsPerPage;
          const pageItems = items.slice(startIndex, startIndex + itemsPerPage);

          // Create menu items (only show first 5)
          pageItems.forEach((item, index) => {
            const button = document.createElement("button");
            const isOnCooldown = type === "skills" && item.currentCooldown > 0;

            // Style the button
            Object.assign(button.style, {
              padding: "4px 4px",
              background: "rgba(0,0,0,0.7)",
              border: "2px solid " + (isOnCooldown ? "#666666" : "#00ffff"),
              borderRadius: "4px",
              color: isOnCooldown ? "#999" : "#00ffff",
              cursor: isOnCooldown ? "not-allowed" : "pointer",
              fontWeight: "bold",
              fontSize: "10px",
              textShadow: "0 0 6px #000, 0 0 12px #00ffff44",
              margin: "1px 0",
              fontFamily: "'Courier New', Courier, monospace",
              letterSpacing: "1px",
              transition: "background 0.2s, border 0.2s",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              minHeight: "38px",
            });

            // Get the appropriate icon and set tooltip
            let iconSrc;
            if (type === "skills" && item.icon) {
              iconSrc = item.icon;
            } else if (type === "spells" && item.icon) {
              iconSrc = item.icon;
            } else {
              // Default icon (Power Strike) for items without icons
              iconSrc =
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Power_Strike-TdI9P4tDRxKJDi4nrkYzOo6ZOQGVd8.png?8zRh";
            }

            // Create center-aligned icon container
            const iconContainer = document.createElement("div");
            iconContainer.style.cssText = `
              display: flex;
              align-items: center;
              justify-content: center;
              width: 100%;
              height: 100%;
            `;

            // Create icon container with positioning for cooldown indicator
            iconContainer.style.position = "relative";

            // Create icon
            const iconImg = document.createElement("img");
            iconImg.src = iconSrc;
            iconImg.alt = item.name;
            iconImg.style.cssText = `
              width: 28px;
              height: 28px;
              border: 2px solid ${isOnCooldown ? "#ff4444" : "#00ffff"};
              border-radius: 4px;
            `;
            iconContainer.appendChild(iconImg);

            // Add a more visible cooldown overlay text
            if (type === "skills" && item.currentCooldown > 0) {
              // Create a more visible cooldown number directly on the icon
              const cooldownNumber = document.createElement("div");
              Object.assign(cooldownNumber.style, {
                position: "absolute",
                bottom: "2px",
                right: "3px",
                backgroundColor: "rgba(0, 0, 0, 0.8)",
                color: "#ff4444",
                fontSize: "10px",
                padding: "0px 3px",
                borderRadius: "3px",
                fontWeight: "bold",
                zIndex: "100",
                pointerEvents: "none",
                textShadow: "1px 1px 1px black",
              });
              cooldownNumber.textContent = item.currentCooldown;
              iconContainer.appendChild(cooldownNumber);

              // We're now using a red border instead of an overlay
            }

            button.appendChild(iconContainer);

            // Add global tooltip style if it doesn't exist
            if (!document.getElementById("battleTooltipStyle")) {
              const tooltipStyle = document.createElement("style");
              tooltipStyle.id = "battleTooltipStyle";
              tooltipStyle.textContent = `
                .battle-tooltip {
                  position: absolute;
                  background: rgba(0, 0, 0, 0.95);
                  border: 2px solid #00ffff;
                  color: #fff;
                  padding: 8px;
                  border-radius: 4px;
                  font-size: 10px;
                  width: 160px;
                  z-index: 9999;
                  pointer-events: none;
                  opacity: 0;
                  transition: opacity 0.3s;
                  text-align: left;
                  top: -80px;
                  left: 50%;
                  transform: translateX(-50%);
                  box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
                }
              `;
              document.head.appendChild(tooltipStyle);
            }

            // Create tooltip
            const tooltip = document.createElement("div");
            tooltip.className = "battle-tooltip";
            tooltip.style.cssText = `
              position: fixed;
              top: calc(50% - 40px);
              right: 20px;
              transform: translateY(-50%);
              box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
              z-index: 9999;
            `;

            // Add cooldown/mp cost/quantity indicator
            const costText =
              type === "spells"
                ? `MP Cost: ${item.mpCost}`
                : type === "skills"
                  ? `Cooldown: ${isOnCooldown ? item.currentCooldown : item.cooldown}`
                  : type === "items" && item.type === "consumable"
                    ? `Quantity: ${item.quantity}`
                    : "";

            tooltip.innerHTML = `
              <div style="font-weight: bold; color: #00ffff; margin-bottom: 4px;">${item.name}</div>
              <div style="margin-bottom: 4px;">${item.description || "No description available."}</div>
              <div style="color: #aaaaff;">${costText}</div>
            `;

            // Add tooltip to button
            button.appendChild(tooltip);

            // Add hover events for tooltip
            button.addEventListener("mouseenter", () => {
              tooltip.style.opacity = "1";
            });

            button.addEventListener("mouseleave", () => {
              tooltip.style.opacity = "0";
            });

            // Handler assignment
            if (isOnCooldown) {
              button.disabled = true;
              button.setAttribute("aria-disabled", "true");
              // Debug log
              console.debug(`[showSubMenu] Button for "${item.name}" is on cooldown, handler not assigned.`);
            } else {
              button.onclick = this.useMenuItem.bind(this, type, item);
              // Debug log
              console.debug(`[showSubMenu] Handler assigned for "${item.name}" (${type}).`);
            }
            itemsContainer.appendChild(button);
          });

          // Navigation buttons (outside the item loop!)
          const navContainer = document.createElement("div");
          Object.assign(navContainer.style, {
            display: "grid",
            gridTemplateColumns: "1fr 1fr",
          });
          itemsContainer.appendChild(navContainer);
          console.log("[showSubMenu] navContainer appended:", navContainer);
          // Back button
          const backButton = document.createElement("button");
          Object.assign(backButton.style, {
            padding: "6px 8px",
            background: "rgba(0,0,0,0.7)",
            border: "2px solid #00ffff",
            borderRadius: "4px",
            color: "#00ffff",
            cursor: "pointer",
            fontWeight: "bold",
            fontSize: "10px",
            textShadow: "0 0 6px #000, 0 0 12px #00ffff44",
            margin: "2px 0",
            fontFamily: "'Courier New', Courier, monospace",
            letterSpacing: "1px",
            transition: "background 0.2s, border 0.2s",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            minHeight: "32px",
          });
          backButton.textContent = "Back";
          backButton.onclick = () => {
            if (this.currentPage > 0) {
              this.currentPage--;
              this.showSubMenu(type);
            } else {
              this.currentPage = 0;
              this.showBattleMenu();
            }
          };
          navContainer.appendChild(backButton);

          // Next button (show if there are more items)
          const hasMoreItems = items.length > startIndex + itemsPerPage;
          if (hasMoreItems) {
            const nextButton = document.createElement("button");
            Object.assign(nextButton.style, {
              padding: "4px 4px",
              background: "rgba(0,0,0,0.7)",
              border: "2px solid #00ffff",
              borderRadius: "4px",
              color: "#00ffff",
              cursor: "pointer",
              fontWeight: "bold",
              fontSize: "10px",
              textShadow: "0 0 6px #000, 0 0 12px #00ffff44",
              fontFamily: "'Courier New', Courier, monospace",
              letterSpacing: "1px",
              transition: "background 0.2s, border 0.2s",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              minHeight: "38px",
            });
            nextButton.textContent = "Next";
            nextButton.onclick = () => {
              this.currentPage++;
              this.showSubMenu(type);
            };
            navContainer.appendChild(nextButton);
          }
        },
        endTurn() {
          console.log("[Combat] Ending player turn");

          // Process skill cooldowns
          if (this.skillCooldowns) {
            Object.keys(this.skillCooldowns).forEach((skill) => {
              if (this.skillCooldowns[skill] > 0) {
                this.skillCooldowns[skill]--;
                console.log(`[Combat] ${skill} cooldown reduced to ${this.skillCooldowns[skill]}`);
              }
            });
          } else {
            // Initialize cooldowns object if it doesn't exist
            this.skillCooldowns = {};
          }

          // Clean up any targeting mode state
          this.targetingMode = false;
          this.selectedAction = null;

          // Highlight appropriate targets
          const enemySide = document.getElementById("enemySide");
          const playerSide = document.getElementById("playerSide");

          // Check if the action can target multiple characters
          const isMultiTarget = this.selectedAction && (this.selectedAction.item.isMultiTarget || false);

          // Clear any existing click handlers
          playerSide.onclick = null;
          enemySide.onclick = null;

          // Reset styles
          playerSide.style.border = "none";
          enemySide.style.border = "none";
          playerSide.style.cursor = "default";
          enemySide.style.cursor = "default";

          // Determine targeting based on effect type
          if (
            (this.selectedAction &&
              this.selectedAction.type === "items" &&
              this.selectedAction.item.type === "consumable") ||
            (this.selectedAction &&
              this.selectedAction.type === "spells" &&
              this.selectedAction.item.effect === "buff") ||
            (this.selectedAction && this.selectedAction.type === "skills" && this.selectedAction.item.effect === "buff")
          ) {
            // For healing items and buffs, highlight player
            playerSide.style.border = "2px solid #00ff00";
            playerSide.style.cursor = "pointer";
            const self = this;
            const clickHandler = function () {
              self.executeAction(self.selectedAction, GameStateManager.state.player);
              // Remove click handler after use
              playerSide.onclick = null;
              playerSide.style.border = "none";
              playerSide.style.cursor = "default";
            };
            playerSide.onclick = clickHandler;
            this.displayBattleMessage(`Select a target for ${this.selectedAction.item.name}!`);
          } else {
            // For other actions, highlight enemy
            enemySide.style.border = "2px solid #ff0000";
            enemySide.style.cursor = "pointer";
            const self = this;
            const clickHandler = function () {
              self.executeAction(self.selectedAction, self.currentEnemy);
              // Remove click handler after use
              enemySide.onclick = null;
              enemySide.style.border = "none";
              enemySide.style.cursor = "default";
            };
            enemySide.onclick = clickHandler;
            this.displayBattleMessage(
              isMultiTarget
                ? `Select targets for ${this.selectedAction.item.name}!`
                : `Select a target for ${this.selectedAction.item.name}!`,
            );
          }
        },

        useMenuItem(type, item) {
          // Set up targeting mode
          this.targetingMode = true;
          this.selectedAction = { type, item };

          // Highlight appropriate targets
          const enemySide = document.getElementById("enemySide");
          const playerSide = document.getElementById("playerSide");

          // Check if the action can target multiple characters
          const isMultiTarget = item.isMultiTarget || false;

          // Clear any existing click handlers
          playerSide.onclick = null;
          enemySide.onclick = null;

          // Reset styles
          playerSide.style.border = "none";
          enemySide.style.border = "none";
          playerSide.style.cursor = "default";
          enemySide.style.cursor = "default";

          // Determine targeting based on effect type
          if (
            (type === "items" && item.type === "consumable") ||
            (type === "spells" && item.effect === "buff") ||
            (type === "skills" && item.effect === "buff")
          ) {
            // For healing items and buffs, highlight player
            playerSide.style.border = "2px solid #00ff00";
            playerSide.style.cursor = "pointer";
            const self = this;
            const clickHandler = function () {
              self.executeAction(self.selectedAction, GameStateManager.state.player);
              // Remove click handler after use
              playerSide.onclick = null;
              playerSide.style.border = "none";
              playerSide.style.cursor = "default";
            };
            playerSide.onclick = clickHandler;
            this.displayBattleMessage(`Select a target for ${item.name}!`);
          } else {
            // For other actions, highlight enemy
            enemySide.style.border = "2px solid #ff0000";
            enemySide.style.cursor = "pointer";
            const self = this;
            const clickHandler = function () {
              self.executeAction(self.selectedAction, self.currentEnemy);
              // Remove click handler after use
              enemySide.onclick = null;
              enemySide.style.border = "none";
              enemySide.style.cursor = "default";
            };
            enemySide.onclick = clickHandler;
            this.displayBattleMessage(
              isMultiTarget ? `Select targets for ${item.name}!` : `Select a target for ${item.name}!`,
            );
          }
        },

        executeAction(action, target) {
          // Ensure battle is still active
          if (!this.isActive) {
            console.log("[Execute Action] Battle is not active, aborting action");
            return;
          }

          // Remove targeting highlights
          const enemySide = document.getElementById("enemySide");
          const playerSide = document.getElementById("playerSide");
          if (enemySide) {
            enemySide.style.border = "none";
            enemySide.onclick = null;
          }
          if (playerSide) {
            playerSide.style.border = "none";
            playerSide.onclick = null;
          }

          this.targetingMode = false;
          this.selectedAction = null;

          const player = GameStateManager.state.player;

          switch (action.type) {
            case "spells":
              if (player.mp < action.item.mpCost) {
                this.displayBattleMessage("Not enough MP!");
                return;
              }
              player.mp -= action.item.mpCost;

              switch (action.item.effect) {
                case "damage":
                  if (action.item.isMultiTarget) {
                    const damage = Math.floor(player.stats.intelligence * 1.2);
                    this.currentEnemy.hp = Math.max(0, this.currentEnemy.hp - damage);
                    this.displayBattleMessage(`You cast ${action.item.name}!`);
                    this.displayBattleMessage(`The spell deals ${damage} damage to all enemies!`);
                  } else {
                    const damage = Math.floor(player.stats.intelligence * 1.5);
                    target.hp = Math.max(0, target.hp - damage);
                    this.displayBattleMessage(`You cast ${action.item.name}!`);
                    this.displayBattleMessage(`The spell deals ${damage} damage!`);
                  }
                  break;
                case "heal":
                  const healAmount = Math.floor(player.stats.intelligence * 1.5);
                  target.hp = Math.min(target.derivedStats.maxHp, target.hp + healAmount);
                  this.displayBattleMessage(`You cast ${action.item.name}!`);
                  this.displayBattleMessage(`The spell heals ${healAmount} HP!`);
                  break;
                case "buff":
                  // Apply buff effect
                  if (!target.buffs) target.buffs = [];
                  target.buffs.push({
                    name: action.item.name,
                    effect: action.item.effect,
                    duration: 3,
                    strength: Math.floor(player.stats.intelligence * 0.5),
                  });
                  this.displayBattleMessage(`You cast ${action.item.name}!`);
                  this.displayBattleMessage(`${target.name}'s strength increased!`);
                  break;
              }
              break;
            case "skills":
              if (action.item.currentCooldown > 0) {
                this.displayBattleMessage(`${action.item.name} is on cooldown!`);
                return;
              }

              switch (action.item.effect) {
                case "damage":
                  // Disable UI during animation
                  this.disableUI();

                  const now = Date.now();
                  const damageResult = this.calculateDamage(player, target, false, now);
                  // Apply skill damage multiplier if it exists
                  const finalDamage = action.item.damageMultiplier
                    ? Math.floor(damageResult.damage * action.item.damageMultiplier)
                    : damageResult.damage;

                  // Check if this is Power Strike skill
                  if (action.item.name === "Power Strike") {
                    // Check if Power Strike is on cooldown
                    if (this.skillCooldowns && this.skillCooldowns.powerStrike > 0) {
                      console.log(
                        "[Combat] Power Strike is on cooldown: " + this.skillCooldowns.powerStrike + " turns remaining",
                      );
                      this.displayBattleMessage(
                        "Power Strike is on cooldown: " + this.skillCooldowns.powerStrike + " turns remaining!",
                      );
                      this.enableUI();
                      return;
                    }

                    // Set Power Strike on cooldown (3 turns)
                    if (!this.skillCooldowns) this.skillCooldowns = {};
                    this.skillCooldowns.powerStrike = 3;
                    console.log("[Combat] Power Strike used - setting cooldown to 3 turns");

                    // Play Power Strike animation sequence
                    this.playPowerStrikeSequence(target);

                    // Play power strike sound
                    AudioManager.play("powerup");

                    // Apply damage after animation delay
                    setTimeout(() => {
                      target.hp = Math.max(0, target.hp - finalDamage);
                      this.displayBattleMessage(`You use ${action.item.name}!`);
                      this.displayBattleMessage(`The skill deals ${finalDamage} damage!`);
                      if (damageResult.wasBlocked) {
                        this.displayBattleMessage("The attack was partially blocked!");
                      }

                      // Re-enable UI
                      this.enableUI();

                      // Update UI and check battle state
                      this.updateUI();
                      if (target.hp <= 0) {
                        this.handleEnemyDeath();
                      } else {
                        console.log("[Execute Action] Battle still active, starting enemy turn");
                        this.startEnemyTurn();
                      }
                    }, 2500); // Longer delay for power strike animation

                    return; // Early return since we're handling this asynchronously
                  } else {
                    // Regular skill, use standard attack animation
                    this.playAttackSequence(target);

                    // Apply damage after animation delay
                    setTimeout(() => {
                      target.hp = Math.max(0, target.hp - finalDamage);
                      this.displayBattleMessage(`You use ${action.item.name}!`);
                      this.displayBattleMessage(`The skill deals ${finalDamage} damage!`);
                      if (damageResult.wasBlocked) {
                        this.displayBattleMessage("The attack was partially blocked!");
                      }

                      // Re-enable UI
                      this.enableUI();

                      // Update UI and check battle state
                      this.updateUI();
                      if (target.hp <= 0) {
                        this.handleEnemyDeath();
                      } else {
                        console.log("[Execute Action] Battle still active, starting enemy turn");
                        this.startEnemyTurn();
                      }
                    }, 1200);
                    return; // Early return since we're handling this asynchronously
                  }
                  break;
                case "buff":
                  // Apply buff effect
                  if (!target.buffs) target.buffs = [];
                  target.buffs.push({
                    name: action.item.name,
                    effect: action.item.effect,
                    duration: 3,
                    strength: Math.floor(player.stats.strength * 0.5),
                  });
                  this.displayBattleMessage(`You use ${action.item.name}!`);
                  this.displayBattleMessage(`${target.name}'s strength increased!`);
                  break;
                case "defense":
                  // Apply defense buff
                  if (!target.buffs) target.buffs = [];
                  target.buffs.push({
                    name: action.item.name,
                    effect: action.item.effect,
                    duration: 2,
                    defense: Math.floor(player.stats.vitality * 0.5),
                  });
                  this.displayBattleMessage(`You use ${action.item.name}!`);
                  this.displayBattleMessage(`${target.name}'s defense increased!`);
                  break;
              }

              // Set the cooldown
              action.item.currentCooldown = action.item.cooldown;
              break;
            case "items":
              this.useItem(target, action.item);
              break;
          }

          this.updateUI();
          if (this.currentEnemy.hp <= 0) {
            this.handleEnemyDeath();
          } else {
            console.log("[Execute Action] Battle still active, starting enemy turn");
            this.startEnemyTurn();
          }
        },

        // Helper methods for UI management during animations
        disableUI() {
          const battleMenu = document.getElementById("BattleMenu");
          if (battleMenu) battleMenu.style.pointerEvents = "none";
        },

        enableUI() {
          const battleMenu = document.getElementById("BattleMenu");
          if (battleMenu) battleMenu.style.pointerEvents = "auto";
        },

        attack(target) {
          if (!target || this.isActionInProgress) return;

          console.log("[Attack] Starting attack on", target.name);

          // Set action in progress to prevent spamming
          this.isActionInProgress = true;

          // Disable UI during animation
          this.disableUI();

          // Calculate damage
          const player = GameStateManager.state.player;
          const now = Date.now();
          const attackResult = this.calculateDamage(player, target, false, now);

          // Play attack sound effect
          AudioManager.play("attack");

          // Play attack animation
          this.playAttackSequence(target);

          // Apply damage after a longer delay to sync with both attack and damage animations
          setTimeout(() => {
            target.hp = Math.max(0, target.hp - attackResult.damage);

            // Display damage message - FIX: Add message for normal attacks
            this.displayBattleMessage(
              `${player.name} dealt ${attackResult.damage} damage to ${target.name}${attackResult.isCritical ? " (Critical Hit!)" : ""}`,
            );

            // Play damage sound when enemy is hit
            AudioManager.play("damage");

            // Update enemy display
            this.updateEnemyDisplay(target);

            // Check if enemy is defeated
            if (target.hp <= 0) {
              this.handleEnemyDeath(target); // FIX: Call handleEnemyDeath instead of enemyDefeated
              // Don't reset isActionInProgress here - it's handled in handleEnemyDeath
            } else {
              // Enemy's turn after a delay, but make sure to reset action flag
              setTimeout(() => {
                this.isActionInProgress = false; // <-- Critical fix: reset the action flag
                this.startEnemyTurn(target);
              }, 1000);
            }
          }, 800); // Slightly shorter to match animation
        },

        castSpell(target, spell) {
          const player = GameStateManager.state.player;
          if (player.mp < spell.mpCost) {
            this.displayBattleMessage("Not enough MP!");
            return;
          }
          player.mp -= spell.mpCost;
          const damage = Math.floor(player.stats.intelligence * 1.5);
          target.hp = Math.max(0, target.hp - damage);
          this.displayBattleMessage(`You cast ${spell.name} dealing ${damage} damage!`);
          this.updateUI();
          if (target.hp <= 0) {
            this.handleEnemyDeath();
          } else {
            this.startEnemyTurn();
          }
        },

        useSkill(target, skillId) {
          if (!target || this.isActionInProgress) {
            console.log("[Skill] Cannot use skill - action in progress or no target", this.isActionInProgress);
            return;
          }

          // Check if the skill is on cooldown
          const player = GameStateManager.state.player;
          const skill = player.skills.find((s) => s.id === skillId);

          if (!skill) {
            console.error("[Skill] Skill not found:", skillId);
            return;
          }

          const now = Date.now();
          if (skill.lastUsed && now - skill.lastUsed < skill.cooldown) {
            // Skill is on cooldown
            this.displayBattleMessage(`${skill.name} is on cooldown!`);
            console.log(`[Skill] ${skill.name} is on cooldown!`);
            return;
          }

          console.log("[Skill] Using skill:", skill.name);

          // Set action in progress
          this.isActionInProgress = true;

          // Disable UI during animation
          this.disableUI();

          // Mark skill as used and start cooldown
          skill.lastUsed = now;

          // Calculate damage with skill modifier
          const attackResult = this.calculateDamage(player, target, true, now);

          // Play power strike sound
          AudioManager.play("powerup");

          // Play the power strike sequence
          this.playPowerStrikeSequence(target);

          // Apply damage after animation delay
          setTimeout(() => {
            target.hp = Math.max(0, target.hp - attackResult.damage);

            // Update enemy display
            this.updateEnemyDisplay(target);

            // Display result
            this.displayBattleMessage(
              `Power Strike! ${player.name} dealt ${attackResult.damage} damage to ${target.name}${attackResult.isCritical ? " (Critical Hit!)" : ""}`,
            );

            // Check if enemy is defeated
            if (target.hp <= 0) {
              this.handleEnemyDeath(target); // FIX: Call handleEnemyDeath instead of enemyDefeated
              // Don't reset isActionInProgress here - it's handled in handleEnemyDeath
            } else {
              // Enemy's turn after a delay
              setTimeout(() => {
                console.log("[Skill] Ending skill action, enemy turn starting");
                this.isActionInProgress = false; // Critical fix: Reset the action flag
                this.startEnemyTurn(target);
              }, 1000);
            }

            // Update skill button to show cooldown
            this.updateSkillButtons();
          }, 2000); // Longer delay for power strike animation
        },

        useItem(target, item) {
          if (item.type === "consumable") {
            target.hp = Math.min(target.derivedStats.maxHp, target.hp + 30);
            GameStateManager.state.player.inventory = GameStateManager.state.player.inventory.filter((i) => i !== item);
            this.displayBattleMessage(`You use ${item.name} and restore 30 HP!`);
          }
          this.updateUI();
          if (target.hp <= 0) {
            this.handleEnemyDeath();
          } else {
            this.startEnemyTurn();
          }
        },

        flee() {
          if (Math.random() < 0.5) {
            this.displayBattleMessage("You successfully fled from battle!");
            setTimeout(() => this.endBattle(true), 1000);
          } else {
            this.displayBattleMessage("Couldn't escape!");
            this.startEnemyTurn();
          }
        },

        playEnemyAttackAnimation() {
          console.log("[Animation] Starting enemy attack animation");
          // Create animation container if it doesn't exist
          const container = document.getElementById("combatAnimationContainer");
          if (!container) {
            console.error("[Animation] Container not found for enemy attack");
            return;
          }

          // Get enemy side position for proper placement
          const enemySide = document.getElementById("enemySide");
          if (!enemySide) {
            console.error("[Animation] EnemySide not found for attack animation");
            return;
          }

          // Get the correct attack animation frames based on enemy type
          let attackFrames = [];

          if (this.currentEnemy.name === "Space Goblin") {
            // Space Goblin attack animation frames
            attackFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPFire2-B2xJz05ebiCyZPrPUFLJ54mLnZVVIB.png?TSFI",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPFire3-hl35WGRRvWLguRNXim8lY9hCigVR8U.png?j0Vr",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPFire4-PiffY9ZvJ60hWzpyfXojl2L2DIYW3u.png?CkOf",
            ];
          } else if (this.currentEnemy.name === "Cyber Orc") {
            // Cyber Orc attack animation frames - DIRECT URL REFERENCE to avoid issues
            attackFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot1-0UdRg4aj8OP1AWAR0Vq5nrsWGj0Pep.png?ADXW",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot2-Jxemlizz9MMFqXn36ZclwjOpwMqm96.png?gAo3",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot3-BhNo7CtJmCeEsEj9pSz7WaMYzWRAMV.png?PjlM",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot4-End5wwXjUv7JkLNvakyNzJeqcIvM37.png?MNJ2",
            ];
            console.log("[DEBUG] Using Cyber Orc attack frames:", attackFrames);
          } else if (this.currentEnemy.name === "Meta Troll") {
            // Meta Troll attack animation frames - DIRECT URL REFERENCE to avoid issues
            attackFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_1-BcG4hrD1BZVmW0UkKQ1g1xTrMLTsGF.png?f2LA",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_2-bv2od1zpdNDbt3rrN3tzHC2wa0v6Uu.png?IkSe",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_3-qTXvBL3mNYlaGNfgkqopgvNFscgTrS.png?WubI",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_4-OtB270wajPYBFWrRVmXGleiGqJ8Wwj.png?VhAs",
            ];
            console.log("[DEBUG] Using Meta Troll attack frames:", attackFrames);
          }

          // Get the enemy side's position
          const enemyRect = enemySide.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          // Get message box position for consistent alignment
          // Get message box position for consistent alignment
          const messageBox = document.getElementById("battleMessages");
          let messageTop = 0;
          if (messageBox) {
            const messageRect = messageBox.getBoundingClientRect();
            messageTop = messageRect.top - containerRect.top;
          }

          // Calculate position (x at center of enemy side, y positioned so bottom aligns with message box)
          const posX = enemyRect.left - containerRect.left + enemyRect.width / 2;
          // Position animation so bottom aligns with top of message box (accounting for animation height)
          const posY = messageTop - 60; // 60px above message box (moved up 20px total)

          // Create the animation element
          const animationElement = document.createElement("div");
          animationElement.id = "enemyAttackAnimation"; // Add an ID for easier reference

          // Adjust size based on enemy type
          let width = 80;
          let height = 80;

          // Adjust size based on enemy type
          if (this.currentEnemy.name === "Cyber Orc") {
            width = 120;
            height = 120;
          } else if (this.currentEnemy.name === "Meta Troll") {
            width = 100;
            height = 100;
          }

          animationElement.style.cssText = `
            position: absolute;
            width: ${width}px;
            height: ${height}px;
            background-image: url('${attackFrames[0]}');
            background-size: contain;
            background-repeat: no-repeat;
            top: ${posY}px;
            left: ${posX}px;
            transform: translate(-50%, -50%) scaleX(-1); /* Flip horizontally */
            z-index: 20; /* Higher z-index to appear above other animations */
            pointer-events: none;
          `;

          // Add the animation element to the container
          container.appendChild(animationElement);

          // Frame duration in milliseconds
          const frameDuration = 150;
          let currentFrame = 0;

          // Function to update the animation frame
          const updateFrame = () => {
            currentFrame++;

            if (currentFrame < attackFrames.length) {
              // Update to next frame
              animationElement.style.backgroundImage = `url('${attackFrames[currentFrame]}')`;
              setTimeout(updateFrame, frameDuration);
            } else {
              // Animation complete - only remove THIS animation element, not all animations
              setTimeout(() => {
                if (container.contains(animationElement)) {
                  animationElement.remove();
                  console.log("[Animation] Enemy attack animation completed and removed");
                }
              }, 100);
            }
          };

          // Start the animation sequence
          setTimeout(updateFrame, frameDuration);

          // When we reach the last frame, shake the player side
          setTimeout(() => {
            // Make shake animation stronger and more visible
            const playerSide = document.getElementById("playerSide");
            if (playerSide) {
              playerSide.style.animation = "shake 0.5s ease-in-out 2";
              setTimeout(() => {
                playerSide.style.animation = "";
              }, 1000);
            }

            // Play the player damage animation with a slight delay
            setTimeout(() => {
              this.playPlayerDamageAnimation();
            }, 300);
          }, frameDuration * attackFrames.length);
        },

        startEnemyTurn() {
          this.turn = "enemy";
          this.displayBattleMessage("Enemy's turn!");

          // Decrease cooldowns for player skills
          if (GameStateManager.state.player.skills) {
            GameStateManager.state.player.skills.forEach((skill) => {
              if (skill.currentCooldown > 0) {
                skill.currentCooldown--;
              }
            });
          }

          // Process battle system skill cooldowns (for Power Strike)
          if (this.skillCooldowns) {
            Object.keys(this.skillCooldowns).forEach((skill) => {
              if (this.skillCooldowns[skill] > 0) {
                this.skillCooldowns[skill]--;
                console.log(`[Combat] ${skill} cooldown reduced to ${this.skillCooldowns[skill]}`);
              }
            });
          }

          setTimeout(() => {
            const enemy = this.currentEnemy;
            const player = GameStateManager.state.player;

            const now = Date.now();
            const damageResult = this.calculateDamage(this.currentEnemy, player, false, now);
            player.hp = Math.max(0, player.hp - damageResult.damage);

            // Play damage sound when player is hit
            AudioManager.play("damage");

            // EXPLICITLY handle each enemy type to ensure animations play correctly
            if (enemy.name === "Space Goblin") {
              console.log("[ENEMY TURN] Playing Space Goblin attack animation");
              this.playEnemyAttackAnimation();
            } else if (enemy.name === "Cyber Orc") {
              console.log("[ENEMY TURN] Playing Cyber Orc attack animation");
              // Explicitly create animation for Cyber Orc attack
              const container = document.getElementById("combatAnimationContainer");
              if (container) {
                const enemyRect = document.getElementById("enemySide").getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const messageBox = document.getElementById("battleMessages");
                let messageTop = messageBox ? messageBox.getBoundingClientRect().top - containerRect.top : 300;

                // Clear any existing animations
                const existingAnimations = container.querySelectorAll("div");
                existingAnimations.forEach((anim) => anim.remove());

                const cyberOrcAttackFrames = [
                  "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot1-0UdRg4aj8OP1AWAR0Vq5nrsWGj0Pep.png?ADXW",
                  "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot2-Jxemlizz9MMFqXn36ZclwjOpwMqm96.png?gAo3",
                  "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot3-BhNo7CtJmCeEsEj9pSz7WaMYzWRAMV.png?PjlM",
                  "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot4-End5wwXjUv7JkLNvakyNzJeqcIvM37.png?MNJ2",
                ];

                const posX = enemyRect.left - containerRect.left + enemyRect.width / 2;
                const posY = messageTop - 60;

                const animationElement = document.createElement("div");
                animationElement.style.cssText = `
                  position: absolute;
                  width: 120px;
                  height: 120px;
                  background-image: url('${cyberOrcAttackFrames[0]}');
                  background-size: contain;
                  background-repeat: no-repeat;
                  top: ${posY}px;
                  left: ${posX}px;
                  transform: translate(-50%, -50%) scaleX(-1);
                  z-index: 20;
                  pointer-events: none;
                `;

                container.appendChild(animationElement);

                let currentFrame = 0;
                const updateFrame = () => {
                  currentFrame++;
                  if (currentFrame < cyberOrcAttackFrames.length) {
                    animationElement.style.backgroundImage = `url('${cyberOrcAttackFrames[currentFrame]}')`;
                    setTimeout(updateFrame, 150);
                  } else {
                    setTimeout(() => {
                      if (container.contains(animationElement)) {
                        animationElement.remove();
                      }
                      // Shake the player side
                      const playerSide = document.getElementById("playerSide");
                      if (playerSide) {
                        playerSide.style.animation = "shake 0.5s ease-in-out 2";
                        setTimeout(() => {
                          playerSide.style.animation = "";
                        }, 1000);
                        // Play player damage
                        setTimeout(() => this.playPlayerDamageAnimation(), 300);
                      }
                    }, 100);
                  }
                };

                setTimeout(updateFrame, 150);
              }
            } else if (enemy.name === "Meta Troll") {
              console.log("[ENEMY TURN] Playing Meta Troll attack animation");
              // Explicitly create animation for Meta Troll attack
              const container = document.getElementById("combatAnimationContainer");
              if (container) {
                const enemyRect = document.getElementById("enemySide").getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const messageBox = document.getElementById("battleMessages");
                let messageTop = messageBox ? messageBox.getBoundingClientRect().top - containerRect.top : 300;

                // Clear any existing animations
                const existingAnimations = container.querySelectorAll("div");
                existingAnimations.forEach((anim) => anim.remove());

                const metaTrollAttackFrames = [
                  "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_1-BcG4hrD1BZVmW0UkKQ1g1xTrMLTsGF.png?f2LA",
                  "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_2-bv2od1zpdNDbt3rrN3tzHC2wa0v6Uu.png?IkSe",
                  "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_3-qTXvBL3mNYlaGNfgkqopgvNFscgTrS.png?WubI",
                  "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_4-OtB270wajPYBFWrRVmXGleiGqJ8Wwj.png?VhAs",
                ];

                const posX = enemyRect.left - containerRect.left + enemyRect.width / 2;
                const posY = messageTop - 60;

                const animationElement = document.createElement("div");
                animationElement.style.cssText = `
                  position: absolute;
                  width: 100px;
                  height: 100px;
                  background-image: url('${metaTrollAttackFrames[0]}');
                  background-size: contain;
                  background-repeat: no-repeat;
                  top: ${posY}px;
                  left: ${posX}px;
                  transform: translate(-50%, -50%) scaleX(-1);
                  z-index: 20;
                  pointer-events: none;
                `;

                container.appendChild(animationElement);

                let currentFrame = 0;
                const updateFrame = () => {
                  currentFrame++;
                  if (currentFrame < metaTrollAttackFrames.length) {
                    animationElement.style.backgroundImage = `url('${metaTrollAttackFrames[currentFrame]}')`;
                    setTimeout(updateFrame, 150);
                  } else {
                    setTimeout(() => {
                      if (container.contains(animationElement)) {
                        animationElement.remove();
                      }
                      // Shake the player side
                      const playerSide = document.getElementById("playerSide");
                      if (playerSide) {
                        playerSide.style.animation = "shake 0.5s ease-in-out 2";
                        setTimeout(() => {
                          playerSide.style.animation = "";
                        }, 1000);
                        // Play player damage
                        setTimeout(() => this.playPlayerDamageAnimation(), 300);
                      }
                    }, 100);
                  }
                };

                setTimeout(updateFrame, 150);
              }
            } else {
              // Default behavior for other enemies - just shake player side
              const playerSide = document.getElementById("playerSide");
              if (playerSide) {
                playerSide.style.animation = "shake 0.5s ease-in-out";
                setTimeout(() => {
                  playerSide.style.animation = "";
                }, 1000);

                // Play player damage animation
                this.playPlayerDamageAnimation();
              }
            }

            // Sync HP values and update all UI elements
            if (!player.derivedStats) {
              player.derivedStats = {
                maxHp: player.stats.vitality * 20,
                maxMp: player.stats.intelligence * 15,
              };
            }

            this.displayBattleMessage(`${enemy.name} attacks you for ${damageResult.damage} damage!`);
            if (damageResult.wasBlocked) {
              this.displayBattleMessage("You partially blocked the attack!");
            }

            // Update all UI elements to ensure consistent HP display
            this.updateUI();
            UIManager.update();
            UIManager.updateCharacterScreen();

            if (player.hp <= 0) {
              this.handlePlayerDeath();
              return;
            } else {
              this.turn = "player";
              this.showBattleMenu();
            }
          }, 1000);
        },

        displayBattleMessage(message) {
          console.log("[Message System] Attempting to display:", message);

          const messageArea = document.getElementById("battleMessages");
          if (!messageArea) {
            console.log("[Message System] Message area not found");
            return;
          }

          const messageElement = document.createElement("div");
          messageElement.textContent = message;
          messageElement.style.marginBottom = "5px";
          messageElement.style.color = "#fff";
          messageElement.style.textShadow = "0 0 2px #000";

          // Ensure messages are visible
          messageArea.style.display = "block";
          messageArea.style.opacity = "1";
          messageArea.appendChild(messageElement);

          // Scroll to the latest message
          messageArea.scrollTop = messageArea.scrollHeight;

          console.log("[Message System] Message added to container");
        },

        updateUI() {
          const playerSide = document.getElementById("playerSide");
          const enemySide = document.getElementById("enemySide");
          if (!playerSide || !enemySide) return;

          const player = GameStateManager.state.player;
          const enemy = this.currentEnemy;

          if (!player || !enemy) return;

          console.log("[updateUI] Updating battle UI: ", {
            enemyName: enemy.name,
            enemyHP: enemy.hp,
            currentEnemyIndex: this.currentEnemyIndex,
            totalEnemies: this.enemyGroup.length,
          });

          console.log("Updating UI with enemy:", enemy.name, "ID:", enemy.id, "Index:", this.currentEnemyIndex);

          // Ensure player has stats
          if (!player.stats) {
            player.stats = {
              strength: 10,
              defense: 5,
              intelligence: 8,
              vitality: 10,
              dexterity: 8,
            };
          }

          // Initialize HP and MP if needed
          if (typeof player.hp !== "number") {
            player.hp = player.derivedStats?.maxHp || 100;
          }
          if (typeof player.mp !== "number") {
            player.mp = player.derivedStats?.maxMp || 50;
          }

          // Update player side
          const playerHpPercent = Math.min(100, Math.max(0, (player.hp / (player.derivedStats?.maxHp || 100)) * 100));
          const playerMpPercent = Math.min(100, Math.max(0, (player.mp / (player.derivedStats?.maxMp || 50)) * 100));

          // Get player sprite based on class and animation frame
          let playerSpriteUrl = player.sprite;
          if (
            player.class === "Flexecutioner" &&
            this.flexecutionerIdleFrames &&
            this.flexecutionerIdleFrames.length > 0
          ) {
            playerSpriteUrl = this.flexecutionerIdleFrames[this.currentAnimationFrame];
          }
          if (!playerSpriteUrl) {
            playerSpriteUrl =
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flexecutioner-YTnx5DSfVR0ALUTlZc9Kt5xLlJFP4m.png?DUxz";
          }

          playerSide.innerHTML = `
                    <div class="player-container" style="background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(0, 210, 211,0.3); border-radius: 8px; padding: 10px; margin: 5px; display: flex; gap: 10px; width: 190px; box-sizing: border-box;">
                        <div style="display: flex; flex-direction: row; gap: 10px; align-items: flex-start; width: 100%;">
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 5px; width: 80px;">
                                <img src="${playerSpriteUrl}" style="width: 64px; height: 64px; border-radius: 4px; border: 2px solid #00ffff; padding: 2px;">
                                <div style="text-align: center;">
                                    <div style="color: #00ffff; font-size: 12px;">${player.name || "Player"}</div>
                                    <div style="color: #aaa; font-size: 12px;">Level ${player.level || 1}</div>
                                </div>
                            </div>

                            <div style="display: flex; flex-direction: row; gap: 8px; width: 80px;">
                                <div style="display: flex; flex-direction: column; gap: 5px; align-items: center;">
                                    <div style="width: 20px; height: 64px; background: rgba(20, 0, 0, 0.5); border-radius: 3px; overflow: hidden; border: 1px solid rgba(100, 0, 0, 0.3); position: relative;">
                                        <div style="width: 100%; height: ${playerHpPercent}%; background: linear-gradient(to top, #600, #800); transition: height 0.3s ease-in-out; position: absolute; bottom: 0;"></div>
                                    </div>
                                    <div style="color: #ff4444; font-size: 10px;">${Math.floor(player.hp)}/${player.derivedStats?.maxHp || 100}</div>
                                </div>
                                <div style="display: flex; flex-direction: column; gap: 5px; align-items: center;">
                                    <div style="width: 20px; height: 64px; background: rgba(0, 0, 20, 0.5); border-radius: 3px; overflow: hidden; border: 1px solid rgba(0, 0, 100, 0.3); position: relative;">
                                        <div style="width: 100%; height: ${playerMpPercent}%; background: linear-gradient(to top, #006, #008); transition: height 0.3s ease-in-out; position: absolute; bottom: 0;"></div>
                                    </div>
                                    <div style="color: #4444ff; font-size: 10px;">${Math.floor(player.mp)}/${player.derivedStats?.maxMp || 50}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;

          // Update enemy side
          const enemyHpPercent = Math.min(100, Math.max(0, (enemy.hp / enemy.maxHp) * 100));
          // Get the most reliable sprite URL - try multiple fallbacks
          let enemySpriteUrl;
          if (enemy.sprite && enemy.sprite.src) {
            enemySpriteUrl = enemy.sprite.src;
          } else if (typeof enemy.sprite === "string") {
            enemySpriteUrl = enemy.sprite;
          } else if (EnemyManager.enemySprites[enemy.name]) {
            enemySpriteUrl = EnemyManager.enemySprites[enemy.name];
          } else {
            enemySpriteUrl = EnemyManager.enemySprites["default"];
          }

          enemySide.innerHTML = `
                    <div class="enemy-container" style="background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 0, 0, 0.3); border-radius: 8px; padding: 10px; margin: 5px; display: flex; gap: 10px; width: 170px; box-sizing: border-box;">
                        <div style="display: flex; flex-direction: row; gap: 10px; align-items: flex-start; width: 100%;">
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 5px; width: 80px;">
                                <img src="${enemySpriteUrl}" style="width: 64px; height: 64px; border-radius: 4px; border: 2px solid #ff4444; padding: 2px;">
                                <div style="text-align: center; width: 100%;">
                                    <div style="color: #ff4444; font-size: 12px; white-space: nowrap; text-align: center; padding-left: 0; margin-left: -10px;">${enemy.name || "Enemy"}${this.enemyGroup.length > 1 ? ` x${this.enemyGroup.length - this.currentEnemyIndex}` : ""}</div>
                                    <div style="color: #aaa; font-size: 12px;">(${this.currentEnemyIndex + 1}/${this.enemyGroup.length})</div>
                                </div>
                            </div>

                            <div style="display: flex; flex-direction: row; gap: 8px; width: 80px;">
                                <div style="display: flex; flex-direction: column; gap: 5px; align-items: center;">
                                    <div style="width: 20px; height: 48px; background: rgba(20, 0, 0, 0.5); border-radius: 3px; overflow: hidden; border: 1px solid rgba(100, 0, 0, 0.3); position: relative;">
                                        <div style="width: 100%; height: ${enemyHpPercent}%; background: linear-gradient(to top, #600, #800); transition: height 0.3s ease-in-out; position: absolute; bottom: 0;"></div>
                                    </div>
                                    <div style="color: #ff4444; font-size: 10px;">${Math.floor(enemy.hp)}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
        },

        handleEnemyDeath() {
          console.log("[Enemy Death] Starting enemy death sequence");
          const player = GameStateManager.state.player;
          const enemy = this.currentEnemy;

          // Calculate XP and gold rewards based on enemy tier
          const enemyTier = getTier(enemy.stats, { name: "DICE_PROGRESSION", stat: "attack" });
          // Ensure we check all possible sources for XP and gold values
          const baseXP = enemy.drops?.xp || enemy.exp || 10;
          const baseGold =
            typeof enemy.drops?.gold === "number" ? enemy.drops.gold : typeof enemy.gold === "number" ? enemy.gold : 5;
          const tierMultiplier = {
            TIER_1: 1.0,
            TIER_2: 1.2,
            TIER_3: 1.4,
            TIER_4: 1.6,
            TIER_5: 1.8,
          };

          const xpReward = Math.floor(baseXP * tierMultiplier[enemyTier]);
          const goldReward = Math.floor(baseGold * tierMultiplier[enemyTier]);

          // Add XP and gold to player
          player.xp += xpReward;
          player.gold = (player.gold || 0) + goldReward;

          // Calculate Fury earned (10% of XP)
          const furyEarned = Math.floor(xpReward * 0.1);

          // Add Fury to player
          GameStateManager.state.fury = (GameStateManager.state.fury || 0) + furyEarned;

          // Check if player has the Glitch Stick relic and add fury to it
          if (player.relics && player.relics.glitchStick) {
            RELIC_SYSTEM.addFury(player, "glitchStick", furyEarned);
            this.displayBattleMessage(`You gained ${xpReward} XP, ${goldReward} gold, and ${furyEarned} Fury!`);
          } else {
            // If player doesn't have the relic yet, just show XP and gold
            this.displayBattleMessage(`You gained ${xpReward} XP and ${goldReward} gold!`);
          }

          // Check for level up
          if (player.xp >= player.xpToNextLevel) {
            this.levelUp();
          }

          // Process enemy defeat and check for more enemies
          const result = this.processEnemyDefeat();

          // Always update the UI to ensure player column is updated
          this.updateUI();

          if (result.battleComplete) {
            // All enemies are defeated, end battle
            console.log("[Enemy Death] All enemies defeated, ending battle");
            this.endBattle(false);
          } else {
            // More enemies to fight, continue battle
            console.log("[Enemy Death] More enemies remain, continuing battle");
            this.showBattleMenu();
          }
          this.isActionInProgress = false; // Critical fix: Make sure to reset action flag here
          console.log("[Battle] Resetting isActionInProgress to false");
        },

        disableCombatUI() {
          // Remove all click handlers from battle menu
          const battleMenu = document.getElementById("BattleMenu");
          if (battleMenu) {
            battleMenu.style.pointerEvents = "none";
            const buttons = battleMenu.getElementsByTagName("button");
            for (let button of buttons) {
              button.onclick = null;
            }
          }

          // Remove enemy click handlers
          const enemySide = document.getElementById("enemySide");
          if (enemySide) {
            enemySide.style.pointerEvents = "none";
            enemySide.onclick = null;
          }

          // Remove player click handlers
          const playerSide = document.getElementById("playerSide");
          if (playerSide) {
            playerSide.style.pointerEvents = "none";
            playerSide.onclick = null;
          }
        },

        handlePlayerDeath() {
          this.isActive = false;

          // Remove any existing defeat screens
          const existingDefeatScreens = document.querySelectorAll(".defeat-screen");
          existingDefeatScreens.forEach((screen) => screen.remove());

          // Add styles if they don't exist
          if (!document.getElementById("defeatScreenStyles")) {
            const style = document.createElement("style");
            style.id = "defeatScreenStyles";
            style.textContent = `
                        .defeat-screen {
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(0, 0, 0, 0.85);
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            z-index: 1001;
                        }
                        .defeat-content {
                            background: rgba(40, 0, 0, 0.95);
                            border: 2px solid #ff0000;
                            border-radius: 10px;
                            padding: 20px;
                            text-align: center;
                            animation: glowPulse 2s infinite;
                        }
                        .defeat-content h2 {
                            color: #ff0000;
                            font-size: 24px;
                            margin-bottom: 20px;
                            text-shadow: 0 0 10px #ff0000;
                        }
                        .defeat-options {
                            display: flex;
                            gap: 15px;
                            justify-content: center;
                        }
                        .defeat-options button {
                            background: #300;
                            color: #ff0000;
                            border: 1px solid #ff0000;
                            padding: 10px 20px;
                            font-family: 'Courier New', Courier, monospace;
                            font-size: 12px;
                            cursor: pointer;
                            transition: all 0.3s ease;
                        }
                        .defeat-options button:hover {
                            background: #500;
                            box-shadow: 0 0 10px #ff0000;
                        }
                        @keyframes glowPulse {
                            0% { box-shadow: 0 0 5px #ff0000; }
                            50% { box-shadow: 0 0 20px #ff0000; }
                            100% { box-shadow: 0 0 5px #ff0000; }
                        }
                    `;
            document.head.appendChild(style);
          }

          const defeatScreen = document.createElement("div");
          defeatScreen.className = "defeat-screen";
          defeatScreen.innerHTML = `
                    <div class="defeat-content">
                        <h2>You've Been Defeated</h2>
                        <div class="defeat-options">
                            <button id="loadSaveBtn">Load Last Save</button>
                            <button id="returnStartBtn">Return to Start</button>
                        </div>
                    </div>
                `;
          document.body.appendChild(defeatScreen);

          // Add event listeners
          document.getElementById("loadSaveBtn").addEventListener("click", () => {
            // Try to load the game, only remove the defeat screen if successful
            const loadSuccessful = GameStateManager.load();

            if (loadSuccessful) {
              // Successfully loaded, remove defeat screen
              defeatScreen.remove();

              // Complete battle cleanup
              // Make sure to exit battle mode
              GameStateManager.state.currentState = GAME_STATES.EXPLORE;
              BattleSystem.isActive = false;

              // Make sure input is re-enabled
              InputManager.disabled = false;

              // Clean up any remaining battle UI elements
              const battleContainer = document.getElementById("battleContainer");
              if (battleContainer) {
                battleContainer.innerHTML = "";
                battleContainer.style.display = "none";
              }

              // Remove any message containers that might block input
              const messageContainer = document.querySelector(".message-container");
              if (messageContainer) {
                messageContainer.remove();
              }

              // Reset any battle-related states
              BattleSystem.currentBattle = null;
              BattleSystem.currentEnemies = [];
              BattleSystem.currentEnemyIndex = 0;

              // Force a full UI redraw
              UIManager.redrawUI();

              console.log("[Load Game] Complete battle cleanup performed");
            } else {
              // No save data found, show message but keep defeat screen visible
              const messageElem = document.createElement("div");
              messageElem.textContent = "No saved game found! Please restart the game.";
              messageElem.style.color = "#ffff00";
              messageElem.style.marginTop = "10px";
              messageElem.style.fontWeight = "bold";

              // Remove any existing message first
              const existingMsg = document.querySelector(".no-save-message");
              if (existingMsg) existingMsg.remove();

              // Add class for easy identification
              messageElem.className = "no-save-message";

              // Add to defeat content
              document.querySelector(".defeat-content").appendChild(messageElem);
            }
          });
          document.getElementById("returnStartBtn").addEventListener("click", () => {
            location.reload();
          });
        },

        endBattle(playerFled = false) {
          console.log("[Battle End] Starting battle end sequence");

          // Store enemy reference for cleanup
          const defeatedEnemy = this.currentEnemy;

          // Display victory message
          if (!playerFled) {
            this.displayBattleMessage("Victory! The enemy has been defeated!");
          }

          // Disable combat UI first
          this.disableCombatUI();

          // Set battle inactive but preserve enemy reference for cleanup
          this.isActive = false;
          this.targetingMode = false;
          this.selectedAction = null;

          // Reset all skill cooldowns when battle ends
          this.skillCooldowns = {};

          // Hide battle UI elements with a delay
          setTimeout(() => {
            // Hide all battle UI elements
            const battleElements = ["battleMenu", "battleMessages", "enemySide", "playerSide", "battleUI"];

            battleElements.forEach((id) => {
              const element = document.getElementById(id);
              if (element) {
                element.style.opacity = "0";
                element.style.transition = "opacity 1s ease-out";
              }
            });

            // Show game UI
            const gameUI = document.getElementById("gameUI");
            if (gameUI) {
              gameUI.style.display = "block";
            }

            // Completely hide battle UI after fade
            setTimeout(() => {
              battleElements.forEach((id) => {
                const element = document.getElementById(id);
                if (element) {
                  element.style.display = "none";
                  element.style.opacity = "1"; // Reset opacity for next battle
                  element.style.transition = "none"; // Remove transition
                  if (id === "battleMenu") {
                    element.style.pointerEvents = "auto";
                  }
                }
              });

              // Clear messages
              const battleMessages = document.getElementById("battleMessages");
              if (battleMessages) {
                battleMessages.innerHTML = "";
              }

              // Only change game state and clear enemy reference after ALL cleanup is done
              GameStateManager.state.currentState = GAME_STATES.EXPLORE;
              this.currentEnemy = null; // Now safe to clear enemy reference

              // Remove the defeated enemy from the enemies array
              if (defeatedEnemy && !playerFled) {
                EnemyManager.enemies = EnemyManager.enemies.filter((e) => e !== defeatedEnemy);
                
                // Spawn a new enemy to replace the defeated one (after a short delay to avoid immediate encounters)
                setTimeout(() => {
                  console.log("[Battle End] Spawning new enemy to replace defeated one");
                  EnemyManager.spawnEnemy();
                }, 1000); // 1 second delay before spawning new enemy
              }

              console.log("[Battle End] Battle UI cleanup complete");
            }, 1000);
          }, 500); // Reduced initial delay to make transition smoother

          console.log("[Battle End] Battle ended successfully");
        },

        levelUp() {
          const player = GameStateManager.state.player;
          LEVELING_SYSTEM.levelUp(player);
          this.displayBattleMessage(`Level up! You are now level ${player.level}!`);
          this.updateUI();
        },

        updateEnemyDisplay(enemy) {
          // Update the enemy HP display in the battle UI
          const enemyHPDisplay = document.getElementById("enemyHP");
          const enemyHPBar = document.getElementById("enemyHPBar");

          if (enemyHPDisplay) {
            enemyHPDisplay.textContent = `${enemy.hp}/${enemy.maxHp || enemy.hp}`;
          }

          if (enemyHPBar) {
            const hpPercent = Math.max(0, (enemy.hp / (enemy.maxHp || enemy.hp)) * 100);
            enemyHPBar.style.width = `${hpPercent}%`;
          }

          // We'll trigger damage animations from attack functions directly
          // This prevents animation conflicts
        },

        playAttackSequence(target) {
          console.log("[Animation] Starting attack animation sequence");
          // Create animation container if it doesn't exist
          const container = document.getElementById("combatAnimationContainer");
          if (!container) {
            console.error("[Animation] Container not found");
            return;
          }

          // Get player side position for showing player attack animation
          const playerSide = document.getElementById("playerSide");
          if (!playerSide) {
            console.error("[Animation] PlayerSide not found");
            return;
          }

          // Get enemy side position for playing damage animation later
          const enemySide = document.getElementById("enemySide");
          if (!enemySide) {
            console.error("[Animation] EnemySide not found");
            return;
          }

          // Animation frames for the player attack
          const attackFrames = [
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexAttack1-7XPtIQUgxcUUsGfh6W0nhjLPnTNpo2.png?txDL",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexAttack2-kBEBlqt4sR4BMGgK1C2Am9LNG6oMXN.png?FA0R",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexAttack3-LWwfnSXDYtFMEepLT1wYpTmVfVmkOU.png?Xy3Z",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexAttack4-aH2cIVsemijsDjZlpQwUSqJI6XFMzN.png?u4vq",
          ];

          // Calculate positions
          const playerRect = playerSide.getBoundingClientRect();
          const enemyRect = enemySide.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          // Get message box position for consistent alignment
          const messageBox = document.getElementById("battleMessages");
          let messageTop = 0;
          if (messageBox) {
            const messageRect = messageBox.getBoundingClientRect();
            messageTop = messageRect.top - containerRect.top;
          }

          // Position for player attack animation (on player side)
          const playerPosX = playerRect.left - containerRect.left + playerRect.width / 2;
          // Position animation so bottom aligns with top of message box (accounting for animation height)
          const playerPosY = messageTop - 60; // 60px above message box (moved up 20px total)

          // Create the attack animation element
          const animationElement = document.createElement("div");
          animationElement.id = "playerAttackAnimation"; // Add ID for easier reference
          animationElement.style.cssText = `
            position: absolute;
            width: 80px;
            height: 80px;
            background-image: url('${attackFrames[0]}');
            background-size: contain;
            background-repeat: no-repeat;
            top: ${playerPosY}px;
            left: ${playerPosX}px;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
          `;

          // Don't clear container, append to it - allows multiple animations to exist
          container.appendChild(animationElement);

          console.log("[Animation] Added attack animation element");

          // Play the frame animation
          let currentFrame = 0;
          const frameInterval = setInterval(() => {
            currentFrame = (currentFrame + 1) % attackFrames.length;
            animationElement.style.backgroundImage = `url('${attackFrames[currentFrame]}')`;
            // When we reach the last frame, shake the enemy side
            if (currentFrame === attackFrames.length - 1) {
              console.log("[Animation] Reached last frame, shaking enemy");

              // Make shake animation stronger and more visible
              enemySide.style.animation = "shake 0.5s ease-in-out";
              enemySide.style.animationIterationCount = "2";

              setTimeout(() => {
                enemySide.style.animation = "";
                enemySide.style.animationIterationCount = "";
              }, 1000);

              // Play the damage animation with a slight delay for animated enemies
              // This ensures the shake is visible first, then damage animation plays
              if (
                (target.name === "Space Goblin" || target.name === "Cyber Orc" || target.name === "Meta Troll") &&
                target.hp > 0
              ) {
                setTimeout(() => {
                  this.playEnemyDamageAnimation(target);
                  console.log("[Animation] Triggering damage animation for " + target.name);
                }, 300);
              }
            }
          }, 150);

          // Clean up animation after it completes
          setTimeout(() => {
            console.log("[Animation] Cleaning up attack animation");
            clearInterval(frameInterval);
            if (container.contains(animationElement)) {
              animationElement.remove();
            }
          }, 800); // Slightly longer than 4 frames at 150ms to ensure animation completes
        },

        playPowerStrikeSequence(target) {
          // Create animation container if it doesn't exist
          const container = document.getElementById("combatAnimationContainer");
          if (!container) return;

          // Clear any existing animations
          container.innerHTML = "";

          // Get player and enemy positions
          const playerSide = document.getElementById("playerSide");
          const enemySide = document.getElementById("enemySide");
          if (!playerSide || !enemySide) return;

          // Animation frames for the player attack (regular attack frames)
          const attackFrames = [
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexAttack1-7XPtIQUgxcUUsGfh6W0nhjLPnTNpo2.png?txDL",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexAttack2-kBEBlqt4sR4BMGgK1C2Am9LNG6oMXN.png?FA0R",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexAttack3-LWwfnSXDYtFMEepLT1wYpTmVfVmkOU.png?Xy3Z",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/FlexAttack4-aH2cIVsemijsDjZlpQwUSqJI6XFMzN.png?u4vq",
          ];

          // Animation frames for the projectile
          const projectileFrames = [
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Dumbell1-tkNxE43vye7zxcMeKlwP8Zi6NWY0MX.png?6Jz1",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Dumbell2-5MePnZ0LkVHPrVv7tAxqLi6MYVgDFE.png?mViw",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Dumbell3-BsP09eh5mdra4aNtnub4L6p6tvMrNl.png?PSfW",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Dumbell4-OAjQ0TPf5iTzj60kmmVKtNEWSTD3bP.png?mfZu",
          ];

          // Get positions
          const containerRect = container.getBoundingClientRect();
          const playerRect = playerSide.getBoundingClientRect();
          const enemyRect = enemySide.getBoundingClientRect();
          // Get message box position for consistent alignment
          const messageBox = document.getElementById("battleMessages");
          let messageTop = 0;
          if (messageBox) {
            const messageRect = messageBox.getBoundingClientRect();
            messageTop = messageRect.top - containerRect.top;
          }

          // Position for player attack animation
          const playerPosX = playerRect.left - containerRect.left + playerRect.width / 2;
          // Position animation so bottom aligns with top of message box (accounting for animation height)
          const playerPosY = messageTop - 60; // 60px above message box (moved up 20px total)

          // Position for enemy (target for projectile)
          const enemyPosX = enemyRect.left - containerRect.left + enemyRect.width / 2;
          const enemyPosY = enemyRect.top - containerRect.top + enemyRect.height / 2;

          // Create the player animation element
          const playerElement = document.createElement("div");
          playerElement.style.cssText = `
            position: absolute;
            width: 80px;
            height: 80px;
            background-image: url('${attackFrames[0]}');
            background-size: contain;
            background-repeat: no-repeat;
            top: ${playerPosY}px;
            left: ${playerPosX}px;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
          `;

          container.appendChild(playerElement);

          // First play through the player attack animation TWICE
          let currentFrame = 0;
          let attackCycles = 0;
          const maxAttackCycles = 2; // Play through attack animation twice

          const frameInterval = setInterval(() => {
            // Cycle through all frames
            currentFrame = (currentFrame + 1) % attackFrames.length;
            playerElement.style.backgroundImage = `url('${attackFrames[currentFrame]}')`;

            // When we reach the last frame, count a cycle
            if (currentFrame === attackFrames.length - 1) {
              attackCycles++;

              // If we've completed both cycles, launch the projectile
              if (attackCycles >= maxAttackCycles) {
                clearInterval(frameInterval);

                // Keep player on the last frame (arm extended)
                playerElement.style.backgroundImage = `url('${attackFrames[attackFrames.length - 1]}')`;

                // Now launch the projectile animation
                this.launchProjectile(
                  container,
                  projectileFrames,
                  playerPosX,
                  playerPosY,
                  enemyPosX,
                  enemyPosY,
                  target,
                );
              }
            }
          }, 150); // Same timing as regular attack
        },

        launchProjectile(container, frames, startX, startY, endX, endY, target) {
          // Create the projectile element
          const projectileElement = document.createElement("div");
          projectileElement.style.cssText = `
            position: absolute;
            width: 45px;
            height: 45px;
            background-image: url('${frames[0]}');
            background-size: contain;
            background-repeat: no-repeat;
            top: ${startY}px;
            left: ${startX}px;
            transform: translate(-50%, -50%);
            z-index: 15;
            pointer-events: none;
          `;

          container.appendChild(projectileElement);

          // Calculate distance and movement
          const distanceX = endX - startX;
          const distanceY = endY - startY;
          const totalSteps = 20; // Total animation steps for movement
          const stepX = distanceX / totalSteps;
          const stepY = distanceY / totalSteps;

          let currentStep = 0;
          let currentFrame = 0;

          // Move and animate the projectile
          const projectileInterval = setInterval(() => {
            // Update frame
            currentFrame = (currentFrame + 1) % frames.length;
            projectileElement.style.backgroundImage = `url('${frames[currentFrame]}')`;

            // Update position
            currentStep++;
            const newX = startX + stepX * currentStep;
            const newY = startY + stepY * currentStep;

            projectileElement.style.left = `${newX}px`;
            projectileElement.style.top = `${newY}px`;

            // Check if we've reached the enemy
            if (currentStep >= totalSteps) {
              clearInterval(projectileInterval);

              // Create impact effect
              const enemySide = document.getElementById("enemySide");
              if (enemySide) {
                // Shake more violently for power strike
                enemySide.style.animation = "shake 0.6s ease-in-out 2";
                setTimeout(() => {
                  enemySide.style.animation = "";
                }, 1200);
              }

              // Play the appropriate damage animation for the target based on enemy type
              // Don't check HP here - we want to show damage animation even if killed in one hit
              if (target.name === "Cyber Orc") {
                console.log("[PLAYER ATTACK] Playing Cyber Orc damage animation");
                // Directly create and play Cyber Orc damage animation
                const damageContainer = document.getElementById("combatAnimationContainer");
                if (damageContainer) {
                  const cyberOrcDamageFrames = [
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit1-Z3JxjiJ5lUV1RDd0BI2YciiXnC4rqx.png?jN4v",
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit2-h4mQBbxIIL0TfvJ4MSrhYqXlnBy910.png?TqWl",
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit3-W1S8bpuUt0VAGi6kryJuNGMjjA1qlZ.png?usrf",
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit4-GmumGPXWv1ggmVGEXYCwZEWdieIWZp.png?NSc6",
                  ];

                  const enemyRect = enemySide.getBoundingClientRect();
                  const containerRect = damageContainer.getBoundingClientRect();
                  const messageBox = document.getElementById("battleMessages");
                  let messageTop = messageBox ? messageBox.getBoundingClientRect().top - containerRect.top : 300;

                  const posX = enemyRect.left - containerRect.left + enemyRect.width / 2;
                  const posY = messageTop - 50;

                  const damageElement = document.createElement("div");
                  damageElement.id = "cyberOrcDamageAnimation";
                  damageElement.style.cssText = `
                    position: absolute;
                    width: 100px;
                    height: 100px;
                    background-image: url('${cyberOrcDamageFrames[0]}');
                    background-size: contain;
                    background-repeat: no-repeat;
                    top: ${posY}px;
                    left: ${posX}px;
                    transform: translate(-50%, -50%) scaleX(-1);
                    z-index: 25;
                    pointer-events: none;
                  `;

                  damageContainer.appendChild(damageElement);

                  let damageFrame = 0;
                  const updateDamageFrame = () => {
                    damageFrame++;
                    if (damageFrame < cyberOrcDamageFrames.length) {
                      damageElement.style.backgroundImage = `url('${cyberOrcDamageFrames[damageFrame]}')`;
                      setTimeout(updateDamageFrame, 150);
                    } else {
                      setTimeout(() => {
                        if (damageContainer.contains(damageElement)) {
                          damageElement.remove();
                        }
                      }, 100);
                    }
                  };

                  setTimeout(updateDamageFrame, 150);
                }
              } else if (target.name === "Meta Troll") {
                console.log("[PLAYER ATTACK] Playing Meta Troll damage animation - EXACT COPY VERSION");
                // Copy EXACTLY the same pattern that works for Cyber Orc
                const damageContainer = document.getElementById("combatAnimationContainer");
                if (damageContainer) {
                  // Use the correct Troll_Pain URLs that exist
                  const metaTrollDamageFrames = [
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_1-7HXxomEVKjjM0FrgxQxsrpTYLiHcwZ.png?4cGL",
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_2-tpDFg7C9hgDajhb59B8C3OomKg0OAp.png?C5gY",
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_3-XGOEsD0gi1PtjG4WejhRtsUP9ANT9A.png?ce1w",
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_4-ME7OEC0JoKJFhH7asG5iORVeLfPY6D.png?u2fj",
                  ];

                  // Use EXACTLY the same positioning logic as Cyber Orc
                  const enemyRect = enemySide.getBoundingClientRect();
                  const containerRect = damageContainer.getBoundingClientRect();
                  const messageBox = document.getElementById("battleMessages");
                  let messageTop = messageBox ? messageBox.getBoundingClientRect().top - containerRect.top : 300;

                  const posX = enemyRect.left - containerRect.left + enemyRect.width / 2;
                  const posY = messageTop - 50;

                  // Use same element creation and styling pattern as Cyber Orc
                  const damageElement = document.createElement("div");
                  damageElement.id = "metaTrollDamageAnimation";
                  damageElement.style.cssText = `
                    position: absolute;
                    width: 100px;
                    height: 100px;
                    background-image: url('${metaTrollDamageFrames[0]}');
                    background-size: contain;
                    background-repeat: no-repeat;
                    top: ${posY}px;
                    left: ${posX}px;
                    transform: translate(-50%, -50%) scaleX(-1);
                    z-index: 25;
                    pointer-events: none;
                  `;

                  damageContainer.appendChild(damageElement);

                  // Use EXACTLY the same animation logic as Cyber Orc
                  let damageFrame = 0;
                  const updateDamageFrame = () => {
                    damageFrame++;
                    if (damageFrame < metaTrollDamageFrames.length) {
                      damageElement.style.backgroundImage = `url('${metaTrollDamageFrames[damageFrame]}')`;
                      setTimeout(updateDamageFrame, 150);
                    } else {
                      setTimeout(() => {
                        if (damageContainer.contains(damageElement)) {
                          damageElement.remove();
                        }
                      }, 100);
                    }
                  };

                  setTimeout(updateDamageFrame, 150);
                }
              } else {
                // For Space Goblin and any other enemy types, use the existing function
                this.playEnemyDamageAnimation(target);
              }

              // Clean up projectile after impact
              setTimeout(() => {
                if (container.contains(projectileElement)) {
                  projectileElement.remove();
                  console.log("[Animation] Removed projectile element");
                }

                // Also clean up player element after a delay, but keep any damage animations
                setTimeout(() => {
                  // Look for the specific player attack animation element (not everything)
                  const playerElements = container.querySelectorAll("div:not(#enemyDamageAnimation)");
                  playerElements.forEach((el) => {
                    if (el.id !== "enemyDamageAnimation") {
                      el.remove();
                      console.log("[Animation] Removed player animation element");
                    }
                  });
                }, 500);
              }, 300);
            }
          }, 80); // Faster animation for projectile movement (smoother)
        },

        playEnemyDamageAnimation(target) {
          console.log("[Animation] Starting enemy damage animation");
          // Create animation container if it doesn't exist
          const container = document.getElementById("combatAnimationContainer");
          if (!container) {
            console.error("[Animation] Container not found for enemy damage");
            return;
          }

          // Get enemy side position for proper placement
          const enemySide = document.getElementById("enemySide");
          if (!enemySide) {
            console.error("[Animation] EnemySide not found for damage animation");
            return;
          }

          // Get the enemy side's position
          const enemyRect = enemySide.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();

          // Get message box position for consistent alignment
          const messageBox = document.getElementById("battleMessages");
          let messageTop = 0;
          if (messageBox) {
            const messageRect = messageBox.getBoundingClientRect();
            messageTop = messageRect.top - containerRect.top;
          }

          // Get the correct damage animation frames based on enemy type
          let damageFrames = [];
          let usePreloadedImages = false;
          let preloadedImages = [];

          if (target.name === "Space Goblin") {
            // Space Goblin damage animation frames
            damageFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPDamage1-bddq1HkvRWO4of3LPFYPjwUKqkfAg9.png?2n4z",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPDamage2-J55F9eyUeRdr3nUvqxTt7zDXzpgAXh.png?ejgU",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPDamage3-7tqeRZgrTJ3GzFnF774qZEz5DrTBlk.png?7QV9",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPDamage4-lf1vJeEdlGUbCyFxWS0UIFjyp6nW8o.png?hAWk",
            ];
          } else if (target.name === "Cyber Orc") {
            // Check if we have preloaded images for Cyber Orc
            if (this.cyberOrcHitFrameImages && this.cyberOrcHitFrameImages.length > 0) {
              usePreloadedImages = true;
              preloadedImages = this.cyberOrcHitFrameImages;
              console.log("[DEBUG-DAMAGE] Using preloaded Cyber Orc damage images");
            } else {
              // Fallback to URLs if preloaded images aren't available
              damageFrames = [
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit1-Z3JxjiJ5lUV1RDd0BI2YciiXnC4rqx.png?jN4v",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit2-h4mQBbxIIL0TfvJ4MSrhYqXlnBy910.png?TqWl",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit3-W1S8bpuUt0VAGi6kryJuNGMjjA1qlZ.png?usrf",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit4-GmumGPXWv1ggmVGEXYCwZEWdieIWZp.png?NSc6",
              ];
              console.log("[DEBUG-DAMAGE] Falling back to Cyber Orc damage URLs");
            }
          } else if (target.name === "Meta Troll") {
            // Check if we have preloaded images for Meta Troll
            if (this.metaTrollDamageFrameImages && this.metaTrollDamageFrameImages.length > 0) {
              usePreloadedImages = true;
              preloadedImages = this.metaTrollDamageFrameImages;
              console.log("[DEBUG-DAMAGE] Using preloaded Meta Troll damage images");
            } else {
              // Fallback to URLs if preloaded images aren't available
              damageFrames = [
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_1-7HXxomEVKjjM0FrgxQxsrpTYLiHcwZ.png?4cGL",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_2-tpDFg7C9hgDajhb59B8C3OomKg0OAp.png?C5gY",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_3-XGOEsD0gi1PtjG4WejhRtsUP9ANT9A.png?ce1w",
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_4-ME7OEC0JoKJFhH7asG5iORVeLfPY6D.png?u2fj",
              ];
              console.log("[DEBUG-DAMAGE] Falling back to Meta Troll damage URLs");
            }
          } else {
            // Default to Space Goblin frames if enemy type not recognized
            console.log(`[Animation] No specific damage frames for ${target.name}, using defaults`);
            damageFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPDamage1-bddq1HkvRWO4of3LPFYPjwUKqkfAg9.png?2n4z",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPDamage2-J55F9eyUeRdr3nUvqxTt7zDXzpgAXh.png?ejgU",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPDamage3-7tqeRZgrTJ3GzFnF774qZEz5DrTBlk.png?7QV9",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GPDamage4-lf1vJeEdlGUbCyFxWS0UIFjyp6nW8o.png?hAWk",
            ];
          }

          // Calculate position (x at center of enemy side, y positioned so bottom aligns with message box)
          const posX = enemyRect.left - containerRect.left + enemyRect.width / 2;
          // Position animation so bottom aligns with top of message box (accounting for animation height)
          const posY = messageTop - 50; // 50px above message box (moved up 20px total)

          // Create the animation element
          const animationElement = document.createElement("div");
          animationElement.id = "enemyDamageAnimation"; // Add an ID for easier reference

          // Adjust size based on enemy type
          let width = 60;
          let height = 60;

          // Make Cyber Orc animations larger
          if (target.name === "Cyber Orc") {
            width = 100;
            height = 100;
          } else if (target.name === "Meta Troll") {
            width = 90;
            height = 90;
          }

          // Set initial background image based on whether we're using preloaded images or direct URLs
          let initialImageUrl = usePreloadedImages
            ? preloadedImages[0] && preloadedImages[0].src
              ? preloadedImages[0].src
              : damageFrames[0]
            : damageFrames[0];

          animationElement.style.cssText = `
            position: absolute;
            width: ${width}px;
            height: ${height}px;
            background-image: url('${initialImageUrl}');
            background-size: contain;
            background-repeat: no-repeat;
            top: ${posY}px;
            left: ${posX}px;
            transform: translate(-50%, -50%) scaleX(-1); /* Flip horizontally */
            z-index: 20; /* Higher z-index to appear above other animations */
            pointer-events: none;
          `;

          // Add the damage animation element to the container (don't clear container)
          container.appendChild(animationElement);

          // Frame duration in milliseconds
          const frameDuration = 150;
          let currentFrame = 0;

          // Function to update the animation frame
          const updateFrame = () => {
            currentFrame++;

            // Check if we have more frames to show
            const maxFrames = usePreloadedImages ? preloadedImages.length : damageFrames.length;

            if (currentFrame < maxFrames) {
              // Update to next frame - use preloaded image or URL based on what's available
              let nextImageUrl;

              if (usePreloadedImages) {
                const img = preloadedImages[currentFrame];
                nextImageUrl = img && img.complete ? img.src : damageFrames[currentFrame] || "";
              } else {
                nextImageUrl = damageFrames[currentFrame];
              }

              // Update the image
              animationElement.style.backgroundImage = `url('${nextImageUrl}')`;
              setTimeout(updateFrame, frameDuration);
            } else {
              // Animation complete - only remove THIS animation element, not all animations
              setTimeout(() => {
                if (container.contains(animationElement)) {
                  animationElement.remove();
                  console.log("[Animation] Enemy damage animation completed and removed");
                }
              }, 100);
            }
          };

          // Start the animation sequence
          setTimeout(updateFrame, frameDuration);
        },

        playPlayerDamageAnimation() {
          console.log("[Animation] Starting player damage animation");
          // Create animation container if it doesn't exist
          const container = document.getElementById("combatAnimationContainer");
          if (!container) {
            console.error("[Animation] Container not found for player damage");
            return;
          }

          // Get player side position for proper placement
          const playerSide = document.getElementById("playerSide");
          if (!playerSide) {
            console.error("[Animation] PlayerSide not found for damage animation");
            return;
          }

          // Flexecutioner pain animation frames
          const damageFrames = [
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flexpain1-VidLzxaX8slQ5LebWcBLxSF1EVxZAB.png?JB5G",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flexpain2-4ypOl4nhWBQbqwzdgtaumvyjVRbu6l.png?yIYW",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flexpain3-9EgutoIdKOabJfgesmPCznr5S3kmvd.png?CatC",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flexpain4-GkB5jPDGiNG7XBLlAlOchpzSqcy7DH.png?VMPC",
          ];

          // Get the player side's position
          const playerRect = playerSide.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          // Get message box position for consistent alignment
          const messageBox = document.getElementById("battleMessages");
          let messageTop = 0;
          if (messageBox) {
            const messageRect = messageBox.getBoundingClientRect();
            messageTop = messageRect.top - containerRect.top;
          }

          // Calculate position (x at center of player side, y positioned so bottom aligns with message box)
          const posX = playerRect.left - containerRect.left + playerRect.width / 2;
          // Position animation so bottom aligns with top of message box (accounting for animation height)
          const posY = messageTop - 55; // 55px above message box (moved up 20px total)

          // Create the animation element
          const animationElement = document.createElement("div");
          animationElement.id = "playerDamageAnimation"; // Add an ID for easier reference
          animationElement.style.cssText = `
            position: absolute;
            width: 70px;
            height: 70px;
            background-image: url('${damageFrames[0]}');
            background-size: contain;
            background-repeat: no-repeat;
            top: ${posY}px;
            left: ${posX}px;
            transform: translate(-50%, -50%);
            z-index: 20; /* Higher z-index to appear above other animations */
            pointer-events: none;
          `;

          // Add the damage animation element to the container (don't clear container)
          container.appendChild(animationElement);

          // Frame duration in milliseconds
          const frameDuration = 150;
          let currentFrame = 0;

          // Function to update the animation frame
          const updateFrame = () => {
            currentFrame++;

            if (currentFrame < damageFrames.length) {
              // Update to next frame
              animationElement.style.backgroundImage = `url('${damageFrames[currentFrame]}')`;
              setTimeout(updateFrame, frameDuration);
            } else {
              // Animation complete - only remove THIS animation element, not all animations
              setTimeout(() => {
                if (container.contains(animationElement)) {
                  animationElement.remove();
                  console.log("[Animation] Player damage animation completed and removed");
                }
              }, 100);
            }
          };

          // Start the animation sequence
          setTimeout(updateFrame, frameDuration);
        },

        // Add any other necessary methods for the battle system
      };

      // Initialize skill cooldowns when BattleSystem is first defined
      if (!BattleSystem.skillCooldowns) {
        BattleSystem.skillCooldowns = {};
      }

      // Enemy Management
      const EnemyManager = {
        enemies: [],
        maxEnemies: 5,
        spawnRate: 0.015,
        lastSpawn: 0,
        lastFrame: 0,
        enemySprites: {
          /* Use the first frame of idle animations for base sprites for consistency */
          "Space Goblin":
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/IdleGob1-lAD0YuwStAmTVR5y5PLDLg9pgZDkWk.png?ulAb",
          "Meta Troll":
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Idle_1-k4ROEaNhVkwqcosB8UbbrlwNkYyb94.png?qrLx",
          "Cyber Orc":
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Orcidle1-tIHYu4iKpGIkvSeVxPFMXlVHcge99h.png?DMfe",
          default:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/defaultEnemy-wCbZhU6hEjFZcdwbgC5Aqrw66Zr2WK.png?KfzR",
        },

        // Animation frames for Space Goblin
        spaceGoblinIdleFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/IdleGob1-lAD0YuwStAmTVR5y5PLDLg9pgZDkWk.png?ulAb",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/IdleGob2-zv7jML6xoty4qMWhPbq5j6QqCaw7Hd.png?ZzzR",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/IdleGob3-xWaNuWPOC7oEsWqPM8IB4yh3pmlNvM.png?bSyw",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/IdleGob4-LrgjZsJ9HtjppJ3YR3w9TCZ3Mi17e1.png?RQ4W",
        ],

        // Animation frames for Cyber Orc
        cyberOrcIdleFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Orcidle1-tIHYu4iKpGIkvSeVxPFMXlVHcge99h.png?DMfe",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Orcidle2-MINruHfyfYteSoEnFEK2i2sL0eKWuw.png?pb5I",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Orcidle3-8x3RcmRZoaNEcy3QuxlTf2d46ibMLa.png?PoNF",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Orcidle4-6MF80s9THdUcfSaK8QGSyHUnvt0HrW.png?vrSw",
        ],

        // Animation frames for Meta Troll
        metaTrollIdleFrames: [
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Idle_1-k4ROEaNhVkwqcosB8UbbrlwNkYyb94.png?qrLx",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Idle_2-f7cpS5NytmHONIQnXIKAR0ZHIsSYq7.png?S2SG",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Idle_3-wV1Mr0FtV1hgxiqbQnIs6gnEahYeem.png?1B2L",
          "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Idle_4-KWrZET3JkYQBdCBHz8kx4AdcwX6886.png?Q8Zy",
        ],

        // Animation timing properties
        animationFrameRate: 200, // milliseconds per frame
        lastFrameTime: 0,
        currentAnimationFrame: 0,

        // Preload animation frames so they're ready to use
        preloadAnimationFrames() {
          // Preload Space Goblin animation frames
          if (!this.spaceGoblinIdleFramesLoaded) {
            this.spaceGoblinIdleFramesLoaded = true;
            this.spaceGoblinIdleFrameImages = [];

            this.spaceGoblinIdleFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Space Goblin animation frame ${index + 1} loaded`);
              };
              this.spaceGoblinIdleFrameImages.push(img);
            });
          }

          // Preload Cyber Orc idle frames
          if (!this.cyberOrcIdleFramesLoaded) {
            this.cyberOrcIdleFramesLoaded = true;
            this.cyberOrcIdleFrameImages = [];

            this.cyberOrcIdleFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Cyber Orc idle frame ${index + 1} loaded`);
              };
              this.cyberOrcIdleFrameImages.push(img);
            });
          }

          // Preload Cyber Orc attack frames
          if (!this.cyberOrcAttackFramesLoaded) {
            this.cyberOrcAttackFramesLoaded = true;
            this.cyberOrcAttackFrameImages = [];

            // Define Cyber Orc attack frames if not already defined
            this.cyberOrcAttackFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot1-0UdRg4aj8OP1AWAR0Vq5nrsWGj0Pep.png?ADXW",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot2-Jxemlizz9MMFqXn36ZclwjOpwMqm96.png?gAo3",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot3-BhNo7CtJmCeEsEj9pSz7WaMYzWRAMV.png?PjlM",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcShot4-End5wwXjUv7JkLNvakyNzJeqcIvM37.png?MNJ2",
            ];

            this.cyberOrcAttackFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Cyber Orc attack frame ${index + 1} loaded`);
              };
              this.cyberOrcAttackFrameImages.push(img);
            });
          }

          // Preload Cyber Orc damage frames
          if (!this.cyberOrcDamageFramesLoaded) {
            this.cyberOrcDamageFramesLoaded = true;
            this.cyberOrcDamageFrameImages = [];

            // Define Cyber Orc damage frames if not already defined
            this.cyberOrcDamageFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit1-hHQeSzKnv1HCdsjWGZUl6N1LcXNAOT.png?qVhS",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit2-AvijdFl16hLH7vfnPtKlqEDXrCqjJR.png?n7qZ",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit3-bw5sUg9m2Kxwt4U0XwZuCnD8C3oOZt.png?PYHi",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/OrcHit4-c2UkxB9yPLnALTIZ8EFo3OCY4oGaT4.png?dD7p",
            ];

            this.cyberOrcDamageFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Cyber Orc damage frame ${index + 1} loaded`);
              };
              this.cyberOrcDamageFrameImages.push(img);
            });
          }

          // Preload Meta Troll idle frames
          if (!this.metaTrollIdleFramesLoaded) {
            this.metaTrollIdleFramesLoaded = true;
            this.metaTrollIdleFrameImages = [];

            this.metaTrollIdleFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Meta Troll idle frame ${index + 1} loaded`);
              };
              this.metaTrollIdleFrameImages.push(img);
            });
          }

          // Preload Meta Troll attack frames
          if (!this.metaTrollAttackFramesLoaded) {
            this.metaTrollAttackFramesLoaded = true;
            this.metaTrollAttackFrameImages = [];

            // Define Meta Troll attack frames if not already defined
            this.metaTrollAttackFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_1-BcG4hrD1BZVmW0UkKQ1g1xTrMLTsGF.png?f2LA",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_2-bv2od1zpdNDbt3rrN3tzHC2wa0v6Uu.png?IkSe",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_3-qTXvBL3mNYlaGNfgkqopgvNFscgTrS.png?WubI",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Attack_4-OtB270wajPYBFWrRVmXGleiGqJ8Wwj.png?VhAs",
            ];

            this.metaTrollAttackFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Meta Troll attack frame ${index + 1} loaded`);
              };
              this.metaTrollAttackFrameImages.push(img);
            });
          }

          // Preload Meta Troll damage frames
          if (!this.metaTrollDamageFramesLoaded) {
            this.metaTrollDamageFramesLoaded = true;
            this.metaTrollDamageFrameImages = [];

            // Define Meta Troll damage frames - using the correct Pain URLs that work
            this.metaTrollDamageFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_1-7HXxomEVKjjM0FrgxQxsrpTYLiHcwZ.png?4cGL",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_2-tpDFg7C9hgDajhb59B8C3OomKg0OAp.png?C5gY",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_3-XGOEsD0gi1PtjG4WejhRtsUP9ANT9A.png?ce1w",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Pain_4-ME7OEC0JoKJFhH7asG5iORVeLfPY6D.png?u2fj",
            ];

            this.metaTrollDamageFrames.forEach((url, index) => {
              const img = new Image();
              img.src = url;
              img.onload = () => {
                console.log(`Meta Troll damage frame ${index + 1} loaded`);
              };
              this.metaTrollDamageFrameImages.push(img);
            });
          }

          // Start animation update timer if it doesn't exist
          if (!this.animationTimer) {
            console.log("Starting animation timer");
            // CRITICAL FIX: Update more frequently for smoother animations (100ms instead of 250ms)
            this.animationTimer = setInterval(() => {
              this.updateAnimations(Date.now());
            }, 100); // Update every 100ms for smoother animations
          }
        },

        // Function to update animation frames
        updateAnimations(timestamp) {
          // If no timestamp provided, force an update using current time
          if (!timestamp) {
            timestamp = Date.now();
          }

          const now = timestamp;

          // Initialize lastAnimationUpdate if it doesn't exist yet
          if (!this.lastAnimationUpdate) {
            this.lastAnimationUpdate = now;
          }

          // Initialize animation frame counter if needed
          if (typeof this.currentAnimationFrame !== "number") {
            this.currentAnimationFrame = 0;
          }

          // Ensure we have a default animation frame rate
          if (!this.animationFrameRate) {
            this.animationFrameRate = 150; // Milliseconds between frame updates
          }

          const elapsed = now - this.lastAnimationUpdate;

          // Check if it's time to advance the animation frame
          if (elapsed > this.animationFrameRate) {
            // Calculate how many frames to advance (in case of lag)
            const framesToAdvance = Math.max(1, Math.floor(elapsed / this.animationFrameRate));

            // Update animation frame counter (limit to 4 frames)
            this.currentAnimationFrame = (this.currentAnimationFrame + framesToAdvance) % 4;
            this.lastAnimationUpdate = now;

            console.log(
              `ANIMATION FRAME UPDATED to: ${this.currentAnimationFrame} (advanced ${framesToAdvance} frames)`,
            );

            // Debug loaded frames information
            console.log(
              `Animation Debug: CyberOrc frames: ${this.cyberOrcIdleFrameImages?.length || 0}, SpaceGoblin frames: ${this.spaceGoblinIdleFrameImages?.length || 0}`,
            );

            // CRITICAL INTEGRITY CHECK - Ensure enemy types haven't been corrupted
            if (this.enemies && this.enemies.length > 0) {
              this.enemies.forEach((enemy) => {
                // If an enemy has been converted but was originally a Cyber Orc, fix it
                if (enemy.originalName === "Cyber Orc" && enemy.name !== "Cyber Orc") {
                  console.log("AUTO-FIXING CORRUPTED ENEMY TYPE");
                  enemy.name = "Cyber Orc";
                  enemy.type = "Cyber Orc";
                  enemy.useAnimatedSprite = true;
                }
              });
            }
          }
        },

        // Get the current animation frame for a specific enemy type
        getEnemySprite(enemy) {
          // NEW CODE - URGENT FIX: Always check and restore original values if needed
          if (enemy.originalName === "Cyber Orc" && enemy.name !== "Cyber Orc") {
            console.log("FIXING ENEMY TYPE: Restoring Cyber Orc proper type/name");
            enemy.name = "Cyber Orc";
            enemy.type = "Cyber Orc";
            enemy.useAnimatedSprite = true;
          }

          // CRITICAL FIX: Make sure we have a valid animation frame
          // Initialize if needed
          if (typeof this.currentAnimationFrame !== "number") {
            this.currentAnimationFrame = 0;
          }

          // Force frame to be within valid range
          const frameIndex = this.currentAnimationFrame % 4;

          // Log all relevant properties to help with debugging
          console.log(
            `Getting sprite for enemy: name=${enemy.name}, type=${enemy.type}, useAnimatedSprite=${enemy.useAnimatedSprite}, frame=${frameIndex}`,
          );

          // IMPORTANT: Check for Cyber Orc FIRST
          // Check both name and type for Cyber Orc
          if (
            (enemy.name === "Cyber Orc" || enemy.type === "Cyber Orc" || enemy.originalName === "Cyber Orc") &&
            this.cyberOrcIdleFrameImages &&
            this.cyberOrcIdleFrameImages.length > 0
          ) {
            console.log(`Using Cyber Orc animation frame: ${frameIndex}`);
            return this.cyberOrcIdleFrameImages[frameIndex];
          }

          // SECOND: Check for Space Goblin
          // Check both name and type for Space Goblin
          if (
            (enemy.name === "Space Goblin" || enemy.type === "Space Goblin") &&
            this.spaceGoblinIdleFrameImages &&
            this.spaceGoblinIdleFrameImages.length > 0
          ) {
            console.log(`Using Space Goblin animation frame: ${frameIndex}`);
            return this.spaceGoblinIdleFrameImages[frameIndex];
          }

          // THIRD: Check for Meta Troll
          // Check both name and type for Meta Troll
          if (
            (enemy.name === "Meta Troll" || enemy.type === "Meta Troll") &&
            this.metaTrollIdleFrameImages &&
            this.metaTrollIdleFrameImages.length > 0
          ) {
            console.log(`Using Meta Troll animation frame: ${frameIndex}`);
            return this.metaTrollIdleFrameImages[frameIndex];
          }

          // Use standard sprite for other enemy types
          // If we have a loaded image object, use that
          if (enemy.sprite && enemy.sprite instanceof Image) {
            console.log(`Using standard sprite for: ${enemy.name}`);
            return enemy.sprite;
          }

          // Otherwise fall back to URL
          console.log(`Using fallback sprite URL for: ${enemy.name}`);
          return this.enemySprites[enemy.name] || this.enemySprites.default;
        },

        spawnEnemy() {
          if (this.enemies.length >= this.maxEnemies) return;

          // Make sure animation frames are loaded
          this.preloadAnimationFrames();

          const enemyTypes = [
            {
              name: "Space Goblin",
              hp: 20,
              mp: 10,
              attack: 5,
              defense: 2,
              magic: 3,
              speed: 4,
              exp: 10,
              gold: 5,
              // Using first frame of idle animation for consistency
              spriteUrl:
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/IdleGob1-lAD0YuwStAmTVR5y5PLDLg9pgZDkWk.png?ulAb",
            },
            {
              name: "Meta Troll",
              hp: 25,
              mp: 15,
              attack: 6,
              defense: 3,
              magic: 4,
              speed: 3,
              exp: 15,
              gold: 8,
              // Using first frame of idle animation for consistency
              spriteUrl:
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Troll_Idle_1-k4ROEaNhVkwqcosB8UbbrlwNkYyb94.png?qrLx",
            },
            {
              name: "Cyber Orc",
              hp: 30,
              mp: 20,
              attack: 8,
              defense: 4,
              magic: 5,
              speed: 2,
              exp: 20,
              gold: 12,
              // Using first frame of idle animation for consistency
              spriteUrl:
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Orcidle1-tIHYu4iKpGIkvSeVxPFMXlVHcge99h.png?DMfe",
            },
          ];

          const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
          console.log("Selected enemy type:", enemyType.name);

          // Immediately create sprite as proper Image object
          const spriteImg = new Image();
          spriteImg.src = enemyType.spriteUrl;

          // Calculate safe spawn boundaries (25 pixels from edges)
          const minX = Math.ceil(25 / GRID_SIZE);
          const maxX = Math.floor((MAP_WIDTH * GRID_SIZE - 25) / GRID_SIZE) - 1;
          const minY = Math.ceil(25 / GRID_SIZE);
          const maxY = Math.floor((MAP_HEIGHT * GRID_SIZE - 25) / GRID_SIZE) - 1;

          // Helper: check if tile is walkable - ENHANCED WITH SAFETY MARGIN
          function isWalkable(x, y) {
            // Coordinate validation
            if (x < 0 || y < 0 || x >= MAP_WIDTH || y >= MAP_HEIGHT) {
              console.log(`Position (${x},${y}) is out of bounds`);
              return false;
            }

            // Define helper function to check if a specific coordinate has collision
            function hasCollision(checkX, checkY) {
              // Skip checks for coordinates outside the map
              if (checkX < 0 || checkY < 0 || checkX >= MAP_WIDTH || checkY >= MAP_HEIGHT) {
                return false; // Treat out-of-bounds as non-collision for adjacent checks
              }

              const checkKey = `${checkX},${checkY}`;
              if (DEBUG && DEBUG.collisionMap) {
                return DEBUG.collisionMap.get(checkKey);
              }
              return false;
            }

            // First, explicitly check the DEBUG collision map for the tile itself
            try {
              // Log for debugging - helps catch any unexpected collision values
              console.log(`Checking collision at (${x},${y}) and adjacent tiles`);

              // CRITICAL: Check the tile itself first
              if (hasCollision(x, y)) {
                console.log(`❌ Direct collision found at (${x},${y}) - blocking enemy spawn`);
                return false;
              }

              // NEW SAFETY MARGIN: Check all 8 adjacent tiles (1-tile safety margin)
              const adjacentOffsets = [
                [-1, -1],
                [0, -1],
                [1, -1], // Top row
                [-1, 0],
                [1, 0], // Middle row (excluding center)
                [-1, 1],
                [0, 1],
                [1, 1], // Bottom row
              ];

              for (const [offsetX, offsetY] of adjacentOffsets) {
                const adjacentX = x + offsetX;
                const adjacentY = y + offsetY;

                if (hasCollision(adjacentX, adjacentY)) {
                  console.log(`⚠️ Adjacent collision found at (${adjacentX},${adjacentY}) - enforcing safety margin`);
                  return false; // Adjacent collision found - maintain safety margin
                }
              }

              // Even if no collision in the map, do a secondary check with the tile data
              // Basic tile check - validate tile exists
              const tile =
                GameStateManager.state.map && GameStateManager.state.map[y] && GameStateManager.state.map[y][x];

              if (tile === undefined) {
                console.log(`Tile at (${x},${y}) is undefined - blocking enemy spawn`);
                return false;
              }

              // Only allow floor (0) or grass (3) tiles for spawning
              if (tile !== 0 && tile !== 3) {
                console.log(`Tile type ${tile} at (${x},${y}) is not allowed for spawning`);
                return false;
              }

              // Additional check: see if player is here (don't spawn directly on player)
              if (
                GameStateManager.state.player &&
                GameStateManager.state.player.x === x &&
                GameStateManager.state.player.y === y
              ) {
                console.log(`Player is at (${x},${y}) - blocking enemy spawn`);
                return false;
              }

              // EMERGENCY FIX: Hardcode known problematic collision spots that may be missed
              const knownProblemSpots = [
                { x: 18, y: 18 }, // Explicitly block the spot you identified
                { x: 9, y: 12 }, // Other spots that might be problematic
                { x: 11, y: 11 },
                { x: 24, y: 9 },
                { x: 26, y: 3 },
                { x: 10, y: 1 },
                { x: 28, y: 6 },
                { x: 3, y: 3 },
              ];

              // Check if current position is in the known problem spots list
              if (knownProblemSpots.some((spot) => spot.x === x && spot.y === y)) {
                console.log(`🚫 Blocked spawn at known problem spot (${x},${y})`);
                return false;
              }

              // If we pass all checks, the location is valid for spawning
              return true;
            } catch (e) {
              console.error(`Critical error checking walkable at (${x},${y}):`, e);
              // If there was any error, be conservative and don't allow spawning
              return false;
            }
          }
          // Helper: check if another enemy is already here
          function isOccupied(x, y) {
            return EnemyManager.enemies.some((e) => e.x === x && e.y === y);
          }
          // Try up to 20 times to find a valid spawn
          let spawnX,
            spawnY,
            tries = 0;
          do {
            spawnX = Math.floor(Math.random() * (maxX - minX + 1)) + minX;
            spawnY = Math.floor(Math.random() * (maxY - minY + 1)) + minY;
            tries++;
          } while ((!isWalkable(spawnX, spawnY) || isOccupied(spawnX, spawnY)) && tries < 20);

          // Create a clean enemy object WITHOUT spreading enemyType (IMPORTANT FIX)
          const enemy = {
            // Stats & Status
            maxHp: enemyType.hp,
            maxMp: enemyType.mp,
            currentHp: enemyType.hp,
            currentMp: enemyType.mp,
            x: spawnX,
            y: spawnY,
            width: 32,
            height: 32,
            sprite: new Image(),
            portalFrames: [],
            portalFrameIndex: 0,
            portalAnimationComplete: false,
            portalAnimationSpeed: 0.005, // Slowed down from 0.05 to 0.005 (10x slower)
            stats: {
              hp: enemyType.hp,
              maxHp: enemyType.hp,
              attack: enemyType.attack,
              defense: enemyType.defense,
            },
            drops: {
              gold: { min: enemyType.gold, max: enemyType.gold * 2 },
              xp: enemyType.exp,
            },
            // CRITICAL FIX: Explicitly set the name and type for animations
            name: enemyType.name,
            type: enemyType.name,
            // CRITICAL FIX: Lock enemy type
            isLocked: true,
            // Special flag to prevent type from being overwritten
            isSpecialEnemyType: true,
            // Original type information - redundant safeguard
            originalName: enemyType.name,
            originalType: enemyType.name,
            // Set animated sprite flag based on enemy type
            useAnimatedSprite:
              enemyType.name === "Space Goblin" || enemyType.name === "Cyber Orc" || enemyType.name === "Meta Troll",
          };

          // CRITICAL DEBUGGING LOG - Record the enemy's creation data
          console.log(`Created ${enemy.name} with type=${enemy.type}, useAnimatedSprite=${enemy.useAnimatedSprite}`);

          // Set sprite image that we already created
          enemy.sprite = spriteImg;
          enemy.sprite.onload = () => {
            console.log("Enemy sprite loaded:", enemyType.name);
          };

          // Load portal animation frames
          const globalPortalFrames = [
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/portal_0-J8UE17oPJVs5qWX30bY90Oi3SufDR3.png?GO24",
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/portal_1-QTIJknUjjLipXptJOFeXXOfUFm6kro.png?I8PB",
          ];

          // For Space Goblin, use specific frames
          if (enemyType.name === "Space Goblin") {
            const goblinPortalFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/portal_goblin_4-gQqt6cc67IvAXH7jGw5TQvJsC5uqnW.png?5rrx",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/portal_goblin_5-ii6EGkjJNVrhhLzh62ezCp1g8RjPxs.png?D9Pa",
            ];

            // Load Goblin-specific portal frames
            goblinPortalFrames.forEach((frameUrl) => {
              const frame = new Image();
              frame.src = frameUrl;
              frame.onload = () => {
                console.log("Space Goblin portal frame loaded");
              };
              enemy.portalFrames.push(frame);
            });

            // Ensure Space Goblin uses the idle animation frames after portal animation completes
            enemy.useAnimatedSprite = true;
            enemy.type = "Space Goblin"; // Set type property
          }
          // For Cyber Orc, copy the exact Space Goblin approach
          else if (enemyType.name === "Cyber Orc") {
            // Use custom portal frames for Cyber Orc too (copying Space Goblin pattern exactly)
            const orcPortalFrames = [
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/portal_goblin_4-gQqt6cc67IvAXH7jGw5TQvJsC5uqnW.png?5rrx",
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/portal_goblin_5-ii6EGkjJNVrhhLzh62ezCp1g8RjPxs.png?D9Pa",
            ];

            // Load Orc-specific portal frames
            orcPortalFrames.forEach((frameUrl) => {
              const frame = new Image();
              frame.src = frameUrl;
              frame.onload = () => {
                console.log("Cyber Orc portal frame loaded");
              };
              enemy.portalFrames.push(frame);
            });

            // Ensure Cyber Orc uses the idle animation frames after portal animation completes
            enemy.useAnimatedSprite = true;
            enemy.type = "Cyber Orc"; // Set type property
          } else {
            // For other enemies, repeat the global frames
            for (let i = 0; i < 2; i++) {
              const frame = new Image();
              frame.src = globalPortalFrames[i];
              frame.onload = () => {
                console.log("Global portal frame loaded");
              };
              enemy.portalFrames.push(frame);
            }
          }

          // CRITICAL: Final safety check to ensure enemy is not on a collision tile
          const collisionKey = `${enemy.x},${enemy.y}`;
          const hasCollision = DEBUG && DEBUG.collisionMap && DEBUG.collisionMap.get(collisionKey);

          if (hasCollision) {
            console.log(`⚠️ PREVENTED enemy spawn at (${enemy.x},${enemy.y}) - collision detected!`);
            // Try to find a safe spot nearby as a last-ditch effort
            let foundSafeSpot = false;
            const directions = [
              { x: 1, y: 0 },
              { x: -1, y: 0 },
              { x: 0, y: 1 },
              { x: 0, y: -1 },
            ];

            for (const dir of directions) {
              const newX = enemy.x + dir.x;
              const newY = enemy.y + dir.y;
              const newKey = `${newX},${newY}`;

              if (!DEBUG.collisionMap.get(newKey) && !EnemyManager.enemies.some((e) => e.x === newX && e.y === newY)) {
                enemy.x = newX;
                enemy.y = newY;
                foundSafeSpot = true;
                console.log(`🔧 Relocated enemy to safe spot (${newX},${newY})`);
                break;
              }
            }

            // Only add if it's not in collision, or we found a safe spot
            if (foundSafeSpot) {
              this.enemies.push(enemy);
              console.log(`✅ Enemy safely added to array: ${enemyType.name} at (${enemy.x},${enemy.y})`);
            } else {
              console.log(`❌ Enemy spawn canceled - no safe location found`);
              return; // Don't add the enemy
            }
          } else {
            // Original code - add normally if no collision
            this.enemies.push(enemy);
            console.log(`✅ Enemy added to array: ${enemyType.name} at (${enemy.x},${enemy.y})`);
          }
        },

        // Get enemy stats by type name
        getEnemyStatsByType(enemyType) {
          // Reference the available enemy types
          const enemyTypes = [
            {
              name: "Space Goblin",
              hp: 20,
              mp: 10,
              attack: 5,
              defense: 2,
              magic: 3,
              speed: 4,
              exp: 10,
              gold: 5,
            },
          ];

          // Find the enemy type by name
          const foundEnemy = enemyTypes.find((enemy) => enemy.name === enemyType);

          if (foundEnemy) {
            return foundEnemy;
          } else {
            // Return default stats if type not found
            console.warn(`[Enemy Manager] Enemy type not found: ${enemyType}, using default stats`);
            return {
              hp: 20,
              mp: 10,
              attack: 5,
              defense: 2,
              magic: 3,
              speed: 4,
              exp: 10,
              gold: 5,
            };
          }
        },

        // Track the current scene ID to detect scene changes
        currentSceneId: null,

        // Reset enemies when entering a new scene to ensure proper spawning with safety margins
        resetEnemiesForNewScene() {
          console.log("🔄 Resetting enemies for new scene");
          this.enemies = []; // Clear all existing enemies
          // Wait a short moment for collision map to be fully loaded
          setTimeout(() => {
            console.log("🔄 Collision map should be loaded now, spawning new enemies");
            this.repopulateEnemies();
          }, 250);
        },

        // Repopulate enemies up to the maximum allowed
        repopulateEnemies() {
          console.log(`🔄 Repopulating enemies (${this.enemies.length}/${this.maxEnemies})`);
          while (this.enemies.length < this.maxEnemies) {
            this.spawnEnemy();
          }
        },

        update(timestamp) {
          // Don't update enemies during battle
          if (GameStateManager.state.currentState === GAME_STATES.BATTLE) {
            console.log("In battle state - skipping enemy update");
            return;
          }

          // CRITICAL: Check if scene has changed and reset enemies if needed
          const currentScene = GameStateManager.state.currentScene;
          if (currentScene !== this.currentSceneId) {
            console.log(`🌍 Scene changed from ${this.currentSceneId} to ${currentScene}`);
            this.currentSceneId = currentScene;
            this.resetEnemiesForNewScene();
            return; // Skip the rest of the update until enemies are reset
          }

          // Update animation frames based on current time
          this.updateAnimations(timestamp || Date.now());

          // Spawn new enemies if needed
          if (this.enemies.length < this.maxEnemies) {
            console.log(`Current enemy count: ${this.enemies.length}/${this.maxEnemies} - spawning new enemies`);
            while (this.enemies.length < this.maxEnemies) {
              this.spawnEnemy();
            }
          }

          // Check for collisions with player
          const player = GameStateManager.state.player;
          if (!player) return;

          this.enemies.forEach((enemy) => {
            if (enemy.x === player.x && enemy.y === player.y) {
              console.log(`Starting battle with ${enemy.name} at (${enemy.x}, ${enemy.y})`);
              // Start battle first
              BattleSystem.startBattle(enemy);
              // Only remove enemy after battle is properly initialized
              setTimeout(() => {
                console.log(`Removing ${enemy.name} from enemies array after battle start`);
                this.enemies = this.enemies.filter((e) => e !== enemy);
                console.log(`Enemies remaining: ${this.enemies.length}`);
              }, 100);
            }
          });
        },
      };

      // Equipment Manager
      const EquipmentManager = {
        equip(player, item) {
          // Check requirements
          if (!this.meetsRequirements(player, item)) {
            UIManager.log(`You don't meet the requirements for ${item.name}`);
            return false;
          }

          // Check if item can be equipped in intended slot
          if (!this.canEquipInSlot(player, item)) {
            UIManager.log(`Cannot equip ${item.name} in that slot`);
            return false;
          }

          // Remove existing item in slot if any
          if (player.equipment[item.slot]) {
            this.unequip(player, item.slot);
          }

          // Equip new item
          player.equipment[item.slot] = item;

          // Apply item effects
          ItemEffectManager.applyItemEffects(item, player, true);

          // Update UI and stay on equipment tab
          updateEquipmentList(player);
          document.querySelector('[data-tab="equipment-tab"]').click();

          UIManager.log(`Equipped ${item.name}`);
          return true;
        },

        unequip(player, slot) {
          const item = player.equipment[slot];
          if (!item) return false;

          // Remove item effects
          ItemEffectManager.applyItemEffects(item, player, false);

          // Remove item from slot
          player.equipment[slot] = null;
          
          // Handle two-handed weapons - also clear OFF_HAND slot if unequipping a two-handed weapon from MAIN_HAND
          if (slot === 'MAIN_HAND' && (item.isTwoHanded || item.weaponType === WEAPON_TYPES.TWO_HANDED)) {
            // Clear off-hand slot too since it's a two-handed weapon
            player.equipment['OFF_HAND'] = null;
          }

          // Add to inventory
          addItemToInventory(item);

          // Update UI and stay on equipment tab
          updateEquipmentList(player);
          document.querySelector('[data-tab="equipment-tab"]').click();

          UIManager.log(`Unequipped ${item.name}`);
          return true;
        },

        meetsRequirements(player, item) {
          if (!item.requirements) return true;

          for (const [stat, value] of Object.entries(item.requirements)) {
            if (player.stats[stat] < value) return false;
          }
          return true;
        },

        canEquipInSlot(player, item) {
          // Check if item is a relic
          if (item.type === EQUIPMENT_TYPES.RELIC) {
            // Check if both relic slots are taken
            if (player.equipment[EQUIPMENT_SLOTS.RELIC_1] && player.equipment[EQUIPMENT_SLOTS.RELIC_2]) {
              return false;
            }
            // Assign to first empty relic slot
            item.slot = !player.equipment[EQUIPMENT_SLOTS.RELIC_1] ? EQUIPMENT_SLOTS.RELIC_1 : EQUIPMENT_SLOTS.RELIC_2;
            return true;
          }

          // For non-relics, check if slot is valid for item type
          return item.slot === item.slot;
        },
      };

      // Add this function after the createCharacter function
      function preloadAnimationFrames(player) {
        const directions = ["up", "down", "left", "right"];
        directions.forEach((direction) => {
          player.animationState.frameImages[direction] = [];
          player.animationState.directions[direction].forEach((url, index) => {
            const img = new Image();
            img.src = url;
            player.animationState.frameImages[direction][index] = img;
          });
        });

        // Preload idle frames
        player.animationState.frameImages.idle = [];
        player.animationState.idleFrames.forEach((url, index) => {
          const img = new Image();
          img.src = url;
          player.animationState.frameImages.idle[index] = img;
        });
      }

      // Relic System
      // Define RELIC_SYSTEM in global scope to ensure it's accessible everywhere
      window.RELIC_SYSTEM = {
        // Fury required for each relic level (starting at 200 and doubling each level)
        getFuryForNextLevel(currentLevel) {
          return Math.floor(200 * Math.pow(2, currentLevel - 1));
        },
        
        // Acquire the Glitch Stick relic
        acquireGlitchStick(player) {
          if (!player.relics) {
            this.initializeRelics(player);
          }
          
          // If player already has the Glitch Stick, don't give it again
          if (player.relics.glitchStick && player.relics.glitchStick.level > 0) {
            return false;
          }
          
          // Set Glitch Stick to level 1 but DO NOT apply bonuses yet (only apply on equip)
          player.relics.glitchStick.level = 1;
          player.relics.glitchStick.furyToNextLevel = this.getFuryForNextLevel(2);
          
          // Display message
          UIManager.log("You acquired the Glitch Stick! Your guide will now assist you on your journey.");
          UIManager.log("The Glitch Stick grants +1 to all stats when equipped and allows you to summon your guide for hints.");
          
          return true;
        },

        // Initialize relics for a new character
        initializeRelics(player) {
          player.relics = {
            glitchStick: {
              name: "Glitch Stick",
              level: 0,
              fury: 0,
              furyToNextLevel: this.getFuryForNextLevel(1),
              maxLevel: 6,
              description: "A mysterious artifact that seems to flicker between realities.",
              fightsSinceLastUse: 0, // For tracking level 6 ability cooldown
              abilities: [
                {
                  level: 1,
                  name: "Reality Guide",
                  description: "+1 to all stats, summon your guide to give you a hint about what to do next"
                },
                {
                  level: 2,
                  name: "Visit the Bodega",
                  description: "+2 to all stats, summon your guide who will let you access a shop to buy and sell consumable items"
                },
                {
                  level: 3,
                  name: "Get to Work",
                  description: "+3 to all stats, summon your guide who will let you access a shop to buy and sell consumable items, armor, and weapons"
                },
                {
                  level: 4,
                 name: "Bodega Superstore",
                  description: "+4 to all stats, summon your guide who will let you access a shop to buy and sell consumable items, armor, and weapons"
                },
                {
                  level: 5,
                  name: "Relic Fusion",
                  description: "+5 to all stats, summon your guide who will let you fuse relic pieces together to create new relics"
                },
                {
                  level: 6,
                  name: "Guide's Blessing",
                  description: "+6 to all stats, summon your guide to heal you and your party and restore your MP, this can only be used once every 20 fights"
                }
              ]
            }
          };
        },

        // Apply relic bonuses to player stats
        applyRelicBonuses(player, relicName) {
          const relic = player.relics[relicName];
          if (!relic) return;

          // Store whether this relic's bonuses have been applied already
          if (!player.appliedRelicBonuses) {
            player.appliedRelicBonuses = {};
          }
          
          // Only apply if not already applied
          if (!player.appliedRelicBonuses[relicName]) {
            // Apply stat bonuses
            player.stats.strength += relic.level;
            player.stats.dexterity += relic.level;
            player.stats.intelligence += relic.level;
            player.stats.vitality += relic.level;
            player.stats.fortune += relic.level;
            player.stats.charisma += relic.level;
            
            // Mark as applied
            player.appliedRelicBonuses[relicName] = true;
            
            console.log(`Applied relic bonuses for ${relicName}: +${relic.level} to all stats`);
            
            // Recalculate derived stats
            if (typeof recalculateDerivedStats === 'function') {
              recalculateDerivedStats(player);
              console.log('Recalculated derived stats after applying relic bonuses');
            }
            
            // Update UI to reflect stat changes
            if (typeof updateCharacterScreen === 'function') {
              updateCharacterScreen();
              console.log('Updated character screen after applying relic bonuses');
            }
          } else {
            console.log(`Relic bonuses for ${relicName} already applied, skipping`);
          }
        },
        
        // Add fury to a specific relic and check for level ups
        addFury(player, relicKey, amount) {
          if (!player.relics || !player.relics[relicKey]) {
            console.warn(`Relic ${relicKey} not found for player`);
            return false;
          }

          const relic = player.relics[relicKey];
          
          // Update total fury for player
          player.fury = (player.fury || 0) + amount;

          // Don't add fury if relic is at max level
          if (relic.level >= relic.maxLevel) {
            return false;
          }

          // Add fury to relic
          relic.fury = (relic.fury || 0) + amount;

          // Check for level up
          if (relic.fury >= relic.furyToNextLevel) {
            this.levelUpRelic(player, relicKey);
            return true;
          }

          return false;
        },

        // Level up a relic
        levelUpRelic(player, relicKey) {
          const relic = player.relics[relicKey];
          
          // Can't level up if at max level
          if (relic.level >= relic.maxLevel) {
            return false;
          }
          
          // Subtract fury needed for this level
          relic.fury -= relic.furyToNextLevel;
          
          // Store old level for stat difference calculation
          const oldLevel = relic.level;
          
          // Level up relic
          relic.level++;
          
          // Calculate fury needed for next level (if not at max)
          if (relic.level < relic.maxLevel) {
            relic.furyToNextLevel = this.getFuryForNextLevel(relic.level + 1);
          }
          
          // If this relic is equipped (has been applied), update stats for the difference
          if (player.appliedRelicBonuses && player.appliedRelicBonuses[relicKey]) {
            // Apply only the stat difference from level up
            const levelDifference = relic.level - oldLevel;
            player.stats.strength += levelDifference;
            player.stats.dexterity += levelDifference;
            player.stats.intelligence += levelDifference;
            player.stats.vitality += levelDifference;
            player.stats.fortune += levelDifference;
            player.stats.charisma += levelDifference;
            
            console.log(`Updated relic bonuses for ${relicKey}: +${levelDifference} to all stats due to level up`);
            
            // Recalculate derived stats
            if (typeof recalculateDerivedStats === 'function') {
              recalculateDerivedStats(player);
            }
          }
          
          // Get the current ability
          const currentAbility = relic.abilities.find(a => a.level === relic.level);
          
          // Log the level up
          UIManager.log(`${relic.name} leveled up to Level ${relic.level}!`);
          UIManager.log(`New ability unlocked: ${currentAbility.name} - ${currentAbility.description}`);
          
          // Update UI to reflect stat changes if needed
          if (typeof updateCharacterScreen === 'function') {
            updateCharacterScreen();
          }
          
          return true;
        },

        // Use a relic's special ability
        useRelicAbility(player, relicKey) {
          if (!player.relics || !player.relics[relicKey]) {
            UIManager.log(`You don't have the ${relicKey} relic!`);
            return false;
          }
          
          const relic = player.relics[relicKey];
          
          // Must be activated (level > 0) to use
          if (relic.level === 0) {
            UIManager.log(`The ${relic.name} is not yet activated.`);
            return false;
          }
          
          // For level 5 ability, check cooldown
          if (relic.level === 5) {
            // Check if we've had 20 fights since last use
            if (relic.fightsSinceLastUse < 20) {
              UIManager.log(`The ${relic.name}'s healing ability can only be used once every 20 fights. ${20 - relic.fightsSinceLastUse} fights remaining.`);
              return false;
            }
          }
          
          // Handle different abilities based on relic and level
          if (relicKey === "glitchStick") {
            switch (relic.level) {
              case 1: // Hint about what to do next
                this.showHint(player);
                break;
              case 2: // Basic shop
                this.openBasicShop(player);
                break;
              case 3: // Advanced shop
                this.openAdvancedShop(player);
                break;
              case 4: // Relic fusion
                this.openRelicFusion(player);
                break;
              case 5: // Heal party and restore MP
                this.healParty(player);
                // Reset cooldown counter
                relic.fightsSinceLastUse = 0;
                break;
            }
            
            return true;
          }
          
          return false;
        },
        
        // Implementations of relic abilities
        showHint(player) {
          // This would be implemented to give quest or progress hints
          UIManager.log("Your guide appears and whispers guidance about your next steps...");
          // Actual implementation would depend on game state, quests, etc.
        },
        
        openBasicShop(player) {
          UIManager.log("Your guide opens a portal to a small shop with consumable items.");
          // Implementation would open a shop UI with consumables only
        },
        
        openAdvancedShop(player) {  
          UIManager.log("Your guide opens a portal to a large shop with various equipment and items.");
          // Implementation would open a shop UI with consumables, armor, and weapons
        },
        
        openRelicFusion(player) {
          UIManager.log("Your guide shows you how to combine relic fragments into new powerful artifacts.");
          // Implementation would open a fusion UI
        },
        
        healParty(player) {
          // Fully restore HP and MP
          player.hp = player.derivedStats.maxHp;
          player.mp = player.derivedStats.maxMp;
          
          // If party members exist, heal them too
          if (player.party) {
            player.party.forEach(member => {
              member.hp = member.derivedStats.maxHp;
              member.mp = member.derivedStats.maxMp;
            });
          }
          
          UIManager.log("Your guide fills you with renewed energy, fully restoring your health and magic!");
        },
        
        // Update fight counter for level 5 ability cooldown
        incrementFightCounter(player) {
          if (!player.relics) return;
          
          // Update fight counter for all relics
          Object.keys(player.relics).forEach(relicKey => {
            const relic = player.relics[relicKey];
            if (relic.level === 5) {
              relic.fightsSinceLastUse = (relic.fightsSinceLastUse || 0) + 1;
            }
          });
        },
        
        // Get relic display info for UI
        getRelicDisplayInfo(player, relicKey) {
          if (!player.relics || !player.relics[relicKey]) {
            return null;
          }
          
          const relic = player.relics[relicKey];
          
          // If relic is not yet activated, provide basic info
          if (relic.level === 0) {
            return {
              name: relic.name,
              level: "Not Activated",
              description: relic.description,
              fury: 0,
              furyToNextLevel: relic.furyToNextLevel,
              furyPercent: 0,
              ability: "None"
            };
          }
          
          // Get current ability
          const currentAbility = relic.abilities.find(a => a.level === relic.level);
          
          // Fury percentage calculation
          let furyPercent = 0;
          if (relic.level < relic.maxLevel) {
            furyPercent = Math.min(100, Math.floor((relic.fury / relic.furyToNextLevel) * 100));
          } else {
            furyPercent = 100; // Max level
          }
          
          return {
            name: relic.name,
            level: relic.level,
            description: relic.description,
            fury: relic.fury,
            furyToNextLevel: relic.level < relic.maxLevel ? relic.furyToNextLevel : "MAX",
            furyPercent: furyPercent,
            ability: currentAbility ? currentAbility.name : "None",
            abilityDescription: currentAbility ? currentAbility.description : "",
            maxLevel: relic.maxLevel,
            isMaxLevel: relic.level >= relic.maxLevel
          };
        },
      };

      // Leveling System
      const LEVELING_SYSTEM = {
        // XP required for next level (exponential formula)
        getXPForNextLevel(currentLevel) {
          return Math.floor(100 * Math.pow(1.5, currentLevel - 1));
        },

        // Stat points gained per level
        getStatPointsPerLevel(level) {
          return 3; // Base stat points per level
        },

        // Class-specific level unlocks
        CLASS_UNLOCKS: {
          MOM_FRIEND: {
            skills: [
              { level: 1, name: "Heal", description: "Restores HP to target ally", mpCost: 20, effect: "heal" },
              {
                level: 5,
                name: "Holy Light",
                description: "Deals holy damage to undead",
                mpCost: 25,
                effect: "damage",
              },
              {
                level: 10,
                name: "Divine Shield",
                description: "Protects ally from damage",
                mpCost: 30,
                effect: "buff",
              },
            ],
            passives: [
              { level: 3, name: "Divine Blessing", description: "+10% healing effectiveness" },
              { level: 7, name: "Holy Aura", description: "+5 MP regeneration per second" },
              { level: 15, name: "Divine Protection", description: "Reduces all incoming damage by 10%" },
            ],
          },
        },

        // Initialize leveling for a new character
        initializeCharacter(player) {
          player.level = 1;
          player.xp = 0;
          player.xpToNextLevel = this.getXPForNextLevel(1);
          player.statPoints = 0;
          // Don't reset skills array if it already exists
          if (!player.skills) {
            player.skills = [];
          }
          if (!player.passives) {
            player.passives = [];
          }

          // Set initial base stats
          player.baseStats = { ...player.stats };
          player.statsLocked = false;

          // Initialize derived stats
          player.derivedStats = {
            maxHp: player.stats.vitality * 20,
            maxMp: player.stats.intelligence * 15,
            defense: Math.floor(player.stats.vitality * 0.2),
            magicDefense: Math.floor(player.stats.intelligence / 5),
            blockChance: player.stats.dexterity * 0.2,
          };

          // Set initial HP and MP to max
          player.hp = player.derivedStats.maxHp;
          player.mp = player.derivedStats.maxMp;

          this.checkLevelUnlocks(player);
        },

        // Add XP and handle level ups
        addXP(player, amount) {
          // Calculate XP bonus based on player's highest tier
          const highestTier = Math.max(
            getTier(player.stats, { name: "DICE_PROGRESSION", stat: "strength" }),
            getTier(player.stats, { name: "DICE_PROGRESSION", stat: "intelligence" }),
          );

          const tierBonus = {
            TIER_1: 1.0,
            TIER_2: 1.1,
            TIER_3: 1.2,
            TIER_4: 1.3,
            TIER_5: 1.4,
          };

          const finalXP = Math.floor(amount * tierBonus[highestTier]);
          player.xp += finalXP;

          while (player.xp >= player.xpToNextLevel) {
            this.levelUp(player);
          }

          UIManager.update();
          UIManager.updateCharacterScreen();
        },

        // Handle level up
        levelUp(player) {
          player.level++;
          player.xp -= player.xpToNextLevel;
          player.xpToNextLevel = this.getXPForNextLevel(player.level);
          player.statPoints += this.getStatPointsPerLevel(player.level);

          // Unlock stats for allocation
          player.statsLocked = false;

          // Check for new unlocks
          this.checkLevelUnlocks(player);

          // Display level up message
          const message = `Level Up! You are now level ${player.level}! You gained ${this.getStatPointsPerLevel(player.level)} stat points!`;
          UIManager.log(message);

          // Update UI
          UIManager.update();
          UIManager.updateCharacterScreen();
        },

        // Check for new unlocks at current level
        checkLevelUnlocks(player) {
          const classData = CHARACTER_CLASSES[player.class];
          if (!classData || !classData.skills) return;

          // Check skill unlocks
          Object.values(classData.skills).forEach((skill) => {
            if (player.level >= skill.level && !player.skills.some((s) => s.name === skill.name)) {
              player.skills.push({ ...skill });
              UIManager.log(`Learned new skill: ${skill.name}!`);

              // If it's a passive skill, also add it to passives
              if (skill.type === "passive") {
                player.passives.push({ ...skill });
              }
            }
          });
        },

        // Allocate stat point
        allocateStatPoint(player, stat, amount) {
          // If removing a point, make sure we're not going below base stats
          if (amount < 0) {
            const baseStat = player.baseStats[stat];
            if (player.stats[stat] <= baseStat) return false;
          }

          // If adding a point, make sure we have points to spend
          if (amount > 0 && player.statPoints <= 0) return false;

          switch (stat) {
            case "strength":
              player.stats.strength += amount;
              break;
            case "dexterity":
              player.stats.dexterity += amount;
              break;
            case "intelligence":
              player.stats.intelligence += amount;
              break;
            case "vitality":
              player.stats.vitality += amount;
              break;
            case "fortune":
              player.stats.fortune += amount;
              break;
            case "charisma":
              player.stats.charisma += amount;
              break;
            default:
              return false;
          }

          player.statPoints -= amount;

          // Initialize or update derived stats
          if (!player.derivedStats) {
            player.derivedStats = {
              maxHp: player.stats.vitality * 20,
              maxMp: player.stats.intelligence * 15,
              defense: Math.floor(player.stats.vitality * 0.2),
              magicDefense: Math.floor(player.stats.intelligence / 5),
              blockChance: player.stats.dexterity * 0.2,
            };
          } else {
            player.derivedStats.maxHp = player.stats.vitality * 20;
            player.derivedStats.maxMp = player.stats.intelligence * 15;
            player.derivedStats.defense = Math.floor(player.stats.vitality * 0.2);
            player.derivedStats.magicDefense = Math.floor(player.stats.intelligence / 5);
            player.derivedStats.blockChance = player.stats.dexterity * 0.2;
          }

          // Ensure HP/MP don't exceed new maximums
          player.hp = Math.min(player.hp, player.derivedStats.maxHp);
          player.mp = Math.min(player.mp, player.derivedStats.maxMp);

          // Update all relevant UI elements
          UIManager.updateCharacterScreen();
          UIManager.update(); // Updates top nav
          return true;
        },

        calculateDerivedStats: function (stats) {
          return {
            maxHp: Math.floor(50 + stats.vitality * 2),
            maxMp: Math.floor(20 + stats.intelligence * 1.5),
            attack: Math.floor(stats.strength * 0.5),
            magicAttack: Math.floor(stats.intelligence * 1.5),
            magicDefense: Math.floor(stats.intelligence * 0.01),
            speed: Math.floor(5 + stats.dexterity * 0.2),
            blockChance: Math.min(0.2, stats.dexterity * 0.01),
          };
        },

        updatePlayerStats: function (target) {
          // Get equipped items stats
          const equippedStats = this.calculateEquippedStats(target);

          // Calculate base stats
          const baseDefense = Math.floor(target.stats.vitality * 0.5); // Standardized to 0.5 per vitality
          const baseAttack = Math.floor(target.stats.strength * 0.5);

          // Calculate dodge/block from dexterity (capped at 20%)
          const baseDodgeBlock = Math.min(20, Math.floor(target.stats.dexterity * 2));

          // Update derived stats
          target.derivedStats = {
            maxHp: Math.floor(target.stats.vitality * 20) + (equippedStats.maxHp || 0),
            maxMp: Math.floor(target.stats.intelligence * 10) + (equippedStats.maxMp || 0),
            attack: baseAttack + (equippedStats.attack || 0),
            magicAttack: Math.floor(target.stats.intelligence * 2) + (equippedStats.magicAttack || 0),
            defense: baseDefense + (equippedStats.defense || 0),
            magicDefense: Math.floor(target.stats.intelligence * 1.5) + (equippedStats.magicDefense || 0),
            speed: target.stats.dexterity + (equippedStats.speed || 0),
            blockChance: Math.min(0.3, baseDodgeBlock + (equippedStats.blockChance || 0)),
            criticalChance: Math.min(20, Math.floor(target.stats.dexterity * 2)) + (equippedStats.criticalChance || 0),
            dodgeChance: Math.min(20, baseDodgeBlock + (equippedStats.dodgeChance || 0)),
            parryChance: Math.min(20, Math.floor(target.stats.dexterity * 2)) + (equippedStats.parryChance || 0),
          };
        },

        updateCharacterStats: function (player) {
          // Update derived stats
          player.derivedStats = {
            maxHp: Math.floor(player.stats.vitality * 20),
            maxMp: Math.floor(player.stats.intelligence * 10),
            attack: Math.floor(player.stats.strength * 0.5),
            magicAttack: Math.floor(player.stats.intelligence * 2),
            defense: Math.floor(player.stats.vitality * 0.5),
            magicDefense: Math.floor(player.stats.intelligence * 1.5),
            speed: player.stats.dexterity,
            blockChance: Math.min(0.3, Math.floor(player.stats.dexterity * 0.01)),
            criticalChance: Math.min(20, Math.floor(player.stats.dexterity * 2)),
            dodgeChance: Math.min(20, Math.floor(player.stats.dexterity * 2)),
            parryChance: Math.min(20, Math.floor(player.stats.dexterity * 2)),
          };
        },

        calculateEquippedStats(target) {
          if (!target || !target.equipment) return {};

          const stats = {
            hp: 0,
            mp: 0,
            defense: 0,
            magicDefense: 0,
            blockChance: 0,
          };

          // Sum up stats from all equipped items
          for (const [slot, item] of Object.entries(target.equipment)) {
            if (!item || !item.stats) continue;

            for (const [stat, value] of Object.entries(item.stats)) {
              if (stats[stat] !== undefined) {
                stats[stat] += value;
              }
            }
          }

          return stats;
        },

        getEquippedStats(target) {
          if (!target || !target.equipment) return {};

          const stats = {
            hp: 0,
            mp: 0,
            defense: 0,
            magicDefense: 0,
            blockChance: 0,
          };

          // Sum up stats from all equipped items
          for (const [slot, item] of Object.entries(target.equipment)) {
            if (!item || !item.stats) continue;

            for (const [stat, value] of Object.entries(item.stats)) {
              if (stats[stat] !== undefined) {
                stats[stat] += value;
              }
            }
          }

          return stats;
        },

        calculateDamage(attacker, defender, isMagic = false) {
          if (!attacker || !defender) return { damage: 0, wasBlocked: false };

          // Get base stats
          const attackStat = isMagic ? attacker.intelligence : attacker.strength;

          // Ensure defender has derivedStats
          if (!defender.derivedStats) {
            defender.derivedStats = {
              defense: 0,
              magicDefense: 0,
              blockChance: 0,
            };
          }

          const defenseStat = isMagic ? defender.derivedStats.magicDefense : defender.derivedStats.defense;

          // Calculate base damage
          const baseDamage = Math.max(1, attackStat - defenseStat);
          const finalDamage = Math.floor(baseDamage * (0.8 + Math.random() * 0.4));

          // Check for block if physical damage
          if (!isMagic && defender.derivedStats.blockChance > 0) {
            if (Math.random() < defender.derivedStats.blockChance) {
              return {
                damage: Math.floor(finalDamage * 0.5),
                wasBlocked: true,
              };
            }
          }

          return {
            damage: finalDamage,
            wasBlocked: false,
          };
        },

        getEnemyStats: function (enemyType, playerLevel) {
          // Get player's base stats for scaling
          const playerStats = player.derivedStats || {
            attack: 5,
            defense: 2,
            maxHp: 50,
          };

          // Base stats for each enemy type
          const baseStats = {
            GOBLIN: {
              hp: Math.floor(playerStats.maxHp * (0.8 + Math.random() * 0.4)), // 80-120% of player HP
              mp: 10,
              attack: Math.floor(playerStats.attack * (1.0 + Math.random() * 0.2)), // 100-120% of player attack
              defense: Math.floor(playerStats.defense * (0.8 + Math.random() * 0.4)), // 80-120% of player defense
              speed: 3,
              exp: Math.floor(playerLevel * 10 * (0.8 + Math.random() * 0.4)), // 8-12 exp per level
              gold: Math.floor(playerLevel * 5 * (0.8 + Math.random() * 0.4)), // 4-6 gold per level
            },
            TROLL: {
              hp: Math.floor(playerStats.maxHp * (1.2 + Math.random() * 0.3)), // 120-150% of player HP
              mp: 15,
              attack: Math.floor(playerStats.attack * (1.2 + Math.random() * 0.3)), // 120-150% of player attack
              defense: Math.floor(playerStats.defense * (1.2 + Math.random() * 0.3)), // 120-150% of player defense
              speed: 2,
              exp: Math.floor(playerLevel * 15 * (1.2 + Math.random() * 0.3)), // 18-22.5 exp per level
              gold: Math.floor(playerLevel * 8 * (1.2 + Math.random() * 0.3)), // 9.6-12 gold per level
            },
            OGRE: {
              hp: Math.floor(playerStats.maxHp * (1.5 + Math.random() * 0.5)), // 150-200% of player HP
              mp: 20,
              attack: Math.floor(playerStats.attack * (1.5 + Math.random() * 0.5)), // 150-200% of player attack
              defense: Math.floor(playerStats.defense * (1.5 + Math.random() * 0.5)), // 150-200% of player defense
              speed: 1,
              exp: Math.floor(playerLevel * 20 * (1.5 + Math.random() * 0.5)), // 30-40 exp per level
              gold: Math.floor(playerLevel * 12 * (1.5 + Math.random() * 0.5)), // 18-24 gold per level
            },
          };

          // Scale stats with level
          const levelMultiplier = 1 + (playerLevel - 1) * 0.1;
          const stats = baseStats[enemyType];

          return {
            hp: Math.floor(stats.hp * levelMultiplier),
            mp: Math.floor(stats.mp * levelMultiplier),
            attack: Math.floor(stats.attack * levelMultiplier),
            defense: Math.floor(stats.defense * levelMultiplier),
            speed: stats.speed,
            exp: stats.exp, // Exp already includes level scaling
            gold: stats.gold, // Gold already includes level scaling
          };
        },
      };

      // Global function for confirming stat allocation
      function confirmStatAllocation() {
        const player = GameStateManager.state.player;
        if (player.statPoints > 0) {
          UIManager.log("You still have stat points to allocate!");
          return;
        }

        // Set the base stats to current values
        if (!player.baseStats) {
          player.baseStats = {};
        }
        Object.keys(player.stats).forEach((stat) => {
          player.baseStats[stat] = player.stats[stat];
        });

        // Lock in the stats
        player.statsLocked = true;
        UIManager.log("Stat allocation confirmed!");
        UIManager.updateCharacterScreen();
      }

      // Helper function to properly capitalize slot names
      function formatSlotName(slot) {
        return slot
          .split("_")
          .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
          .join(" ");
      }

      function showEquipmentInfo(slot, item) {
        const tooltip = document.getElementById("equipmentTooltip");
        if (!tooltip) return;

        if (!item) {
          tooltip.innerHTML = `
                    <div class="title">${formatSlotName(slot)}</div>
                    <div class="description">Empty slot</div>
                `;
        } else {
          tooltip.innerHTML = `
                    <div class="title">${item.name}</div>
                    ${
                      item.requirements
                        ? `
                        <div class="requirements">Required: ${Object.entries(item.requirements)
                          .map(([stat, value]) => `${stat.charAt(0).toUpperCase() + stat.slice(1)} ${value}`)
                          .join(", ")}</div>
                    `
                        : ""
                    }
                    ${
                      item.stats
                        ? `
                        <div class="stats">
                            ${Object.entries(item.stats)
                              .map(([stat, value]) => {
                                if (stat === "hitChance") {
                                  return `Hit Chance +${Math.round(value * 100)}%`;
                                } else if (stat === "damage") {
                                  return `Damage +${value}`;
                                } else if (stat === "defense") {
                                  return `Defense +${value}`;
                                } else if (stat === "blockChance") {
                                  return `Block Chance +${Math.round(value * 100)}%`;
                                } else if (stat === "evasion") {
                                  return `Evasion +${Math.round(value * 100)}%`;
                                } else if (stat === "magicDamage") {
                                  return `Magic Damage +${value}`;
                                } else if (stat === "magicDefense") {
                                  return `Magic Defense +${value}`;
                                }
                                return `${stat.charAt(0).toUpperCase() + stat.slice(1)} +${value}`;
                              })
                              .join(", ")}
                        </div>
                    `
                        : ""
                    }
                    <div class="description">Click to unequip</div>
                `;
        }
      }

      function hideEquipmentInfo() {
        const tooltip = document.getElementById("equipmentTooltip");
        if (tooltip) {
          tooltip.innerHTML = `
                    <div class="title">Equipment Information</div>
                    <div class="description">Hover over equipment to see details</div>
                `;
        }
      }

      // Generate 4-character acronym for item names
      function getItemAcronym(itemName) {
        const acronyms = {
          "Rubber Dumbells": "RSWD",
          "Wooden Staff": "WSTF",
          "Wooden Shield": "WSLD",
          "Leather Cap": "LCAP",
          "Cloth Robe": "CRBE",
          "Ancient Crystal": "ACRL",
          "Warrior's Sigil": "WSGL",
        };

        // Return predefined acronym if exists
        if (acronyms[itemName]) {
          return acronyms[itemName];
        }

        // Generate acronym for unknown items
        const words = itemName.split(" ");
        if (words.length === 1) {
          // Single word - take first 4 letters
          return itemName.substring(0, 4).toUpperCase();
        } else {
          // Multiple words - take parts of each word
          return words
            .map((word) => word[0])
            .join("")
            .toUpperCase()
            .padEnd(4, "X");
        }
      }

      // Update equipment display to use acronyms
      function generateEquipmentItemHTML(slot, item) {
        return `
                <div class="equipment-item" 
                    onmouseover="showEquipmentInfo('${slot}', ${item ? JSON.stringify(item).replace(/"/g, "&quot;") : null})"
                    onmouseout="hideEquipmentInfo()"
                    onclick="${item ? `EquipmentManager.unequip(GameStateManager.state.player, '${slot}')` : ""}"
                >
                    <span class="slot-label">${formatSlotName(slot)}</span>
                    ${
                      item
                        ? `
                        <div class="item">
                            <span class="item-name" title="${item.name}">${getItemAcronym(item.name)}</span>
                        </div>
                    `
                        : '<span class="empty-slot">Empty</span>'
                    }
                </div>
            `;
      }

      // Update equipment list generation
      function updateEquipmentList(player) {
        const equipmentList = document.querySelector(".equipment-list");
        if (!equipmentList) return;
        
        // Use fixed array of slots to ensure all slots are displayed
        const allSlots = ['main_hand', 'off_hand', 'head', 'body', 'legs', 'feet', 'relic_1', 'relic_2'];
        
        equipmentList.innerHTML = allSlots
          .map(slot => {
            // Find the item regardless of case by checking all equipment slots
            let item = player.equipment[slot];
            
            // If no exact match, try case-insensitive match
            if (!item && player.equipment) {
                const upperSlot = slot.toUpperCase();
                for (const [equipSlot, equipItem] of Object.entries(player.equipment)) {
                    if (equipSlot.toUpperCase() === upperSlot) {
                        item = equipItem;
                        break;
                    }
                }
            }
            
            return generateEquipmentItemHTML(slot, item);
          })
          .join("");
      }

      // Item Effect Manager
      const ItemEffectManager = {
        applyItemEffects(item, target, isEquipping) {
          if (!item || !target) return;

          // Handle stat boosts
          if (item.effectType === "STAT_BOOST") {
            const multiplier = isEquipping ? 1 : -1;
            if (item.effectValue) {
              for (const [stat, value] of Object.entries(item.effectValue)) {
                target[stat] = (target[stat] || 0) + value * multiplier;
              }
            }
          }

          // Handle skill unlocks
          if (item.effectType === "SKILL_UNLOCK" && isEquipping) {
            if (!target.skills) target.skills = [];
            if (!target.skills.includes(item.effectValue)) {
              target.skills.push(item.effectValue);
            }
          }

          // Handle passive effects
          if (item.effectType === "PASSIVE_EFFECT" && isEquipping) {
            if (!target.passiveEffects) target.passiveEffects = [];
            if (!target.passiveEffects.includes(item.effectValue)) {
              target.passiveEffects.push(item.effectValue);
            }
          }

          // Update derived stats
          this.updateDerivedStats(target);
        },

        updateDerivedStats(target) {
          // Calculate base HP and MP from stats
          const baseHp = target.stats.vitality * 20;
          const baseMp = target.stats.intelligence * 15;

          // Get additional stats from equipment
          const equippedStats = this.calculateEquippedStats(target);

          // Update derived stats
          target.derivedStats = {
            maxHp: baseHp + (equippedStats.hp || 0),
            maxMp: baseMp + (equippedStats.mp || 0),
            defense: Math.floor(target.stats.vitality * 0.5) + (equippedStats.defense || 0),
            magicDefense: Math.floor(target.stats.intelligence / 2) + (equippedStats.magicDefense || 0),
            blockChance: target.stats.dexterity * 0.5 + (equippedStats.blockChance || 0),
          };

          // Sync with top-level maxHp and maxMp
          target.maxHp = target.derivedStats.maxHp;
          target.maxMp = target.derivedStats.maxMp;

          // Ensure HP/MP don't exceed new maximums
          target.hp = Math.min(target.hp, target.derivedStats.maxHp);
          target.mp = Math.min(target.mp, target.derivedStats.maxMp);

          // Update UI
        },

        calculateEquippedStats(target) {
          if (!target || !target.equipment) return {};

          const stats = {
            hp: 0,
            mp: 0,
            defense: 0,
            magicDefense: 0,
            blockChance: 0,
          };

          // Sum up stats from all equipped items
          for (const [slot, item] of Object.entries(target.equipment)) {
            if (!item || !item.stats) continue;

            for (const [stat, value] of Object.entries(item.stats)) {
              if (stats[stat] !== undefined) {
                stats[stat] += value;
              }
            }
          }

          return stats;
        },

        getEquippedStats(target) {
          if (!target || !target.equipment) return {};

          const stats = {
            hp: 0,
            mp: 0,
            defense: 0,
            magicDefense: 0,
            blockChance: 0,
          };

          // Sum up stats from all equipped items
          for (const [slot, item] of Object.entries(target.equipment)) {
            if (!item || !item.stats) continue;

            for (const [stat, value] of Object.entries(item.stats)) {
              if (stats[stat] !== undefined) {
                stats[stat] += value;
              }
            }
          }

          return stats;
        },

        calculateDamage(attacker, defender, isMagic = false) {
          if (!attacker || !defender) return { damage: 0, wasBlocked: false };

          // Get base stats
          const attackStat = isMagic ? attacker.intelligence : attacker.strength;

          // Ensure defender has derivedStats
          if (!defender.derivedStats) {
            defender.derivedStats = {
              defense: 0,
              magicDefense: 0,
              blockChance: 0,
            };
          }

          const defenseStat = isMagic ? defender.derivedStats.magicDefense : defender.derivedStats.defense;

          // Calculate base damage
          const baseDamage = Math.max(1, attackStat - defenseStat);
          const finalDamage = Math.floor(baseDamage * (0.8 + Math.random() * 0.4));

          // Check for block if physical damage
          if (!isMagic && defender.derivedStats.blockChance > 0) {
            if (Math.random() < defender.derivedStats.blockChance) {
              return {
                damage: Math.floor(finalDamage * 0.5),
                wasBlocked: true,
              };
            }
          }

          return {
            damage: finalDamage,
            wasBlocked: false,
          };
        },
      };

      function renderEnemies() {
        // Use EnemyManager.enemies instead of global enemies
        if (!EnemyManager || !EnemyManager.enemies || !EnemyManager.enemies.length) {
          return; // No enemies to render
        }

        // If we're in battle, skip rendering enemies in overworld
        if (GameStateManager.state.currentState === GAME_STATES.BATTLE) {
          return;
        }

        EnemyManager.enemies.forEach((enemy) => {
          // Debug log all enemy data to troubleshoot
          console.log(
            `Rendering enemy: name=${enemy.name}, type=${enemy.type}, animated=${enemy.useAnimatedSprite}, portal=${enemy.portalAnimationComplete}`,
          );

          // Standard animation for all enemy types
          if (!enemy.portalAnimationComplete) {
            // Draw portal animation
            const frameIndex = Math.floor(enemy.portalFrameIndex);
            if (frameIndex < enemy.portalFrames.length && enemy.portalFrames[frameIndex].complete) {
              ctx.drawImage(enemy.portalFrames[frameIndex], enemy.x - 32, enemy.y - 32, 64, 64);

              // Update portal animation
              enemy.portalFrameIndex += enemy.portalAnimationSpeed;
              if (enemy.portalFrameIndex >= enemy.portalFrames.length) {
                enemy.portalAnimationComplete = true;
                console.log(
                  "Portal animation complete for:",
                  enemy.name,
                  "original type:",
                  enemy.originalType || enemy.type,
                );

                // CRITICAL FIX: PRESERVE ENEMY TYPE EXPLICITLY (this is a failsafe)
                if (enemy.originalName === "Cyber Orc" || enemy.originalType === "Cyber Orc") {
                  enemy.name = "Cyber Orc";
                  enemy.type = "Cyber Orc";
                  console.log("RESTORED CYBER ORC type after portal animation");
                }

                // Force animated sprites for key enemy types - ALWAYS set this flag
                if (
                  enemy.name === "Space Goblin" ||
                  enemy.name === "Cyber Orc" ||
                  enemy.type === "Cyber Orc" ||
                  enemy.originalName === "Cyber Orc" ||
                  enemy.originalType === "Cyber Orc"
                ) {
                  enemy.useAnimatedSprite = true;
                  console.log(`Set useAnimatedSprite=true for ${enemy.name}`);
                }
              }
            }
          } else {
            // Add direct debug for comparing original vs current type
            console.log(
              `Enemy type check - current: ${enemy.name}/${enemy.type}, original: ${enemy.originalName || "none"}/${enemy.originalType || "none"}`,
            );

            // CRITICAL FIX: Test original type as well
            const isCyberOrc =
              enemy.name === "Cyber Orc" ||
              enemy.type === "Cyber Orc" ||
              enemy.originalName === "Cyber Orc" ||
              enemy.originalType === "Cyber Orc";

            // Check for Cyber Orc by name OR type OR original type
            if (isCyberOrc) {
              console.log("DIRECT RENDERING CYBER ORC");
              // Get current frame for Cyber Orc
              const frameIndex = EnemyManager.currentAnimationFrame % 4; // Only 4 frames

              // Debug the Cyber Orc frame data
              console.log(
                `Cyber Orc animation data: frame=${frameIndex}, frames=${EnemyManager.cyberOrcIdleFrameImages ? EnemyManager.cyberOrcIdleFrameImages.length : "none"}, loaded=${EnemyManager.cyberOrcIdleFramesLoaded}`,
              );

              // CRITICAL FIX: Force Cyber Orc name/type regardless
              enemy.name = "Cyber Orc";
              enemy.type = "Cyber Orc";
              enemy.useAnimatedSprite = true;

              // Try to use animation frame
              if (EnemyManager.cyberOrcIdleFrameImages && EnemyManager.cyberOrcIdleFrameImages.length > 0) {
                const frameToUse = EnemyManager.cyberOrcIdleFrameImages[frameIndex];
                if (frameToUse && frameToUse.complete) {
                  console.log(`Drew Cyber Orc frame ${frameIndex} at (${enemy.x}, ${enemy.y})`);
                  ctx.drawImage(frameToUse, enemy.x * GRID_SIZE, enemy.y * GRID_SIZE, enemy.width, enemy.height);
                  return; // Skip other rendering for this enemy
                } else {
                  // Fallback to static sprite
                  console.log(`Cyber Orc frame ${frameIndex} not ready, using static`);
                  ctx.drawImage(enemy.sprite, enemy.x * GRID_SIZE, enemy.y * GRID_SIZE, enemy.width, enemy.height);
                  return; // Skip other rendering for this enemy
                }
              } else {
                // No frames available, use static
                console.log("No Cyber Orc frames available, using static image");
                ctx.drawImage(enemy.sprite, enemy.x * GRID_SIZE, enemy.y * GRID_SIZE, enemy.width, enemy.height);
                return; // Skip other rendering for this enemy
              }
            }
            // Handle animated enemies after portal animation completes
            else if (enemy.useAnimatedSprite) {
              // First check for Cyber Orcs (we need to prioritize this check before Space Goblin)
              if (enemy.name === "Cyber Orc" || enemy.type === "Cyber Orc") {
                const frameIndex = EnemyManager.currentAnimationFrame % 4;
                if (EnemyManager.cyberOrcIdleFrameImages && EnemyManager.cyberOrcIdleFrameImages.length > 0) {
                  const frameToUse = EnemyManager.cyberOrcIdleFrameImages[frameIndex];
                  if (frameToUse && frameToUse.complete) {
                    ctx.drawImage(frameToUse, enemy.x * GRID_SIZE, enemy.y * GRID_SIZE, enemy.width, enemy.height);
                  } else {
                    ctx.drawImage(enemy.sprite, enemy.x * GRID_SIZE, enemy.y * GRID_SIZE, enemy.width, enemy.height);
                  }
                } else {
                  ctx.drawImage(enemy.sprite, enemy.x * GRID_SIZE, enemy.y * GRID_SIZE, enemy.width, enemy.height);
                }
                return; // Skip other rendering for this enemy
              }
              // Then check for Space Goblin
              else if (enemy.name === "Space Goblin" || enemy.type === "Space Goblin") {
                // Get current frame for Space Goblin
                const spriteFrame = EnemyManager.spaceGoblinIdleFrameImages[EnemyManager.currentAnimationFrame % 4];
                if (spriteFrame && spriteFrame.complete) {
                  ctx.drawImage(spriteFrame, enemy.x * GRID_SIZE, enemy.y * GRID_SIZE, enemy.width, enemy.height);
                } else {
                  ctx.drawImage(enemy.sprite, enemy.x * GRID_SIZE, enemy.y * GRID_SIZE, enemy.width, enemy.height);
                }
                return; // Skip other rendering for this enemy
              } else {
                // For other animated enemies without specific handling
                ctx.drawImage(enemy.sprite, enemy.x * GRID_SIZE, enemy.y * GRID_SIZE, enemy.width, enemy.height);
              }
            } else if (enemy.sprite.complete) {
              // For all non-animated enemies, use static sprite
              ctx.drawImage(enemy.sprite, enemy.x * GRID_SIZE, enemy.y * GRID_SIZE, enemy.width, enemy.height);
            }
          }
        });
      }

      // Removed duplicate updateCharacterScreen function - using UIManager.updateCharacterScreen instead

      function updateBattleScreen() {
        const battleScreen = document.getElementById("battleScreen");
        if (!battleScreen) return;

        const enemy = BattleManager.currentEnemy;
        if (!enemy) return;

        // Create portal animation container
        const portalContainer = document.createElement("div");
        portalContainer.className = "portal-animation";
        portalContainer.style.position = "absolute";
        portalContainer.style.top = "50%";
        portalContainer.style.left = "50%";
        portalContainer.style.transform = "translate(-50%, -50%)";
        portalContainer.style.width = "128px";
        portalContainer.style.height = "128px";
        portalContainer.style.zIndex = "1";

        // Add portal frames
        enemy.portalFrames.forEach((frame, index) => {
          const img = document.createElement("img");
          img.src = frame.src;
          img.style.position = "absolute";
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.display = "none";
          img.className = "portal-frame";
          portalContainer.appendChild(img);
        });

        // Create enemy sprite container
        const enemyContainer = document.createElement("div");
        enemyContainer.className = "enemy-sprite";
        enemyContainer.style.position = "relative";
        enemyContainer.style.width = "64px";
        enemyContainer.style.height = "64px";
        enemyContainer.style.zIndex = "2";

        const enemyImg = document.createElement("img");
        enemyImg.src = enemy.sprite.src; // Use the sprite.src property which contains the actual image URL
        enemyImg.style.width = "100%";
        enemyImg.style.height = "100%";
        enemyImg.style.borderRadius = "4px";
        enemyImg.style.border = "2px solid #ff4444";
        enemyImg.style.padding = "2px";
        enemyImg.style.display = "none";
        enemyContainer.appendChild(enemyImg);

        battleScreen.innerHTML = `
                <div class="battle-info">
                    <div class="enemy-display">
                        ${portalContainer.outerHTML}
                        ${enemyContainer.outerHTML}
                    </div>
                    <div class="enemy-stats">
                        <h3>${enemy.name}</h3>
                        <div class="progress-stat">
                            <span>HP: ${enemy.hp}/${enemy.maxHp}</span>
                            <div class="progress-bar">
                                <div class="hp-fill" style="width: ${(enemy.hp / enemy.maxHp) * 100}%"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="battle-actions">
                    <button onclick="BattleManager.executeAction('attack')">Attack</button>
                    <button onclick="BattleManager.executeAction('spell')">Spell</button>
                    <button onclick="BattleManager.executeAction('skill')">Skill</button>
                    <button onclick="BattleManager.executeAction('item')">Item</button>
                </div>
            `;

        // Start portal animation
        let currentFrame = 0;
        const portalFrames = battleScreen.querySelectorAll(".portal-frame");
        const enemySprite = battleScreen.querySelector(".enemy-sprite img");

        function animatePortal() {
          if (currentFrame < portalFrames.length) {
            portalFrames.forEach((frame, index) => {
              frame.style.display = index === currentFrame ? "block" : "none";
            });
            currentFrame++;
            setTimeout(animatePortal, 2000); // Slowed down from 200ms to 2000ms (10x slower)
          } else {
            // Show enemy sprite after portal animation
            enemySprite.style.display = "block";
            portalContainer.style.display = "none";
          }
        }

        animatePortal();
      }

      // Add these functions after the getItemAcronym function
      function getSkillAcronym(skillName) {
        const acronyms = {
          Whirlwind: "WHRL",
          "Divine Protection": "DPRT",
          Backstab: "BSTB",
          Fireball: "FIRE",
        };

        if (acronyms[skillName]) {
          return acronyms[skillName];
        }

        const words = skillName.split(" ");
        if (words.length === 1) {
          return skillName.substring(0, 4).toUpperCase();
        } else {
          return words
            .map((word) => word[0])
            .join("")
            .toUpperCase()
            .padEnd(4, "X");
        }
      }

      function getSpellAcronym(spellName) {
        const acronyms = {
          Heal: "HEAL",
          Fireball: "FIRE",
          Lightning: "LITN",
          "Ice Shard": "ICE",
        };

        if (acronyms[spellName]) {
          return acronyms[spellName];
        }

        const words = spellName.split(" ");
        if (words.length === 1) {
          return spellName.substring(0, 4).toUpperCase();
        } else {
          return words
            .map((word) => word[0])
            .join("")
            .toUpperCase()
            .padEnd(4, "X");
        }
      }

      function showSkillInfo(skill) {
        const tooltip = document.getElementById("skillTooltip");
        if (!tooltip) return;

        tooltip.innerHTML = `
                <div class="title">${skill.name}</div>
                <div class="description">${skill.description}</div>
                ${skill.mpCost ? `<div class="stats">MP Cost: ${skill.mpCost}</div>` : ""}
                ${skill.cooldown ? `<div class="stats">Cooldown: ${skill.cooldown} turns</div>` : ""}
            `;
      }

      function hideSkillInfo() {
        const tooltip = document.getElementById("skillTooltip");
        if (tooltip) {
          tooltip.innerHTML = `
                    <div class="title">Skill Information</div>
                    <div class="description">Click on a skill to see details</div>
                `;
        }
      }

      function showSpellInfo(spell) {
        const tooltip = document.getElementById("spellTooltip");
        if (!tooltip) return;

        tooltip.innerHTML = `
                <div class="title">${spell.name}</div>
                <div class="description">${spell.description}</div>
                ${spell.mpCost ? `<div class="stats">MP Cost: ${spell.mpCost}</div>` : ""}
                ${spell.cooldown ? `<div class="stats">Cooldown: ${spell.cooldown} turns</div>` : ""}
            `;
      }

      function hideSpellInfo() {
        const tooltip = document.getElementById("spellTooltip");
        if (tooltip) {
          tooltip.innerHTML = `
                    <div class="title">Spell Information</div>
                    <div class="description">Click on a spell to see details</div>
                `;
        }
      }

      function showItemInfo(item) {
        const tooltip = document.getElementById("itemTooltip");
        if (!tooltip) return;

        let description = `<div class="title">${item.name}</div>`;
        description += '<div class="description">';

        if (item.type === "consumable") {
          description += `Consumable Item<br>`;
          description += `Quantity: ${item.quantity}<br>`;
          if (item.healing) description += `<br>Healing: ${item.healing}`;
          if (item.manaRestore) description += `<br>Mana Restore: ${item.manaRestore}`;
        } else {
          description += `${item.weaponType || item.type}<br>`;
          if (item.stats) {
            description += Object.entries(item.stats)
              .map(([stat, value]) => `${stat}: +${value}`)
              .join("<br>");
          }
          if (item.requirements) {
            description += "<br><br>Requirements:<br>";
            description += Object.entries(item.requirements)
              .map(([stat, value]) => `${stat}: ${value}`)
              .join("<br>");
          }
        }

        description += "</div>";
        tooltip.innerHTML = description;
      }

      function hideItemInfo() {
        const tooltip = document.getElementById("itemTooltip");
        if (!tooltip) return;
        tooltip.querySelector(".title").textContent = "Item Information";
        tooltip.querySelector(".description").textContent = "Hover over an item to see details";
      }

      function getItemAcronym(name) {
        return name
          .split(" ")
          .map((word) => word[0])
          .join("");
      }

      const IntroManager = {
        // ...existing properties...
        introBox: null, // Will hold the reference to the styled intro box
        typingSpeed: 100, // Speed in ms between characters (slowed by 50% from typical 50ms)

        currentScreen: 0,
        screens: [
          {
            text: "We had no idea Earth was for sale.\nUntil we were purchased by the intersteller version of P.T. Barnum",
            background:
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Narrative1-q2mDBsKvyqQsNn7Zu7a3QT36p2M9hh.png?vGuq",
            duration: 2000,
          },
          {
            text: "It was just a normal day on Earth. People were grocery shopping. Picking up their kids. Scrolling. Swiping. Swearing at traffic.",
            background:
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Shopping-58EG1CsWpUH7RBPY3jXTyyxBdLrCm1.png?SMlF",
            duration: 2000,
          },
          {
            text: "A piercing PING! erupts from every screen—phones, billboards, smart‑watches—halting seven billion heartbeats in unison.",
            background:
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Shock-FE8GYBHDyJ1NXFS6vDl4O6K36GIVA1.png?pZxF",
            duration: 2000,
          },
          {
            text: "The message repeats in every language as panic sparks.",
            background:
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Auction-DD4H0eTvXmUDImg5FIuH8a8bPot7Xq.png?0KdN",
            duration: 2000,
          },
          {
            text: "Shafts of electric light skewer the streets; citizens are digitized mid‑stride and whisked skyward in shimmering data‑streams.",
            background:
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/TeleportStore-o52yEto3qZbwQuZkZmi2RlKjTaXsaE.png?wblu",
            duration: 2000,
          },

          {
            text: "In transit, bodies recompile—jeans into neon jumpsuits, flesh into pixel‑sheened avatars—stats and health bars flickering overhead.",
            background:
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Transformation-BzVmMb5tmkizSnIxX5rDDqv5YnvKF7.png?mppc",
            duration: 2000,
          },
          {
            text: "Humanity rematerializes inside a boundless, zero‑G arcade. Cabinets ignite, revealing the grinning visage of Galaxander: 'Welcome, contestants! Your planet has been acquired by the Galaxander Corporation and all of you now star in the ultimate intergalactic game show.'",
            background:
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/ArcadeWelcomeAnime-HTgSCgK8bb5l026TEsrtvxLs2WoovU.png?ixZi",
            duration: 2500,
          },
          {
            text: "Alarms blare. Prize hatches on every claw machine burst open, spewing goblins that swarm the floor—Level One has begun.",
            background:
              "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Firrstfight-k99DrfTi1srSIFLGPo0tqI0oX2neX3.png?32eu",
            duration: 2000,
          },
          // Add more screens here as needed
        ],

        isActive: false,
        enemyGroup: [],
        currentEnemyIndex: 0,
        currentEnemy: null,

        // Update animation frames based on the timestamp
        updateAnimations(timestamp) {
          // Only update if enough time has passed
          if (timestamp - this.lastFrameTime > this.animationFrameRate) {
            this.lastFrameTime = timestamp;
            this.currentAnimationFrame++;

            // Update enemy animations - check for any animated enemy types
            if (this.isActive && (EnemyManager.spaceGoblinIdleFrameImages || EnemyManager.cyberOrcIdleFrameImages)) {
              // Set animation frame count based on available frames
              let frameCount = 4; // Default
              if (EnemyManager.spaceGoblinIdleFrameImages && EnemyManager.spaceGoblinIdleFrameImages.length > 0) {
                frameCount = EnemyManager.spaceGoblinIdleFrameImages.length;
              } else if (EnemyManager.cyberOrcIdleFrameImages && EnemyManager.cyberOrcIdleFrameImages.length > 0) {
                frameCount = EnemyManager.cyberOrcIdleFrameImages.length;
              }

              // Update frame counter based on available frames
              this.currentAnimationFrame = this.currentAnimationFrame % frameCount;

              // Directly update enemy sprites in battle UI
              this.updateBattleSprites();
            } else {
              // Default animation cycle length if we don't have any animation frames
              this.currentAnimationFrame = this.currentAnimationFrame % 4;
            }
          }
        },

        // Update enemy sprite elements with current animation frame
        updateBattleSprites() {
          const enemySide = document.getElementById("enemySide");
          if (!enemySide) return;

          // Get all enemy sprite containers
          const enemyContainers = enemySide.querySelectorAll(".battle-sprite-container");
          if (!enemyContainers || enemyContainers.length === 0) return;

          // Update each enemy sprite with current animation frame
          enemyContainers.forEach((container, index) => {
            if (index < this.enemyGroup.length) {
              const enemy = this.enemyGroup[index];
              const img = container.querySelector("img");

              // Handle Space Goblin animations
              if (enemy && enemy.name === "Space Goblin" && img && EnemyManager.spaceGoblinIdleFrameImages) {
                const frameImage = EnemyManager.spaceGoblinIdleFrameImages[this.currentAnimationFrame];
                if (frameImage && frameImage.src) {
                  img.src = frameImage.src;
                }
              }

              // Handle Cyber Orc animations
              else if (enemy && enemy.name === "Cyber Orc" && img && EnemyManager.cyberOrcIdleFrameImages) {
                const frameImage = EnemyManager.cyberOrcIdleFrameImages[this.currentAnimationFrame];
                if (frameImage && frameImage.src) {
                  img.src = frameImage.src;
                }
              }
            }
          });
        },

        // Get the appropriate sprite for an entity in battle
        getBattleSprite(entity) {
          // For enemies, check if it's a Space Goblin with animation frames
          if (
            entity.name === "Space Goblin" &&
            EnemyManager.spaceGoblinIdleFrameImages &&
            EnemyManager.spaceGoblinIdleFrameImages.length > 0
          ) {
            return EnemyManager.spaceGoblinIdleFrameImages[this.currentAnimationFrame];
          }

          // For players, we'll implement player animations later
          // Here we would check for player animation frames

          // Fall back to the entity's regular sprite
          return entity.sprite;
        },

        // Update the battle UI with current game state including animated sprites
        updateUI() {
          console.log("[Battle] Updating battle UI");

          // Get references to UI elements
          const playerSide = document.getElementById("playerSide");
          const enemySide = document.getElementById("enemySide");

          if (!playerSide || !enemySide) {
            console.warn("[Battle] Battle UI elements not found");
            return;
          }

          // Clear previous content
          playerSide.innerHTML = "";
          enemySide.innerHTML = "";

          // Add player UI
          const player = GameStateManager.state.player;
          if (player) {
            const playerContainer = document.createElement("div");
            playerContainer.className = "battle-sprite-container";
            playerContainer.style.cssText = `
              position: relative;
              width: 150px;
              height: 150px;
              display: flex;
              flex-direction: column;
              align-items: center;
              justify-content: center;
            `;

            // Create player sprite
            const playerImg = document.createElement("img");
            playerImg.style.cssText = `
              width: 96px;
              height: 96px;
              object-fit: contain;
            `;
            // Use animation frames for Flexecutioner instead of static sprite
            if (
              player.class &&
              player.class.toUpperCase() === "FLEXECUTIONER" &&
              this.flexecutionerIdleFrameImages &&
              this.flexecutionerIdleFrameImages.length > 0
            ) {
              playerImg.src = this.flexecutionerIdleFrameImages[0].src;
              playerImg.classList.add("player-container");
            } else {
              // Safe fallback mechanism with default Flexecutioner image
              const defaultFlexecutionerSprite =
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Flexecutioner-YTnx5DSfVR0ALUTlZc9Kt5xLlJFP4m.png?DUxz";

              // Check if player.sprite exists and has a valid src property
              if (player.sprite && typeof player.sprite.src === "string") {
                playerImg.src = player.sprite.src;
              } else {
                console.log("[Battle] Using default Flexecutioner sprite due to missing sprite data");
                playerImg.src = defaultFlexecutionerSprite;
              }
            }

            // Add player stats
            const playerStats = document.createElement("div");
            playerStats.className = "battle-stats";
            playerStats.style.cssText = `
              margin-top: 10px;
              display: flex;
              flex-direction: column;
              align-items: center;
              width: 100%;
            `;

            // HP bar
            const hpContainer = document.createElement("div");
            hpContainer.className = "stat-bar-container";
            hpContainer.style.cssText = `
              width: 100%;
              margin-bottom: 5px;
            `;

            const hpLabel = document.createElement("div");
            hpLabel.className = "stat-label";
            hpLabel.style.cssText = `
              font-size: 10px;
              color: #00ffff;
              display: flex;
              justify-content: space-between;
              width: 100%;
            `;
            hpLabel.innerHTML = `<span>HP</span><span>${player.hp}/${player.derivedStats.maxHp}</span>`;

            const hpBar = document.createElement("div");
            hpBar.className = "hp-bar";
            hpBar.style.cssText = `
              width: 100%;
              height: 8px;
              background: rgba(0, 0, 0, 0.5);
              border: 1px solid #444;
              border-radius: 4px;
              overflow: hidden;
            `;

            const hpFill = document.createElement("div");
            hpFill.className = "hp-fill";
            hpFill.style.cssText = `
              width: ${(player.hp / player.derivedStats.maxHp) * 100}%;
              height: 100%;
              background: linear-gradient(to right, #ff0000, #ff6600);
            `;

            hpBar.appendChild(hpFill);
            hpContainer.appendChild(hpLabel);
            hpContainer.appendChild(hpBar);

            // MP bar
            const mpContainer = document.createElement("div");
            mpContainer.className = "stat-bar-container";
            mpContainer.style.cssText = `
              width: 100%;
            `;

            const mpLabel = document.createElement("div");
            mpLabel.className = "stat-label";
            mpLabel.style.cssText = `
              font-size: 10px;
              color: #00ffff;
              display: flex;
              justify-content: space-between;
              width: 100%;
            `;
            mpLabel.innerHTML = `<span>MP</span><span>${player.mp}/${player.derivedStats.maxMp}</span>`;

            const mpBar = document.createElement("div");
            mpBar.className = "mp-bar";
            mpBar.style.cssText = `
              width: 100%;
              height: 8px;
              background: rgba(0, 0, 0, 0.5);
              border: 1px solid #444;
              border-radius: 4px;
              overflow: hidden;
            `;

            const mpFill = document.createElement("div");
            mpFill.className = "mp-fill";
            mpFill.style.cssText = `
              width: ${(player.mp / player.derivedStats.maxMp) * 100}%;
              height: 100%;
              background: linear-gradient(to right, #0066ff, #00ccff);
            `;

            mpBar.appendChild(mpFill);
            mpContainer.appendChild(mpLabel);
            mpContainer.appendChild(mpBar);

            // Add all components
            playerStats.appendChild(hpContainer);
            playerStats.appendChild(mpContainer);

            playerContainer.appendChild(playerImg);
            playerContainer.appendChild(playerStats);
            playerSide.appendChild(playerContainer);
          }

          // Add enemy UI (showing all enemies in the group)
          if (this.enemyGroup && this.enemyGroup.length > 0) {
            this.enemyGroup.forEach((enemy, index) => {
              const enemyContainer = document.createElement("div");
              enemyContainer.className = "battle-sprite-container";
              enemyContainer.style.cssText = `
                position: relative;
                width: 150px;
                height: ${120 / this.enemyGroup.length}px;
                margin-bottom: 10px;
                display: flex;
                flex-direction: column;
                align-items: center;
              `;

              // Create enemy sprite using the animated sprite if available
              const enemyImg = document.createElement("img");
              enemyImg.style.cssText = `
                width: 64px;
                height: 64px;
                object-fit: contain;
                ${index === this.currentEnemyIndex ? "filter: drop-shadow(0 0 5px #ff0000);" : ""}
              `;

              // Directly use animation frames for Space Goblin instead of getBattleSprite
              if (
                enemy.name === "Space Goblin" &&
                this.spaceGoblinIdleFrameImages &&
                this.spaceGoblinIdleFrameImages.length > 0
              ) {
                // Make sure image is loaded before using it
                const frameImage = this.spaceGoblinIdleFrameImages[0];
                if (frameImage && frameImage.complete) {
                  console.log("[Battle] Using Space Goblin animation frame");
                  enemyImg.src = frameImage.src;
                  enemyImg.classList.add("enemy-container");
                } else {
                  console.log("[Battle] Space Goblin animation frame not loaded, using fallback");
                  // Default Space Goblin image as fallback
                  enemyImg.src =
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/SpaceGoblin-4JcVRqMRV3uNDXmWMBGdAj2qsKDGVa.png?eYWc";
                  enemyImg.classList.add("enemy-container");
                }
              }
              // Use animation frames for Cyber Orc
              else if (
                enemy.name === "Cyber Orc" &&
                this.cyberOrcIdleFrameImages &&
                this.cyberOrcIdleFrameImages.length > 0
              ) {
                // Make sure image is loaded before using it
                const frameImage = this.cyberOrcIdleFrameImages[0];
                if (frameImage && frameImage.complete) {
                  console.log("[Battle] Using Cyber Orc animation frame");
                  enemyImg.src = frameImage.src;
                  enemyImg.classList.add("enemy-container");
                } else {
                  console.log("[Battle] Cyber Orc animation frame not loaded, using fallback");
                  // Use a default Cyber Orc static image as fallback
                  enemyImg.src = this.cyberOrcIdleFrames[0];
                  enemyImg.classList.add("enemy-container");
                }
              } else {
                // Fall back to static sprite for other enemy types with better error handling
                if (enemy.sprite && typeof enemy.sprite.src === "string") {
                  enemyImg.src = enemy.sprite.src;
                } else {
                  console.log(`[Battle] Missing sprite data for enemy: ${enemy.name}`);
                  // Generic enemy fallback image
                  enemyImg.src =
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/defaultEnemy-wCbZhU6hEjFZcdwbgC5Aqrw66Zr2WK.png?KfzR";
                }
              }

              // Add enemy stats
              const enemyStats = document.createElement("div");
              enemyStats.className = "battle-stats";
              enemyStats.style.cssText = `
                margin-top: 5px;
                display: flex;
                flex-direction: column;
                align-items: center;
                width: 100%;
              `;

              // Add enemy name
              const enemyName = document.createElement("div");
              enemyName.className = "enemy-name";
              enemyName.style.cssText = `
                font-size: 10px;
                color: #ff6600;
                margin-bottom: 2px;
              `;
              enemyName.textContent = enemy.name || "Enemy";

              // HP bar
              const hpContainer = document.createElement("div");
              hpContainer.className = "stat-bar-container";
              hpContainer.style.cssText = `
                width: 100%;
              `;

              const hpBar = document.createElement("div");
              hpBar.className = "hp-bar";
              hpBar.style.cssText = `
                width: 100%;
                height: 5px;
                background: rgba(0, 0, 0, 0.5);
                border: 1px solid #444;
                border-radius: 2px;
                overflow: hidden;
              `;

              const hpFill = document.createElement("div");
              hpFill.className = "hp-fill";
              hpFill.style.cssText = `
                width: ${(enemy.hp / enemy.maxHp) * 100}%;
                height: 100%;
                background: linear-gradient(to right, #ff0000, #ff6600);
              `;

              hpBar.appendChild(hpFill);
              hpContainer.appendChild(hpBar);

              // Add all components
              enemyStats.appendChild(enemyName);
              enemyStats.appendChild(hpContainer);

              enemyContainer.appendChild(enemyImg);
              enemyContainer.appendChild(enemyStats);
              enemySide.appendChild(enemyContainer);

              // Add click event for targeting
              enemyContainer.addEventListener("click", () => {
                if (this.targetingMode) {
                  this.currentTarget = index;
                  this.executeAction(this.pendingAction, index);
                }
              });
            });
          }
        },
        timeouts: [], // New: Track all timeouts
        isTransitioning: false, // New: Track screen transition state
        isSkipping: false, // New: Track skip operation state

        // New: Timeout management helpers
        addTimeout(timeoutId) {
          this.timeouts.push(timeoutId);
        },

        clearAllTimeouts() {
          this.timeouts.forEach((id) => clearTimeout(id));
          this.timeouts = [];
        },

        init() {
          // Create or get the intro screen
          this.introScreen = document.getElementById("introScreen");
          if (!this.introScreen) {
            this.introScreen = document.createElement("div");
            this.introScreen.id = "introScreen";
            document.getElementById("game-container").appendChild(this.introScreen);
          }

          // Style the intro screen
          Object.assign(this.introScreen.style, {
            position: "absolute",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%",
            zIndex: "1000",
            background: "#000",
            display: "none", // Initially hide the intro screen
          });
          // Remove any existing intro box
          if (this.introBox && this.introBox.parentNode) {
            this.introBox.parentNode.removeChild(this.introBox);
          }
          // Create and style the intro box
          this.introBox = document.createElement("div");
          this.introBox.className = "intro-box";

          // Create text content container
          this.textContentContainer = document.createElement("div");
          Object.assign(this.textContentContainer.style, {
            width: "100%",
            flex: "1",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          });

          // Create skip message container
          this.skipMessageContainer = document.createElement("div");
          Object.assign(this.skipMessageContainer.style, {
            color: "#00ffff",
            fontSize: "14px",
            textAlign: "center",
            fontFamily: "'Courier New', Courier, monospace",
            textShadow: "2px 2px 4px rgba(0,0,0,0.8)",
            opacity: "0.9",
            pointerEvents: "none",
            whiteSpace: "nowrap",
            padding: "5px 10px",
            backgroundColor: "rgba(0,0,0,0.7)",
            borderRadius: "4px",
            position: "absolute",
            top: "10px",
            left: "50%",
            transform: "translateX(-50%)",
          });
          this.skipMessageContainer.textContent = "[Spacebar or Tap to Skip]";
          Object.assign(this.introBox.style, {
            position: "absolute",
            left: "50%",
            bottom: "0",
            transform: "translateX(-50%)",
            width: "90%",
            height: "35%",
            minHeight: "150px",
            background: "rgba(0,0,0,0.93)",
            border: "3px solid #00ffff",
            borderRadius: "18px 18px 0 0",
            boxShadow: "0 -2px 32px #00ffff33",
            display: "flex",
            flexDirection: "column",
            justifyContent: "flex-start",
            alignItems: "center",
            color: "#00ffff",
            fontSize: "12px",
            lineHeight: "1.6",
            padding: "15px 24px 24px 24px",
            textAlign: "center",
            zIndex: "10",
            fontFamily: "'Courier New', Courier, monospace",
            letterSpacing: "1px",
            fontWeight: "bold",
            textShadow:
              "2px 2px 4px rgba(0,0,0,0.8), -2px -2px 4px rgba(0,0,0,0.8), 2px -2px 4px rgba(0,0,0,0.8), -2px 2px 4px rgba(0,0,0,0.8)",
            overflow: "hidden",
          });
          // Clear any existing content
          this.introScreen.innerHTML = "";
          // Add the elements in the correct order
          this.introScreen.appendChild(this.introBox);
          this.introBox.appendChild(this.skipMessageContainer);
          this.introBox.appendChild(this.textContentContainer);
          this.textContainer = this.textContentContainer;
          this.cursor = null; // No cursor needed for this style

          this.keyHandler = (e) => {
            if (this.isTyping) {
              this.skipTyping();
            } else {
              this.skipScreen();
            }
          };

          document.addEventListener("keydown", this.keyHandler);

          // Add simple mobile touch handler
          this.introScreen.addEventListener("touchstart", (e) => {
            // Use the same function as spacebar press
            if (this.isTyping) {
              this.skipTyping();
            } else {
              this.skipScreen();
            }
          });

          // DO NOT automatically start the intro - will be started from PreStartManager
          // this.startIntro();
        },

        // New method to show the intro screen and start the intro sequence
        showIntro() {
          console.log("[IntroManager] Showing intro screen and starting intro");
          this.introScreen.style.display = "flex";
          this.startIntro();
        },

        startIntro() {
          this.clearAllTimeouts(); // Clear any existing timeouts
          this.isTransitioning = false;
          this.isSkipping = false;
          this.introScreen.style.display = "flex";
          this.showScreen(0);
        },

        showScreen(index) {
          if (this.isTransitioning) return; // Prevent overlapping transitions
          this.isTransitioning = true;

          if (index >= this.screens.length) {
            this.endIntro();
            return;
          }

          this.clearAllTimeouts(); // Clear any pending timeouts
          this.currentScreen = index;
          this.currentText = "";
          this.textContainer.innerHTML = "";
          this.isTyping = true;

          const screen = this.screens[index];

          if (screen.background) {
            this.introScreen.style.backgroundImage = `url('${screen.background}')`;
            this.introScreen.style.backgroundSize = "cover";
            this.introScreen.style.backgroundPosition = "center";
          } else {
            this.introScreen.style.backgroundImage = "none";
          }

          let charIndex = 0;

          const typeNextChar = () => {
            if (charIndex < screen.text.length) {
              this.currentText += screen.text[charIndex];
              this.textContainer.textContent = this.currentText;
              charIndex++;
              const timeoutId = setTimeout(typeNextChar, this.typingSpeed);
              this.addTimeout(timeoutId);
            } else {
              this.isTyping = false;
              // Single timeout for screen transition
              const timeoutId = setTimeout(() => {
                this.isTransitioning = false;
                this.nextScreen();
              }, screen.duration + 1000); // Combine both delays
              this.addTimeout(timeoutId);
            }
          };

          // Start typing after a short delay to ensure clean transition
          const startTypingId = setTimeout(() => {
            this.isTransitioning = false;
            typeNextChar();
          }, 100);
          this.addTimeout(startTypingId);
        },

        skipTyping() {
          if (this.isSkipping) return; // Prevent rapid skips
          this.isSkipping = true;

          this.clearAllTimeouts();
          this.isTyping = false;
          this.currentText = this.screens[this.currentScreen].text;
          this.textContainer.textContent = this.currentText;

          // Add small delay before allowing next skip
          const timeoutId = setTimeout(() => {
            this.isSkipping = false;
          }, 100);
          this.addTimeout(timeoutId);
        },

        skipScreen() {
          if (this.isTransitioning) return;
          this.clearAllTimeouts();
          this.nextScreen();
        },

        nextScreen() {
          this.showScreen(this.currentScreen + 1);
        },

        endIntro() {
          console.log(`[IntroManager] Ending intro - currentScreen: ${this.currentScreen}`);
          this.clearAllTimeouts();
          this.isTransitioning = false;
          this.isSkipping = false;

          if (this.keyHandler) {
            document.removeEventListener("keydown", this.keyHandler);
            this.keyHandler = null;
          }

          this.introScreen.style.display = "none";

          // Check if we just completed the 4th intro screen (index 3)
          if (this.currentScreen === 3) {
            console.log("[IntroManager] Launching FarFaller game");
            // Initialize and start the FarFaller game
            FarFaller.init();
            FarFaller.start();
          } else {
            // Start the game directly instead of showing the start screen
            console.log("[IntroManager] Starting game directly after intro");
            startGame();
          }
        },
      };

      // Pre-Start Screen for Audio Initialization and Game Start
      const PreStartManager = {
        init() {
          // Create pre-start screen if it doesn't exist
          if (!document.getElementById("preStartScreen")) {
            const preStartScreen = document.createElement("div");
            preStartScreen.id = "preStartScreen";

            // Use the same styling as the original start screen
            Object.assign(preStartScreen.style, {
              position: "fixed",
              top: "0",
              left: "0",
              width: "100%",
              height: "100%",
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              alignItems: "center",
              zIndex: "1000",
              // Use the actual background image for the start screen
              backgroundImage:
                'url("https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/GlitterStart-eWtnNjTcWxXyheoQtPcBK9MDLQWYBK.png?koxn")',
              backgroundSize: "cover",
              backgroundPosition: "center center",
              backgroundRepeat: "no-repeat",
              fontFamily: '"Courier New", monospace',
              color: "#edd628",
              textShadow: "0 0 7px #9932CC, 0 0 10px #9932CC, 0 0 21px #9932CC, 0 0 42px #9932CC",
            });

            // Add logo/title
            const title = document.createElement("h1");
            title.textContent = "GLITTER CLOUD ADVENTURE";
            Object.assign(title.style, {
              fontSize: "28px",
              marginBottom: "30px",
              textAlign: "center",
              letterSpacing: "2px",
              color: "#edd628",
              textShadow: "0 0 7px #9932CC, 0 0 10px #9932CC, 0 0 21px #9932CC, 0 0 42px #9932CC",
            });
            preStartScreen.appendChild(title);

            // Content container for better organization
            const contentContainer = document.createElement("div");
            contentContainer.className = "start-content";
            Object.assign(contentContainer.style, {
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              padding: "20px",
              backgroundColor: "rgba(0, 0, 0, 0.85)",
              border: "2px solid #9932CC",
              borderRadius: "10px",
              boxShadow: "0 0 20px rgba(153, 50, 204, 0.5)",
              maxWidth: "80%",
              margin: "0 auto",
            });

            // Add audio option container
            const audioOptionContainer = document.createElement("div");
            Object.assign(audioOptionContainer.style, {
              marginBottom: "30px",
              display: "flex",
              alignItems: "center",
              padding: "12px",
              border: "1px solid #9932CC",
              borderRadius: "5px",
              backgroundColor: "rgba(153, 50, 204, 0.2)",
              width: "100%",
              justifyContent: "center",
            });

            // Add checkbox for audio - UNCHECKED by default
            const audioCheckbox = document.createElement("input");
            audioCheckbox.type = "checkbox";
            audioCheckbox.id = "enableAudio";
            audioCheckbox.checked = false; // Start unchecked as requested
            Object.assign(audioCheckbox.style, {
              marginRight: "10px",
              transform: "scale(1.5)",
              accentColor: "#9932CC",
            });
            audioOptionContainer.appendChild(audioCheckbox);

            // Add label for checkbox
            const audioLabel = document.createElement("label");
            audioLabel.htmlFor = "enableAudio";
            audioLabel.textContent = "Initialize game audio and music";
            Object.assign(audioLabel.style, {
              cursor: "pointer",
              color: "#edd628",
              textShadow: "0 0 5px #9932CC",
              fontWeight: "bold",
            });
            audioOptionContainer.appendChild(audioLabel);

            contentContainer.appendChild(audioOptionContainer);

            // Add start button with styling from original start screen
            const startButton = document.createElement("button");
            startButton.textContent = "START GAME";
            Object.assign(startButton.style, {
              padding: "12px 25px",
              fontSize: "20px",
              color: "#edd628",
              borderColor: "#9932CC",
              background: "linear-gradient(135deg, rgba(153, 50, 204, 0.8) 0%, rgba(153, 50, 204, 0.4) 100%)",
              textShadow: "0 0 10px #000, 0 0 20px #000, 0 0 30px #9932CC",
              boxShadow: "0 0 20px rgba(153, 50, 204, 0.5)",
              border: "2px solid #9932CC",
              borderRadius: "5px",
              cursor: "pointer",
              transition: "all 0.3s",
            });

            // Hover effect
            startButton.onmouseover = function () {
              Object.assign(this.style, {
                background: "linear-gradient(135deg, rgba(153, 50, 204, 0.9) 0%, rgba(153, 50, 204, 0.6) 100%)",
                transform: "scale(1.05)",
                boxShadow: "0 0 30px rgba(153, 50, 204, 0.7)",
              });
            };

            startButton.onmouseout = function () {
              Object.assign(this.style, {
                background: "linear-gradient(135deg, rgba(153, 50, 204, 0.8) 0%, rgba(153, 50, 204, 0.4) 100%)",
                transform: "scale(1)",
                boxShadow: "0 0 20px rgba(153, 50, 204, 0.5)",
              });
            };

            // Click handler to initialize audio and start the game directly
            startButton.onclick = function () {
              const enableAudio = document.getElementById("enableAudio").checked;

              if (enableAudio) {
                // Initialize audio with user interaction
                AudioManager.init(true); // Pass true to indicate user-initiated action
                AudioManager.userInitiatedAudio = true; // Explicitly set this flag
                AudioManager.readyToPlay = true;
                console.log("[Audio] User has initialized audio");

                // Force a small delay before playing to ensure the audio context is ready
                setTimeout(() => {
                  // Play a test sound to ensure audio is properly initialized
                  AudioManager.play("click");
                  // Start background music after a short delay
                  setTimeout(() => {
                    AudioManager.playBackgroundMusic();
                  }, 100);
                }, 100);
              } else {
                // Set audio to muted but still do initialization
                AudioManager.init(true); // Still init with user interaction
                AudioManager.userInitiatedAudio = true; // Set the flag
                AudioManager.setMuted(true); // But keep it muted
                console.log("[Audio] Audio initialized but muted by user preference");
              }

              // Hide pre-start screen and start the game directly
              document.getElementById("preStartScreen").style.display = "none";

              // First show the intro
              IntroManager.init(); // Initialize the intro manager
              IntroManager.showIntro(); // Show and start the intro sequence
            };

            contentContainer.appendChild(startButton);
            preStartScreen.appendChild(contentContainer);
            document.body.appendChild(preStartScreen);

            // Hide the original start screen - we don't need it anymore
            const originalStartScreen = document.getElementById("startScreen");
            if (originalStartScreen) {
              originalStartScreen.style.display = "none";
            }
          }
        },
      };

      // Initialize the pre-start screen when the page loads
      window.addEventListener("load", () => {
        // Show pre-start screen first
        PreStartManager.init();

        // Add mobile touch support for start screen and character selection
        const startScreen = document.getElementById("startScreen");
        if (startScreen) {
          const startButton = startScreen.querySelector(".button");
          if (startButton) {
            // Add explicit touch event to ensure iOS Safari compatibility
            startButton.addEventListener("touchstart", function (e) {
              e.preventDefault(); // Prevent double-firing
              startGame(); // Call the same function as the onclick handler
            });
          }
        }

        // Setup for character selection screen - just ensure the choose buttons work on touch
        const characterSelect = document.getElementById("characterSelect");
        if (characterSelect) {
          // We'll add the touch handlers when the character list is populated
          const originalPopulateCharacterList = populateCharacterList;

          // Override the function to add touch handlers after populating
          window.populateCharacterList = function () {
            // Call the original function first
            originalPopulateCharacterList.apply(this, arguments);

            // Now add touch handlers to all choose buttons
            const chooseButtons = characterSelect.querySelectorAll(".choose-button");
            chooseButtons.forEach((button) => {
              button.addEventListener("touchstart", function (e) {
                e.preventDefault(); // Prevent double-firing
                this.click(); // Trigger the same action as clicking
              });
            });
          };
        }
      });

      const COMBAT_SYSTEMS = {
        DICE_PROGRESSION: {
          TIER_1: { min: 0, max: 10, dice: "d4", multiplier: 1.2 },
          TIER_2: { min: 11, max: 20, dice: "d6", multiplier: 1.4 },
          TIER_3: { min: 21, max: 30, dice: "d8", multiplier: 1.6 },
          TIER_4: { min: 31, max: 40, dice: "d10", multiplier: 1.8 },
          TIER_5: { min: 41, max: 999, dice: "d12", multiplier: 2.0 },
        },
        SPECIAL_EFFECTS: {
          TIER_1: { effects: [] },
          TIER_2: { effects: ["stun"] },
          TIER_3: { effects: ["stun", "cleave"] },
          TIER_4: { effects: ["stun", "cleave", "execute"] },
          TIER_5: { effects: ["stun", "cleave", "execute", "lifesteal"] },
        },
        CRITICAL_SYSTEM: {
          TIER_1: { min: 0, max: 10, multiplier: 1.5 },
          TIER_2: { min: 11, max: 20, multiplier: 1.75 },
          TIER_3: { min: 21, max: 30, multiplier: 2.0 },
          TIER_4: { min: 31, max: 40, multiplier: 2.25 },
          TIER_5: { min: 41, max: 999, multiplier: 2.5 },
        },
        PENETRATION_SYSTEM: {
          TIER_1: { min: 0, max: 10, penetration: 0.1 },
          TIER_2: { min: 11, max: 20, penetration: 0.2 },
          TIER_3: { min: 21, max: 30, penetration: 0.3 },
          TIER_4: { min: 31, max: 40, penetration: 0.4 },
          TIER_5: { min: 41, max: 999, penetration: 0.5 },
        },
      };

      function getTier(stats, system) {
        const statValue = stats[system.stat];
        for (const [tier, range] of Object.entries(COMBAT_SYSTEMS[system.name])) {
          if (statValue >= range.min && statValue <= range.max) {
            return tier;
          }
        }
        return "TIER_1";
      }

      function calculateDiceRolls(stats, system) {
        const tier = getTier(stats, system);
        const diceSystem = COMBAT_SYSTEMS.DICE_PROGRESSION[tier];
        const baseStat = stats[system.stat];

        // Calculate number of dice rolls based on stat value
        const rolls = Math.floor(baseStat / 10) + 1;

        // Calculate dice size based on tier
        const diceSize = parseInt(diceSystem.dice.substring(1));

        return {
          rolls,
          diceSize,
          multiplier: diceSystem.multiplier,
        };
      }

      function checkSpecialEffects(attacker, defender) {
        const tier = getTier(attacker.stats, { name: "DICE_PROGRESSION", stat: "strength" });
        const effects = COMBAT_SYSTEMS.SPECIAL_EFFECTS[tier].effects;
        const appliedEffects = [];

        effects.forEach((effect) => {
          if (Math.random() < 0.1) {
            // 10% chance per effect
            appliedEffects.push(effect);
          }
        });

        return appliedEffects;
      }

      // Mini-game battle helpers
      const BattleHelpers = {
        isActive: false,
        currentEnemy: null,
        createBattleUI() {
          // Implementation will be added
          console.log("[Battle UI] Creating battle UI");
        },

        displayMessage(message) {
          console.log("[Message System] Attempting to display:", message);
          const messageContainer = document.getElementById("battleMessageContainer");
          if (!messageContainer) {
            console.warn("[Message System] Message container not found");
            return;
          }
          console.log("[Message System] Current battle state:", this.isActive);

          const messageElement = document.createElement("div");
          messageElement.textContent = message;
          messageContainer.appendChild(messageElement);
          console.log("[Message System] Message added to container");
        },

        endBattle() {
          console.log("[Battle End] Starting battle end sequence");
          console.log(
            "[Battle End] Messages in container:",
            document.getElementById("battleMessageContainer")?.children.length,
          );
          console.log("[Battle End] Battle state before end:", this.isActive);

          const battleScreen = document.getElementById("battleScreen");

          // Give time for final messages to display
          setTimeout(() => {
            this.isActive = false;
            if (battleScreen) {
              console.log("[Battle End] Removing battle screen");
              battleScreen.remove();
            }
            console.log("[Battle End] Battle cleanup complete");
          }, 1000); // 1 second delay
        },

        executeAction(action) {
          console.log("[Battle Action] Executing action:", action);
          // ... existing code ...
          console.log("[Battle Action] Action complete, messages pending display");
        },

        startBattle(enemy) {
          console.log("[Battle Start] Initializing battle with:", enemy?.name);
          console.log("[Battle Start] Previous battle state:", this.isActive);
          this.currentEnemy = enemy;
          this.isActive = true;
          this.createBattleUI();
          console.log("[Battle Start] Battle UI created");
        },

        processEnemyTurn() {
          console.log("[Enemy Turn] Starting enemy turn");
          console.log("[Enemy Turn] Current enemy HP:", this.currentEnemy?.hp);
          // ... existing code ...
          console.log("[Enemy Turn] Enemy turn complete");
        },

        checkBattleEnd() {
          console.log("[Battle Check] Checking battle end conditions");
          if (GameStateManager.state.player.hp <= 0) {
            this.handlePlayerDeath();
            return true;
          }
          if (this.currentEnemy.hp <= 0) {
            this.handleEnemyDeath();
            return true;
          }
          return false;
        },

        handlePlayerDeath() {
          this.isActive = false;
          const defeatScreen = document.createElement("div");
          defeatScreen.className = "defeat-screen";
          defeatScreen.innerHTML = `
                <div class="defeat-content">
                    <h2>You've Been Defeated</h2>
                    <div class="defeat-options">
                        <button onclick="GameStateManager.load(); defeatScreen.remove();">Load Last Save</button>
                        <button onclick="location.reload()">Return to Start</button>
                    </div>
                </div>
            `;
          document.body.appendChild(defeatScreen);
        },

        playMiniAttackSequence(target) {
          // Create animation container if it doesn't exist
          const container = document.getElementById("combatAnimationContainer");
          if (!container) return;

          // Clear any existing animations
          container.innerHTML = "";

          // Get enemy side position for proper placement (same positioning as main battle system)
          const miniEnemySide = document.getElementById("enemySide");
          if (!miniEnemySide) return;

          // Get the enemy side's position
          const enemyRect = miniEnemySide.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();

          // Calculate position (center of enemy side)
          const posX = enemyRect.left - containerRect.left + enemyRect.width / 2;
          const posY = enemyRect.top - containerRect.top + enemyRect.height / 2;

          // Create slash effect
          const slashEffect = document.createElement("div");
          slashEffect.style.cssText = `
            position: absolute;
            width: 80px;
            height: 80px;
            background-image: url('https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/slash-hDG8UJuYaUUyYXLWdJcUGRPyPyQ7iP.png');
            background-size: cover;
            top: ${posY}px;
            left: ${posX}px;
            transform: translate(-50%, -50%) rotate(45deg);
            opacity: 0;
            z-index: 10;
            pointer-events: none;
            animation: slashAnim 1s ease-out forwards;
          `;

          // Add animation keyframes if they don't exist yet
          if (!document.getElementById("combatAnimationStyles")) {
            const styleSheet = document.createElement("style");
            styleSheet.id = "combatAnimationStyles";
            styleSheet.textContent = `
              @keyframes slashAnim {
                0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5) rotate(-20deg); }
                10% { opacity: 1; }
                90% { opacity: 1; transform: translate(-50%, -50%) scale(1.2) rotate(20deg); }
                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5) rotate(30deg); }
              }
              
              @keyframes powerStrikeAnim {
                0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                70% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
              }
              
              @keyframes shake {
                0% { transform: translateX(0); }
                25% { transform: translateX(-5px); }
                50% { transform: translateX(5px); }
                75% { transform: translateX(-5px); }
                100% { transform: translateX(0); }
              }
            `;
            document.head.appendChild(styleSheet);
          }

          container.appendChild(slashEffect);

          // Shake the enemy side
          const enemySide = document.getElementById("enemySide");
          if (enemySide) {
            enemySide.style.animation = "shake 0.5s ease-in-out";
            setTimeout(() => {
              enemySide.style.animation = "";
            }, 500);
          }

          // Clean up animation after it completes
          setTimeout(() => {
            container.innerHTML = "";
          }, 1000);
        },

        playPowerStrikeSequence(target) {
          // Create animation container if it doesn't exist
          const container = document.getElementById("combatAnimationContainer");
          if (!container) return;

          // Clear any existing animations
          container.innerHTML = "";

          // Create power strike effect
          const powerEffect = document.createElement("div");
          powerEffect.style.cssText = `
            position: absolute;
            width: 150px;
            height: 150px;
            background-image: url('https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/power_strike-QDkgH5c0ygUTIJhSx89sccPjuLJ4L8.png');
            background-size: cover;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            z-index: 10;
            pointer-events: none;
            animation: powerStrikeAnim 2s ease-out forwards;
          `;

          container.appendChild(powerEffect);

          // Add a second delayed slash effect
          setTimeout(() => {
            const slashEffect = document.createElement("div");
            slashEffect.style.cssText = `
              position: absolute;
              width: 120px;
              height: 120px;
              background-image: url('https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/slash-hDG8UJuYaUUyYXLWdJcUGRPyPyQ7iP.png');
              background-size: cover;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%) rotate(45deg);
              opacity: 0;
              z-index: 10;
              pointer-events: none;
              animation: slashAnim 1s ease-out forwards;
            `;
            container.appendChild(slashEffect);

            // Shake the enemy side more intensely
            const enemySide = document.getElementById("enemySide");
            if (enemySide) {
              enemySide.style.animation = "shake 0.7s ease-in-out 3";
              setTimeout(() => {
                enemySide.style.animation = "";
              }, 1000);
            }
          }, 1000);

          // Clean up animation after it completes
          setTimeout(() => {
            container.innerHTML = "";
          }, 2500);
        },

        handleEnemyDeath() {
          this.isActive = false;
          const victoryScreen = document.createElement("div");
          victoryScreen.className = "victory-screen";
          victoryScreen.innerHTML = `
                <div class="victory-content">
                    <h2>Victory!</h2>
                    <div class="victory-options">
                        <button onclick="BattleManager.endBattle()">Continue</button>
                    </div>
                </div>
            `;
          document.body.appendChild(victoryScreen);
        },
      };

      // Dialogue System
      const DialogueSystem = {
        // Store the dialogue sequences
        dialogues: {
          glitchStick: [
            { speaker: "📝 SYSTEM", text: "You feel a strange pull…Press Spacebar to Claim the Relic" },
            {
              speaker: "📝 SYSTEM",
              text: "[A low hum rises. A teal-colored USB stick — pulsating with digital static — floats into view on the screen.]",
            },
            { speaker: "📝 SYSTEM", text: "You obtained: The Glitch Stick™." },
            {
              speaker: "📝 SYSTEM",
              text: "[Suddenly, the room surges with energy. Sparks flash. A distorted voice echoes from nowhere.]",
            },
            {
              speaker: "🗣️ ??? (Voice)",
              text: "Whew. That felt... awful.\nYou again? Or—no. Wait. First-timer.\nCongratulations, you're officially stuck with me.",
            },
            {
              speaker: "🗣️ ??? (Voice)",
              text: "I'm your Guide, more or less.\nA spiritual firmware companion from the glory days of patchable consciousness.",
            },
            {
              speaker: "📝 SYSTEM",
              text: "[A faint holographic sprite appears above the Glitch Stick. It flickers like a corrupted tutorial assistant.]",
            },
            {
              speaker: "🗣️ Guide",
              text: "So. This place? It's not an arcade.\nIt's a multiversal choke point duct-taped together by nostalgia and unstable cheat codes.",
            },
            {
              speaker: "🗣️ Guide",
              text: "Every room is a game. Every game is a test. Every test… earns me XP.\nAnd when I level up? You get access to cooler stuff. Shops. Missions.\nRelic fusion. Inventory systems. You know, the good stuff.",
            },
            {
              speaker: "📝 SYSTEM",
              text: "[The arched door on the right buzzes to life. Neon letters flash above it.]",
            },
            { speaker: "📝 SYSTEM", text: "INSERT FURY TO BEGIN" },
            {
              speaker: "🗣️ Guide",
              text: "Through there? That's Glitch Gremlin Gauntlet.\nYou'll know what to do when you see it.\nBreak something. Survive. Make me sparkle.",
            },
            { speaker: "🗣️ Guide", text: "Relics like me... wake up when the world fights back." },
            {
              speaker: "📝 SYSTEM",
              text: "[New Objective: Enter the Gauntlet]\n[The Glitch Stick pulses with energy.]",
            },
          ],
        },

        // Track current dialogue state
        isActive: false,
        currentDialogue: null,
        currentIndex: 0,
        previousGameState: null,

        // Initialize dialogue system
        init() {
          // Create dialogue box if it doesn't exist
          if (!document.getElementById("dialogueBox")) {
            const dialogueBox = document.createElement("div");
            dialogueBox.id = "dialogueBox";
            dialogueBox.style.cssText = `
                    position: absolute;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.8);
                    border: 2px solid #38f3ff;
                    border-radius: 5px;
                    color: #fff;
                    padding: 15px;
                    width: 80%;
                    max-width: 500px;
                    z-index: 1000;
                    display: none;
                    font-family: 'Courier New', Courier, monospace;
                    text-shadow: 0 0 5px #38f3ff;
                    animation: fadeIn 0.3s ease-in;
                `;

            // Create content elements
            dialogueBox.innerHTML = `
                    <div id="dialogueSpeaker" style="
                        color: #38f3ff;
                        font-weight: bold;
                        margin-bottom: 5px;
                    "></div>
                    <div id="dialogueText" style="
                        margin-bottom: 10px;
                        line-height: 1.5;
                        font-size: 16px;
                    "></div>
                    <div id="dialogueContinue" style="
                        text-align: right;
                        color: #38f3ff;
                        font-size: 14px;
                        animation: pulse 1s infinite;
                    ">Press SPACEBAR to continue...</div>
                `;

            document.body.appendChild(dialogueBox);
          }
        },

        // Start a dialogue
        start(dialogueKey) {
          if (!this.dialogues[dialogueKey]) {
            console.error(`Dialogue ${dialogueKey} not found`);
            return;
          }

          this.init();

          // Save previous game state
          this.previousGameState = GameStateManager.state.currentState;
          GameStateManager.state.currentState = GAME_STATES.DIALOGUE;

          // IMPORTANT FIX: Initialize the GlitchNPCManager if this is the glitchStick dialogue
          if (dialogueKey === "glitchStick" && typeof GlitchNPCManager !== 'undefined') {
            console.log("DEBUG: Initializing GlitchNPCManager for glitchStick dialogue");
            
            // Make sure the NPC manager is initialized
            if (!GlitchNPCManager.isInitialized) {
              GlitchNPCManager.init();
            }
            
            // Reset spacebar press count to ensure proper tracking
            GlitchNPCManager.state.spacebarPressCount = 0;
            
            // Ensure we're in the hidden state initially
            GlitchNPCManager.state.currentState = GlitchNPCManager.STATES.HIDDEN;
            GlitchNPCManager.state.isVisible = false;
            
            // Remove any existing NPCs to start fresh
            GlitchNPCManager.remove();
          }

          this.currentDialogue = this.dialogues[dialogueKey];
          this.currentIndex = 0;
          this.isActive = true;
          this.showCurrentMessage();

          // Add spacebar event listener
          document.addEventListener("keydown", this.handleKeyPress);
        },

        // Display current message
        showCurrentMessage() {
          if (!this.currentDialogue || this.currentIndex >= this.currentDialogue.length) {
            this.end();
            return;
          }

          const message = this.currentDialogue[this.currentIndex];
          const dialogueBox = document.getElementById("dialogueBox");
          const speakerElement = document.getElementById("dialogueSpeaker");
          const textElement = document.getElementById("dialogueText");

          speakerElement.textContent = message.speaker;
          textElement.innerHTML = message.text.replace(/\n/g, "<br>");
          dialogueBox.style.display = "block";

          // Play sound if available
          if (AudioManager && typeof AudioManager.play === "function") {
            AudioManager.play("clickSound");
          }
        },

        // Handle spacebar press
        handleKeyPress(event) {
          if (DialogueSystem.isActive && (event.code === "Space" || event.key === " ")) {
            event.preventDefault();
            DialogueSystem.nextMessage();
          }
        },

        // Advance to next message
        nextMessage() {
          this.currentIndex++;
          
          // IMPORTANT FIX: We need to properly track spacebar presses for the glitchStick dialogue
          if (this.currentDialogue === this.dialogues.glitchStick && 
              typeof GlitchNPCManager !== 'undefined') {
            
            // Ensure GlitchNPCManager is initialized
            if (!GlitchNPCManager.state) {
              GlitchNPCManager.init();
            }
            
            // Increment the counter manually
            GlitchNPCManager.state.spacebarPressCount++;
            console.log("DEBUG: DialogueSystem incremented GlitchNPC spacebar count to " + GlitchNPCManager.state.spacebarPressCount);
            
            // Only trigger special animation exactly on the 4th press
            if (GlitchNPCManager.state.spacebarPressCount === 4 && 
                !GameStateManager.state.relics?.glitchStickClaimed) {
              console.log("DEBUG: Dialogue system triggering Glitch NPC on 4th press");
              
              console.log('USING OVERLAY APPROACH');
              
              // Clean up any previous elements
              document.querySelectorAll('[id^="glitch-"], #backupGlitch, #glitch-indicator, #game-overlay, #overlay-glitch').forEach(el => el.remove());
              
              // APPROACH: Create an overlay that sits on top of the game canvas
              const canvas = document.getElementById('gameCanvas');
              if (!canvas) {
                console.error('Game canvas not found!');
                return;
              }
              
              // Create container overlay that matches the canvas exactly
              const overlay = document.createElement('div');
              overlay.id = 'game-overlay';
              
              // Apply styles to make overlay match canvas exactly
              const canvasRect = canvas.getBoundingClientRect();
              overlay.style.cssText = `
                position: absolute;
                top: ${canvasRect.top}px;
                left: ${canvasRect.left}px;
                width: ${canvasRect.width}px;
                height: ${canvasRect.height}px;
                pointer-events: none;
                z-index: 9999999;
                overflow: hidden;
              `;
              
              document.body.appendChild(overlay);
              
              // Get camera position from player position
              let cameraX = 0;
              let cameraY = 0;
              
              function updateCamera() {
                // Only attempt if GameStateManager exists
                if (!GameStateManager || !GameStateManager.state || !GameStateManager.state.player) {
                  return;
                }
                
                const GRID_SIZE = 48; // Grid size in pixels
                const player = GameStateManager.state.player;
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                
                // Calculate camera based on how the game calculates it (from your code)
                cameraX = Math.max(
                  0,
                  Math.min(
                    player.x * GRID_SIZE - canvasWidth / 2,
                    (RenderManager.backgroundImage ? RenderManager.backgroundImage.width : 0) - canvasWidth
                  )
                );
                
                cameraY = Math.max(
                  0,
                  Math.min(
                    player.y * GRID_SIZE - canvasHeight / 2,
                    (RenderManager.backgroundImage ? RenderManager.backgroundImage.height : 0) - canvasHeight
                  )
                );
              }
              
              // Create our glitch element container
              const glitch = document.createElement('div');
              glitch.id = 'overlay-glitch';
              
              // Style the glitch element container
              glitch.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 48px;
                height: 48px;
                filter: drop-shadow(0 0 10px #ff00ff);
              `;
              
              // Load all three glitch frames
              const frames = [
                'https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch1-p2MLYFtyBu70EfEzX38RisTZlDPz34.png?Uexu',
                'https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch2-wuGkXV6PbAhek8PI8QmClEcb2RWQNs.png?vrAB',
                'https://lqy3lriiybxcejon.public.blob.vercel-storage.com/c3AEorTjqZQC/Glitch3-VJR80WmbDycduGMWQoDAcXwVzUGb0k.png?npHD'
              ];
              
              // Create all frame images
              const frameElements = frames.map((src, i) => {
                const img = document.createElement('img');
                img.id = `glitch-frame-${i}`;
                img.src = src;
                img.style.cssText = `
                  width: 48px;
                  height: 48px;
                  display: ${i === 0 ? 'block' : 'none'}; /* Only show first frame initially */
                  position: absolute;
                  top: 0;
                  left: 0;
                `;
                glitch.appendChild(img);
                return img;
              });
              
              // Add the glitch to the overlay
              overlay.appendChild(glitch);
              
              // Create flash element
              const flash = document.createElement('div');
              flash.id = 'glitch-flash';
              flash.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: white;
                opacity: 0;
                pointer-events: none;
                z-index: 9999;
                transition: opacity 0.1s ease-in-out;
              `;
              overlay.appendChild(flash);
              
              // Add animation styles
              const animStyle = document.createElement('style');
              animStyle.textContent = `
                @keyframes bobAnimation {
                  0% { transform: translateY(0); }
                  50% { transform: translateY(-5px); }
                  100% { transform: translateY(0); }
                }
                
                @keyframes flashAnimation {
                  0% { opacity: 0; }
                  20% { opacity: 1; }
                  100% { opacity: 0; }
                }
              `;
              document.head.appendChild(animStyle);
              
              // Animation sequence variables
              let isAnimating = true;
              let currentFrame = 0;
              let cyclesCompleted = 0;
              let frameDelay = 300; // Initial speed (300ms per frame)
              
              // Play flash effect before starting animation
              const playFlash = () => {
                // Make sure glitch is hidden initially
                glitch.style.opacity = '0';
                
                // Play a bright flash
                flash.style.animation = 'flashAnimation 0.4s ease-in-out';
                
                // Start animation sequence after flash
                setTimeout(() => {
                  glitch.style.opacity = '1';
                  animateFrames();
                  
                  // Remove flash after it's done
                  setTimeout(() => {
                    flash.style.animation = 'none';
                    flash.style.opacity = '0';
                  }, 500);
                }, 350); // Start animation right as flash is fading
              };
              
              // Animation sequence that runs before bobbing
              const animateFrames = () => {
                if (!isAnimating) return;
                
                // Hide all frames
                frameElements.forEach(frame => frame.style.display = 'none');
                
                // Show current frame
                frameElements[currentFrame].style.display = 'block';
                
                // Apply flip transformation based on cycle number
                // Normal orientation for cycles 0 and 2, flipped for cycles 1 and 3
                const shouldFlip = cyclesCompleted % 2 === 1;
                frameElements[currentFrame].style.transform = shouldFlip ? 'scaleX(-1)' : 'scaleX(1)';
                
                // Move to next frame
                currentFrame = (currentFrame + 1) % frameElements.length;
                
                // If we've completed a cycle
                if (currentFrame === 0) {
                  cyclesCompleted++;
                  console.log(`Completed cycle ${cyclesCompleted} at speed ${frameDelay}ms`);
                  
                  // Speed up by 50% for each cycle for the first 4 cycles, then maintain speed
                  if (cyclesCompleted < 4) {
                    frameDelay = Math.max(75, frameDelay * 0.5); // Don't go faster than 75ms
                  }
                  
                  // After completing 10 cycles, switch to bobbing
                  if (cyclesCompleted >= 10) {
                    isAnimating = false;
                    
                    // Show only the first frame, flipped, and add bobbing
                    frameElements.forEach(frame => frame.style.display = 'none');
                    frameElements[0].style.display = 'block';
                    frameElements[0].style.transform = 'scaleX(-1)'; // Flip the bobbing sprite
                    glitch.style.animation = 'bobAnimation 2s ease-in-out infinite';
                    console.log('Animation sequence completed, switched to bobbing with flipped sprite');
                    return;
                  }
                }
                
                // Continue animation sequence with the current speed
                setTimeout(animateFrames, frameDelay);
              };
              
              // Start with the flash effect, which will trigger the animation sequence
              playFlash();
              
              // Update the glitch position on every frame
              function updateGlitchPosition() {
                updateCamera();
                
                const GRID_SIZE = 48;
                const targetX = 11;
                const targetY = 9;
                
                // Calculate screen position based on target grid position and camera offset
                const screenX = (targetX * GRID_SIZE) - cameraX;
                const screenY = (targetY * GRID_SIZE) - cameraY;
                
                // Update the glitch position
                glitch.style.left = `${screenX}px`;
                glitch.style.top = `${screenY}px`;
              }
              
              // Update frequently
              setInterval(updateGlitchPosition, 16); // 60fps
              
              // Also try to hook into the game's render loop for smoother updates
              if (typeof RenderManager !== 'undefined' && typeof RenderManager.render === 'function') {
                const originalRender = RenderManager.render;
                RenderManager.render = function() {
                  const result = originalRender.apply(this, arguments);
                  updateGlitchPosition(); // Update position after rendering
                  return result;
                };
              }
              
              // Debug indicator removed to clean up UI
              console.log('Creating glitch at grid position (11,9) without debug indicator');
              
              // Just log to console, no visual alerts
              console.log("Glitch animation activated at grid position (11,9)");
              
              // Disable GlitchNPCManager completely to avoid conflicts
              if (typeof GlitchNPCManager !== 'undefined') {
                GlitchNPCManager.createGlitchNPC = function() { return null; };
                GlitchNPCManager.playSpecialAnimation = function() { return null; };
                GlitchNPCManager.update = function() { return null; };
              }
              
              // Set game state flags
              GameStateManager.state.glitchSpawned = true;
              console.log('EMERGENCY GLITCH MODE COMPLETE');
              
              // IMPORTANT: DO NOT call GlitchNPCManager.playSpecialAnimation()!
              // Instead, intercept and disable the GlitchNPCManager completely
              
              // Neutralize the GlitchNPCManager to prevent it from creating duplicates
              if (GlitchNPCManager) {
                // Save the original remove method
                const originalRemove = GlitchNPCManager.remove;
                
                // Override the GlitchNPCManager's create method to do nothing
                GlitchNPCManager.createGlitchNPC = function() {
                  console.log("🔍 DEBUG: Prevented GlitchNPCManager from creating duplicate NPC");
                  return null;
                };
                
                // Override playSpecialAnimation to do nothing
                GlitchNPCManager.playSpecialAnimation = function() {
                  console.log("🔍 DEBUG: Prevented GlitchNPCManager from playing duplicate animation");
                  return this;
                };
                
                // Make sure we keep our DOM element intact when GlitchNPCManager tries to remove NPCs
                GlitchNPCManager.remove = function() {
                  console.log("🔍 DEBUG: Modified remove to keep our direct DOM glitch");
                  // Only remove the game engine NPCs, not our DOM implementation
                  if (GameStateManager.state.npcs) {
                    GameStateManager.state.npcs = GameStateManager.state.npcs.filter(npc => npc.type !== "GlitchNPC");
                  }
                  GameStateManager.state.glitchNPC = null;
                };
                
                // Set game state flags to indicate the glitch has appeared
                GameStateManager.state.glitchSpawned = true;
              }
            }
          }
          
          if (this.currentIndex >= this.currentDialogue.length) {
            this.end();
            return;
          }

          this.showCurrentMessage();
        },

        // End dialogue
        end() {
          const dialogueBox = document.getElementById("dialogueBox");
          dialogueBox.style.display = "none";
          this.isActive = false;
          document.removeEventListener("keydown", this.handleKeyPress);
          
          // Clean up Glitch NPC animation if dialogue ends while it's active
          if (this.currentDialogue === this.dialogues.glitchStick &&
              typeof GlitchNPCManager !== 'undefined') {
            
            // Stop any running animation interval
            if (GlitchNPCManager.animationInterval) {
              console.log("Cleaning up animation interval on dialogue end");
              clearInterval(GlitchNPCManager.animationInterval);
              GlitchNPCManager.animationInterval = null;
            }
            
            // Get our overlay and glitch elements if they exist
            const overlay = document.getElementById('game-overlay');
            const glitch = document.getElementById('overlay-glitch');
            const frameElements = [];
            for (let i = 0; i < 3; i++) {
              const frame = document.getElementById(`glitch-frame-${i}`);
              if (frame) frameElements.push(frame);
            }
            
            // If our glitch overlay exists and we're past the 4th press,
            // play the exit animation sequence
            if (overlay && glitch && frameElements.length > 0 && 
                GlitchNPCManager.state.spacebarPressCount >= 4) {
              
              console.log("Starting glitch dismissal animation sequence");
              
              // Create or get the flash element
              let flash = document.getElementById('glitch-flash');
              if (!flash) {
                flash = document.createElement('div');
                flash.id = 'glitch-flash';
                flash.style.cssText = `
                  position: absolute;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  background: white;
                  opacity: 0;
                  pointer-events: none;
                  z-index: 9999;
                  transition: opacity 0.1s ease-in-out;
                `;
                overlay.appendChild(flash);
              }
              
              // Animation variables for much faster exit
              let isAnimating = true;
              let currentFrame = 0;
              let cyclesCompleted = 0;
              let frameDelay = 50; // Very fast animation (50ms per frame)
              
              // Show glitch if it was hidden
              glitch.style.opacity = '1';
              
              // Stop any existing bobbing animation
              glitch.style.animation = 'none';
              
              // Animation sequence that runs in reverse order but much faster
              const animateFramesReverse = () => {
                if (!isAnimating) return;
                
                // Hide all frames
                frameElements.forEach(frame => frame.style.display = 'none');
                
                // Show current frame
                frameElements[currentFrame].style.display = 'block';
                
                // Apply flip transformation - alternate each cycle
                const shouldFlip = cyclesCompleted % 2 === 0;
                frameElements[currentFrame].style.transform = shouldFlip ? 'scaleX(-1)' : 'scaleX(1)';
                
                // Move to next frame
                currentFrame = (currentFrame + 1) % frameElements.length;
                
                // If we've completed a cycle
                if (currentFrame === 0) {
                  cyclesCompleted++;
                  console.log(`Dismissal: Completed cycle ${cyclesCompleted}`);
                  
                  // After just 2 cycles, play final flash and remove
                  if (cyclesCompleted >= 2) {
                    isAnimating = false;
                    
                    // Play the final flash
                    flash.style.animation = 'flashAnimation 0.5s ease-in-out';
                    
                    // Remove the glitch after the flash
                    setTimeout(() => {
                      // Remove all elements
                      overlay.remove();
                      document.getElementById('glitch-indicator')?.remove();
                      
                      console.log('Glitch dismissed with exit animation');
                    }, 450); // Just before flash ends
                    
                    return;
                  }
                }
                
                // Continue animation sequence with the current speed
                setTimeout(animateFramesReverse, frameDelay);
              };
              
              // Start the exit animation sequence
              animateFramesReverse();
            } else {
              // If no custom overlay found, clean up any existing GlitchNPCManager elements
              console.log("No custom glitch overlay found, cleaning up standard elements");
              if (GlitchNPCManager.remove) {
                GlitchNPCManager.remove();
              }
            }
          }

          // Handle post-dialogue actions
          if (this.currentDialogue === this.dialogues.glitchStick) {
            // Use window.RELIC_SYSTEM to add Glitch Stick as a relic
            // Make sure player object exists
            if (GameStateManager.state.player) {
              // Use RELIC_SYSTEM to acquire the Glitch Stick
              window.RELIC_SYSTEM.initializeRelics(GameStateManager.state.player);
              
              // Set level to 1 to activate the relic
              if (!GameStateManager.state.player.relics.glitchStick || GameStateManager.state.player.relics.glitchStick.level === 0) {
                // Either initialize or set level to 1 if it's at 0
                if (!GameStateManager.state.player.relics.glitchStick) {
                  window.RELIC_SYSTEM.acquireGlitchStick(GameStateManager.state.player);
                }
                
                // Set the level to 1 to activate it
                GameStateManager.state.player.relics.glitchStick.level = 1;
                
                UIManager.log("Acquired the Glitch Stick! Check your relics tab to equip it.");
              }
              
              // Mark relic as claimed in the game state
              GameStateManager.state.relics = GameStateManager.state.relics || {};
              GameStateManager.state.relics.glitchStickClaimed = true;
              
              // Remove from inventory if it exists there (for backwards compatibility)
              if (GameStateManager.state.inventory) {
                const glitchStickIndex = GameStateManager.state.inventory.findIndex(i => 
                  i.name === 'Glitch Stick' || 
                  i.name === 'The Glitch Stick™');
                if (glitchStickIndex >= 0) {
                  GameStateManager.state.inventory.splice(glitchStickIndex, 1);
                  console.log('Removed Glitch Stick from inventory');
                }
              }

              // Add XP reward - FIX for NaN error
              if (GameStateManager.state.player) {
                try {
                  // Make sure current XP is a valid number
                  if (typeof GameStateManager.state.player.xp !== 'number' || isNaN(GameStateManager.state.player.xp)) {
                    console.log('Fixing invalid XP value:', GameStateManager.state.player.xp);
                    GameStateManager.state.player.xp = 0;
                  }
                  
                  // Reset XP system completely if it's not initialized correctly
                  const player = GameStateManager.state.player;

                  // Initialize XP properties if missing
                  if (typeof player.xp === 'undefined' || player.xp === null || isNaN(player.xp)) {
                    player.xp = 0;
                    console.log('Player XP was invalid, reset to 0');
                  }
                  
                  if (typeof player.level === 'undefined' || player.level === null || isNaN(player.level)) {
                    player.level = 1;
                    console.log('Player level was invalid, reset to 1');
                  }
                  
                  if (typeof player.xpToNextLevel === 'undefined' || player.xpToNextLevel === null || isNaN(player.xpToNextLevel)) {
                    player.xpToNextLevel = 100;
                    console.log('XP to next level was invalid, reset to 100');
                  }
                  
                  // Always use a robust XP addition method
                  const addXpToPlayer = (amount) => {
                    // Convert XP to a number or default to 0
                    const currentXp = typeof player.xp === 'number' ? player.xp : 0;
                    const xpAmount = typeof amount === 'number' ? amount : 0;
                    
                    // Calculate the new XP value
                    player.xp = currentXp + xpAmount;
                    
                    // Force as a number and check for NaN
                    player.xp = Number(player.xp);
                    if (isNaN(player.xp)) player.xp = currentXp;
                    
                    // Update UI
                    if (UIManager && typeof UIManager.updateStats === 'function') {
                      UIManager.updateStats();
                    } else if (UIManager && typeof UIManager.updatePlayerStats === 'function') {
                      UIManager.updatePlayerStats();
                    }
                    
                    console.log(`XP added: ${xpAmount}, Total XP: ${player.xp}`);
                    return true;
                  };
                  
                  // Add the XP
                  addXpToPlayer(50);
                  
                  // Add message to game log
                  UIManager.log('Gained 50 experience points!');
                  
                  // Update UI if possible
                  if (UIManager && typeof UIManager.updatePlayerStats === 'function') {
                    UIManager.updatePlayerStats();
                  }
                  
                  // Add a message to game log
                  UIManager.log('Gained 50 experience points!');
                } catch (e) {
                  console.error('Error adding XP:', e);
                }
              }
            }
          }

          // Fix player movement state when dialogue ends
          if (GameStateManager.state.player) {
            const player = GameStateManager.state.player;

            // Reset animation and movement state completely
            player.canMove = true;
            player.isMoving = false;
            player.moveTimeout = null;
            player.lastMoveTime = 0;

            // Reset all key states to prevent player from continuing to move
            if (GameStateManager.state.keys) {
              GameStateManager.state.keys.ArrowLeft = false;
              GameStateManager.state.keys.ArrowRight = false;
              GameStateManager.state.keys.ArrowUp = false;
              GameStateManager.state.keys.ArrowDown = false;
              GameStateManager.state.keys.w = false;
              GameStateManager.state.keys.a = false;
              GameStateManager.state.keys.s = false;
              GameStateManager.state.keys.d = false;
            }

            // Handle movement fixes for any problematic tiles in Arcade1
            if (GameStateManager.state.currentScene === "arcade1") {
              console.log(`DEBUG: Fixing player position after dialogue at (${player.x},${player.y})`);

              // Extra handling for left direction which seems to cause most issues
              if (GameStateManager.state.lastPlayerDirection === "left") {
                console.log("DEBUG: Special fix for left direction movement");
                // Force animation frame reset for left direction
                if (player.animationState) {
                  player.animationState.currentFrame = 0;
                  player.animationState.isMoving = false;
                  player.animationState.lastFrameUpdate = Date.now();
                }
              }

              // IMPORTANT: We've removed the automatic NPC spawning at dialogue end
              // Now the Glitch NPC will ONLY appear during the 4th spacebar press
              // (handled by GlitchNPCManager.handleSpacebarPress)
              console.log("DEBUG: Player at position (" + player.x + "," + player.y + ") after dialogue");
              
              // Just mark that we've been to this spot for other game mechanics
              if (player.x === 13 && player.y === 11 && !GameStateManager.state.glitchSpawned) {
                console.log("DEBUG: Marking special tile (13,11) as visited");
                GameStateManager.state.glitchSpawned = true;
              }

              // Clear the stored direction after using it
              GameStateManager.state.lastPlayerDirection = null;
            }
            // Removed incomplete if statement that was causing syntax error
            // The Glitch NPC spawning is already handled in the code above
          }

          // Restore previous game state
          if (this.previousGameState) {
            GameStateManager.state.currentState = this.previousGameState;
            this.previousGameState = null;
          } else {
            GameStateManager.state.currentState = GAME_STATES.EXPLORE;
          }
        },
      };

      // Using the window.RELIC_SYSTEM defined at the top of the file

      // RELIC INTEGRATION CODE - Added directly to HTML file
      // Ensure the relics tab exists in the character screen
      function ensureRelicsTab() {
        console.log('Ensuring relics tab exists...');
        const characterScreen = document.getElementById('characterScreen');
        if (!characterScreen) return;
        
        // Check if relics tab already exists
        if (!document.getElementById('relics-tab')) {
          // Create relics tab content
          const relicsTabContent = document.createElement('div');
          relicsTabContent.className = 'tab-content';
          relicsTabContent.id = 'relics-tab';
          relicsTabContent.innerHTML = `
            <div class="equipment-screen-content">
              <div class="equipment-list" id="relics-list">
                <!-- Relics will be added here dynamically -->
              </div>
              <div class="equipment-tooltip" id="relicTooltip">
                <div class="title">Relic Information</div>
                <div class="description">Click on a relic to see details</div>
              </div>
            </div>
          `;
          
          // Append to character screen
          const tabContents = characterScreen.querySelectorAll('.tab-content');
          if (tabContents.length > 0) {
            tabContents[tabContents.length - 1].parentNode.insertBefore(relicsTabContent, tabContents[tabContents.length - 1].nextSibling);
          } else {
            characterScreen.appendChild(relicsTabContent);
          }
          
          // Add relics tab button if it doesn't exist
          const tabNavigation = characterScreen.querySelector('.tab-navigation');
          if (tabNavigation && !tabNavigation.querySelector('[data-tab="relics-tab"]')) {
            const relicsTabButton = document.createElement('button');
            relicsTabButton.className = 'tab-button';
            relicsTabButton.setAttribute('data-tab', 'relics-tab');
            relicsTabButton.textContent = 'Relics';
            tabNavigation.appendChild(relicsTabButton);
            
            // Add event listener
            relicsTabButton.addEventListener('click', function() {
              // Hide all tab content
              const tabContents = document.querySelectorAll('.tab-content');
              tabContents.forEach(content => content.classList.remove('active'));
              
              // Show selected tab
              document.getElementById('relics-tab').classList.add('active');
              
              // Update tab buttons
              const tabButtons = document.querySelectorAll('.tab-button');
              tabButtons.forEach(button => button.classList.remove('active'));
              this.classList.add('active');
            });
          }
          
          console.log('Relics tab created and added to character screen');
        }
      }

      // Update the relics tab with available relics
      function updateRelicsTab(player) {
        console.log('Updating relics tab...');
        const relicsList = document.getElementById('relics-list');
        if (!relicsList) {
          console.warn('Relics list element not found');
          return;
        }
        
        // Clear existing content
        relicsList.innerHTML = '';
        
        // Check if player has relics
        if (!player.relics || Object.keys(player.relics).length === 0) {
          relicsList.innerHTML = '<div class="empty-message">No relics found</div>';
          return;
        }
        
        // Add each relic to the list
        for (const [relicKey, relic] of Object.entries(player.relics)) {
          // Skip relics with level 0 (not yet acquired)
          if (relic.level === 0) continue;
          
          const relicItem = document.createElement('div');
          relicItem.className = 'relic-item';
          relicItem.innerHTML = `
            <div class="relic-header">
              <span class="relic-name">${relic.name}</span>
              <span class="relic-level">Lvl ${relic.level}</span>
            </div>
            <div class="relic-description">${relic.description}</div>
            <div class="fury-bar">
              <div class="fury-fill" style="width: ${(relic.fury / relic.furyToNextLevel) * 100}%"></div>
            </div>
            <div class="relic-stats">+${relic.level} to all stats</div>
            <div class="relic-abilities">
              ${relic.abilities.map(ability => `
                <div class="ability-item">
                  <div class="ability-level ${ability.level <= relic.level ? 'unlocked' : 'locked'}" 
                       data-name="${ability.name}" 
                       data-description="${ability.description}">${ability.level}</div>
                  <div class="ability-info">
                    <div class="ability-name ${ability.level <= relic.level ? '' : 'locked'}" style="text-align: left !important;">${ability.name}</div>
                  </div>
                </div>
              `).join('')}
            </div>
          `;
          
          // Add click event for relic header to toggle equip status
          const relicHeader = relicItem.querySelector('.relic-header');
          if (relicHeader) {
            relicHeader.addEventListener('click', function(e) {
              e.stopPropagation(); // Prevent bubbling up to the relicItem click handler
              
              // Toggle equipped status
              if (window.RELIC_SYSTEM) {
                if (player.appliedRelicBonuses && player.appliedRelicBonuses[relicKey]) {
                  // Currently equipped, unequip it
                  window.RELIC_SYSTEM.removeRelicBonuses(player, relicKey);
                  console.log(`Unequipped relic: ${relic.name}`);
                  if (UIManager && UIManager.log) {
                    UIManager.log(`Unequipped relic: ${relic.name}`);
                  }
                } else {
                  // Currently unequipped, equip it
                  window.RELIC_SYSTEM.applyRelicBonuses(player, relicKey);
                  console.log(`Equipped relic: ${relic.name}`);
                  if (UIManager && UIManager.log) {
                    UIManager.log(`Equipped relic: ${relic.name}`);
                  }
                }
                // Make tab visible before updating - crucial to prevent disappearing
                const relicsTab = document.getElementById('relics-tab');
                if (relicsTab) {
                  relicsTab.classList.add('active');

                  // Make sure tab button is active too
                  const tabButtons = document.querySelectorAll('.tab-button');
                  tabButtons.forEach(btn => btn.classList.remove('active'));
                  const relicsButton = document.querySelector('[data-tab="relics-tab"]');
                  if (relicsButton) {
                    relicsButton.classList.add('active');
                  }
                }
                
                // Now update the display
                updateRelicsTab(player);

                // Force an update to the character screen to show relics in equipment tab
                UIManager.updateCharacterScreen();
                
                // Re-show the relics tab after update
                document.getElementById('relics-tab').classList.add('active');
              }
            });
          }
          
          // Add click handlers for ability levels to show tooltips
          const abilityLevels = relicItem.querySelectorAll('.ability-level.unlocked');
          abilityLevels.forEach(function(level) {
            level.addEventListener('click', function(e) {
              e.stopPropagation(); // Prevent bubbling up to the relicItem click handler
              
              const name = this.getAttribute('data-name');
              const description = this.getAttribute('data-description');
              if (name && description) {
                showAbilityTooltip(name, description);
              }
            });
          });
          
          // Add click event to the main relic item to use the ability
          relicItem.addEventListener('click', () => {
            // Don't process if tooltip is open
            const tooltip = document.getElementById('ability-tooltip');
            if (tooltip && !tooltip.classList.contains('hidden')) {
              hideAbilityTooltip();
              return;
            }
            
            // Ensure RELIC_SYSTEM is defined before using it
            if (window.RELIC_SYSTEM) {
              window.RELIC_SYSTEM.useRelicAbility(player, relicKey);
              updateRelicsTab(player); // Refresh the display
            } else {
              console.error('RELIC_SYSTEM is not defined!');
            }
          });
          
          relicsList.appendChild(relicItem);
        }
        
        console.log('Relics tab updated with player relics');
      }

      // Modified toggleCharacterScreen to update relics
      const originalToggleCharacterScreen = window.toggleCharacterScreen;
      window.toggleCharacterScreen = function() {
        if (originalToggleCharacterScreen) {
          originalToggleCharacterScreen();
        } else {
          const characterScreen = document.getElementById('characterScreen');
          if (characterScreen) {
            const isVisible = characterScreen.style.display !== 'none';
            characterScreen.style.display = isVisible ? 'none' : 'flex';
            
            if (!isVisible) {
              GameStateManager.state.currentState = GAME_STATES.CHARACTER_SCREEN;
            } else {
              GameStateManager.state.currentState = GAME_STATES.EXPLORE;
            }
          }
        }
        
        // Add our custom logic
        const characterScreen = document.getElementById('characterScreen');
        if (characterScreen && characterScreen.style.display !== 'none') {
          ensureRelicsTab();
          updateRelicsTab(GameStateManager.state.player);
          
          // Clear existing event listeners by cloning and replacing elements
          const tabNavigation = characterScreen.querySelector('.tab-navigation');
          if (tabNavigation) {
            const tabButtons = tabNavigation.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
              const newButton = button.cloneNode(true);
              button.parentNode.replaceChild(newButton, button);
              
              newButton.addEventListener('click', function(e) {
                // CRITICAL: Prevent event from bubbling up to other handlers
                e.stopPropagation();
                e.preventDefault();
                
                // Hide all tab content
                const tabContents = document.querySelectorAll('.tab-content');
                tabContents.forEach(content => content.classList.remove('active'));
                
                // Show selected tab
                const tabId = this.getAttribute('data-tab');
                const tabContent = document.getElementById(tabId);
                if (tabContent) {
                  tabContent.classList.add('active');
                } else {
                  console.warn(`Tab content not found: ${tabId}`);
                }
                
                // Update tab buttons
                const allTabButtons = document.querySelectorAll('.tab-button');
                allTabButtons.forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                
                // Log for debugging
                console.log(`Switched to tab: ${tabId}`);
                
                return false;
              });
            });
          }
        }
      };

      // CSS styles for relics
      const relicStylesElement = document.createElement('style');
      relicStylesElement.textContent = `
        .relic-item {
          display: flex;
          flex-direction: column;
          background: rgba(0, 0, 0, 0.5);
          border: 2px solid #00ffff;
          border-radius: 4px;
          padding: 10px;
          margin-bottom: 10px;
          cursor: pointer;
          transition: all 0.3s ease;
        }
        
        .relic-item:hover {
          background: rgba(0, 210, 211, 0.1);
          transform: translateY(-2px);
        }
        
        .relic-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 6px;
        }
        
        .relic-name {
          color: #00ffff;
          font-weight: bold;
          font-size: 14px;
          text-shadow: 0 0 10px #00ffff;
        }
        
        .relic-level {
          color: #00ff00;
          font-size: 12px;
          background: rgba(0, 0, 0, 0.7);
          padding: 2px 6px;
          border-radius: 10px;
          border: 1px solid #00ff00;
        }
        
        .relic-description {
          color: #ddd;
          font-size: 12px;
          margin-bottom: 6px;
          font-style: italic;
        }
        
        .fury-bar {
          height: 8px;
          background: rgba(0, 0, 0, 0.5);
          border-radius: 4px;
          overflow: hidden;
          margin-bottom: 8px;
          border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .fury-fill {
          height: 100%;
          background: linear-gradient(to right, #ff00ff, #00ffff);
          width: 0%;
          transition: width 0.3s ease;
        }
        
        .relic-stats {
          color: #fff;
          font-size: 11px;
          margin-bottom: 4px;
        }
        
        .relic-abilities {
          margin-top: 8px;
          border-top: 1px solid rgba(255, 255, 255, 0.2);
          padding-top: 6px;
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          grid-gap: 8px;
          margin-bottom: 65px; /* Space for tooltip */
          position: relative;
        }
        
        /* Fixed positioning for relic tooltip */
        #relicTooltip {
          position: absolute;
          bottom: -60px;
          left: 0;
          width: 100%;
          background: rgba(0, 0, 0, 0.8);
          border: 1px solid #00ffff;
          border-radius: 4px;
          padding: 8px;
          box-sizing: border-box;
          z-index: 10;
        }
        
        .ability-item {
          display: flex;
          align-items: center;
          margin: 4px 0;
          justify-content: flex-start; /* Ensure content is left-aligned */
          text-align: left; /* Set text alignment explicitly */
          width: 100%; /* Ensure full width */
          padding: 4px; /* Add padding for spacing */
          box-sizing: border-box; /* Include padding in width calculation */
        }
        
        /* Ensure all child elements are also left-aligned */
        .ability-item * {
          text-align: left !important;
        }
        
        /* Target the expanded ability details specifically */
        .ability-item-expanded,
        .ability-details,
        .ability-details * {
          text-align: left !important;
        }
        
        .ability-level {
          width: 24px;
          height: 24px;
          background: rgba(0, 0, 0, 0.7);
          border-radius: 50%;
          display: flex;
          justify-content: center;
          align-items: center;
          margin-right: 8px;
          color: #fff;
          font-size: 12px;
          font-weight: bold;
        }
        
        .ability-level.unlocked {
          background: #00ff00;
          color: #000;
        }
        
        .ability-level.locked {
          background: rgba(255, 0, 0, 0.5);
          color: #fff;
        }
        
        .ability-info {
          flex: 1;
        }
        
        .ability-name {
          color: #00ffff;
          font-weight: bold;
          font-size: 12px;
          text-align: left;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          max-width: 100%;
          padding-right: 5px;
        }
        
        .ability-name.locked {
          color: #777;
        }
        
        .ability-description {
          color: #999;
          font-size: 11px;
          font-style: italic;
          text-align: left;
        }
      `;
      document.head.appendChild(relicStylesElement);

      // Connect relic system with equipment manager
      // Override or extend equipment functions to handle relics
      if (typeof EquipmentManager !== 'undefined') {
        console.log('Connecting relic system with equipment manager...');
        
        // Store original equip function
        const originalEquip = EquipmentManager.equip;
        
        // Replace with our new function that handles relics
        EquipmentManager.equip = function(player, item) {
          console.log('Equipment manager equipping item:', item);
          
          // Call original function
          if (originalEquip) {
            const result = originalEquip.call(this, player, item);
            if (!result) {
              console.log('Original equip function returned false');
              return false;
            }
          }
          
          // Additional logic for relics
          if (item && item.type === EQUIPMENT_TYPES.RELIC) {
            console.log('Equipping relic:', item.name);
            
            // Handle specifically the Glitch Stick relic
            if (item.name === 'Glitch Stick') {
              console.log('Equipping Glitch Stick, applying stat bonuses');
              RELIC_SYSTEM.applyRelicBonuses(player, 'glitchStick');
              
              // Move from inventory to relics
              if (!player.relics) {
                RELIC_SYSTEM.initializeRelics(player);
              }
              
              // Make sure it's shown in the relics tab
              if (player.relics.glitchStick) {
                player.relics.glitchStick.level = Math.max(1, player.relics.glitchStick.level);
              }
              
              // Remove from inventory if it exists there
              if (player.inventory) {
                const glitchStickIndex = player.inventory.findIndex(i => i.name === 'Glitch Stick');
                if (glitchStickIndex >= 0) {
                  player.inventory.splice(glitchStickIndex, 1);
                  console.log('Removed Glitch Stick from inventory');
                }
              }
              
              // Force refresh UI
              updateCharacterScreen();
              return true;
            }
          }
          
          return true;
        };
        
        // Store original unequip function
        const originalUnequip = EquipmentManager.unequip;
        
        // Replace with our function that handles relics
        EquipmentManager.unequip = function(player, slot) {
          // Get the item before unequipping to check if it's a relic
          const itemBeforeUnequip = player.equipment[slot];
          
          // Call original unequip function
          const result = originalUnequip(player, slot);
          
          // Check if the slot contained a relic
          if (result && result.name === 'Glitch Stick') {
            console.log('Unequipped Glitch Stick, removing stat bonuses');
            
            // Remove the stat bonuses if they were applied
            if (player.appliedRelicBonuses && player.appliedRelicBonuses['glitchStick']) {
              const relicLevel = player.relics.glitchStick.level;
              
              // Remove the stat bonuses
              player.stats.strength -= relicLevel;
              player.stats.dexterity -= relicLevel;
              player.stats.intelligence -= relicLevel;
              player.stats.vitality -= relicLevel;
              player.stats.fortune -= relicLevel;
              player.stats.charisma -= relicLevel;
              
              // Mark as not applied
              player.appliedRelicBonuses['glitchStick'] = false;
              
              console.log(`Removed relic bonuses: -${relicLevel} to all stats`);
              
              // Recalculate derived stats
              if (typeof recalculateDerivedStats === 'function') {
                recalculateDerivedStats(player);
              }
              
              // Update UI
              if (typeof updateCharacterScreen === 'function') {
                updateCharacterScreen();
              }
            }
          }
          
          return result;
        };
        
        console.log('Equipment manager successfully connected to relic system');
      } else {
        console.warn('EquipmentManager not found, cannot integrate relic system');
      }
      
      // Initialize relic integration when page loads
      document.addEventListener('DOMContentLoaded', function() {
        console.log('Relic integration initialized');
        
        // Force initialize relics for the player
        if (GameStateManager && GameStateManager.state && GameStateManager.state.player) {
          if (!GameStateManager.state.player.relics) {
            console.log('Initializing relics for player...');
            // Ensure RELIC_SYSTEM is defined before using it
            if (window.RELIC_SYSTEM) {
              window.RELIC_SYSTEM.initializeRelics(GameStateManager.state.player);
            } else {
              console.error('RELIC_SYSTEM is not defined!');
            }
          }
          
          // Check if Glitch Stick is in inventory and move it to relics
          if (GameStateManager.state.player.inventory) {
            const glitchStickItem = GameStateManager.state.player.inventory.find(item => item.name === 'Glitch Stick');
            if (glitchStickItem) {
              console.log('Found Glitch Stick in inventory, ensuring it appears in relics tab');
              // Ensure RELIC_SYSTEM is defined before using it
              if (window.RELIC_SYSTEM) {
                window.RELIC_SYSTEM.acquireGlitchStick(GameStateManager.state.player);
              } else {
                console.error('RELIC_SYSTEM is not defined!');
              }
              
              // If the Glitch Stick is equipped, ensure bonuses are applied correctly
              const equippedGlitchStick = Object.values(GameStateManager.state.player.equipment || {}).find(item => item && item.name === 'Glitch Stick');
              if (equippedGlitchStick) {
                console.log('Glitch Stick is equipped, ensuring stat bonuses are applied');
                // Ensure RELIC_SYSTEM is defined before using it
                if (window.RELIC_SYSTEM) {
                  // Initialize the appliedRelicBonuses tracking object if needed
                  if (!GameStateManager.state.player.appliedRelicBonuses) {
                    GameStateManager.state.player.appliedRelicBonuses = {};
                  }
                  
                  // Only apply if not already applied
                  if (!GameStateManager.state.player.appliedRelicBonuses['glitchStick']) {
                    window.RELIC_SYSTEM.applyRelicBonuses(GameStateManager.state.player, 'glitchStick');
                  }
                } else {
                  console.error('RELIC_SYSTEM is not defined!');
                }
              }
            }
          }
        }
      });
    </script>
  </body>
</html>